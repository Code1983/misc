
build/app_ax45043_driver.elf:     file format elf32-littlearm


Disassembly of section .vectors:

08000000 <_vectors>:
 8000000:	20000400 	.word	0x20000400
 8000004:	080002b9 	.word	0x080002b9
 8000008:	080002bb 	.word	0x080002bb
 800000c:	080002bb 	.word	0x080002bb
 8000010:	080002bb 	.word	0x080002bb
 8000014:	080002bb 	.word	0x080002bb
 8000018:	080002bb 	.word	0x080002bb
 800001c:	080002bb 	.word	0x080002bb
 8000020:	080002bb 	.word	0x080002bb
 8000024:	080002bb 	.word	0x080002bb
 8000028:	080002bb 	.word	0x080002bb
 800002c:	08002b71 	.word	0x08002b71
 8000030:	080002bb 	.word	0x080002bb
 8000034:	080002bb 	.word	0x080002bb
 8000038:	080002bb 	.word	0x080002bb
 800003c:	080002bb 	.word	0x080002bb
 8000040:	080002bb 	.word	0x080002bb
 8000044:	080002bb 	.word	0x080002bb
 8000048:	080002bb 	.word	0x080002bb
 800004c:	080002bb 	.word	0x080002bb
 8000050:	080002bb 	.word	0x080002bb
 8000054:	080002bb 	.word	0x080002bb
 8000058:	080031b1 	.word	0x080031b1
 800005c:	08003171 	.word	0x08003171
 8000060:	08003131 	.word	0x08003131
 8000064:	080030f1 	.word	0x080030f1
 8000068:	080030b1 	.word	0x080030b1
 800006c:	08002ee1 	.word	0x08002ee1
 8000070:	08002eb1 	.word	0x08002eb1
 8000074:	08002e81 	.word	0x08002e81
 8000078:	08002e51 	.word	0x08002e51
 800007c:	08002e21 	.word	0x08002e21
 8000080:	08002df1 	.word	0x08002df1
 8000084:	08002dc1 	.word	0x08002dc1
 8000088:	080002bb 	.word	0x080002bb
 800008c:	080002bb 	.word	0x080002bb
 8000090:	080002bb 	.word	0x080002bb
 8000094:	080002bb 	.word	0x080002bb
 8000098:	080002bb 	.word	0x080002bb
 800009c:	08002ff1 	.word	0x08002ff1
 80000a0:	080002bb 	.word	0x080002bb
 80000a4:	080002bb 	.word	0x080002bb
 80000a8:	080002bb 	.word	0x080002bb
 80000ac:	080002bb 	.word	0x080002bb
 80000b0:	08002c01 	.word	0x08002c01
 80000b4:	080002bb 	.word	0x080002bb
 80000b8:	080002bb 	.word	0x080002bb
 80000bc:	080002bb 	.word	0x080002bb
 80000c0:	080002bb 	.word	0x080002bb
 80000c4:	080002bb 	.word	0x080002bb
 80000c8:	080002bb 	.word	0x080002bb
 80000cc:	080002bb 	.word	0x080002bb
 80000d0:	080002bb 	.word	0x080002bb
 80000d4:	080002bb 	.word	0x080002bb
 80000d8:	08002be1 	.word	0x08002be1
 80000dc:	080002bb 	.word	0x080002bb
 80000e0:	08002f11 	.word	0x08002f11
 80000e4:	080002bb 	.word	0x080002bb
 80000e8:	080002bb 	.word	0x080002bb
 80000ec:	080002bb 	.word	0x080002bb
 80000f0:	080002bb 	.word	0x080002bb
 80000f4:	080002bb 	.word	0x080002bb
 80000f8:	080002bb 	.word	0x080002bb
 80000fc:	08002d91 	.word	0x08002d91
 8000100:	080002bb 	.word	0x080002bb
 8000104:	080002bb 	.word	0x080002bb
 8000108:	080002bb 	.word	0x080002bb
 800010c:	080002bb 	.word	0x080002bb
 8000110:	080002bb 	.word	0x080002bb
 8000114:	080002bb 	.word	0x080002bb
 8000118:	080002bb 	.word	0x080002bb
 800011c:	080002bb 	.word	0x080002bb
 8000120:	08002d61 	.word	0x08002d61
 8000124:	08002d31 	.word	0x08002d31
 8000128:	08002d01 	.word	0x08002d01
 800012c:	08002cd1 	.word	0x08002cd1
 8000130:	08002ca1 	.word	0x08002ca1
 8000134:	080002bb 	.word	0x080002bb
 8000138:	080002bb 	.word	0x080002bb
 800013c:	080002bb 	.word	0x080002bb
 8000140:	080002bb 	.word	0x080002bb
 8000144:	080002bb 	.word	0x080002bb
 8000148:	080002bb 	.word	0x080002bb
 800014c:	080002bb 	.word	0x080002bb
 8000150:	08002c71 	.word	0x08002c71
 8000154:	08002c41 	.word	0x08002c41
 8000158:	08002c11 	.word	0x08002c11
 800015c:	080002bb 	.word	0x080002bb
 8000160:	080002bb 	.word	0x080002bb
 8000164:	080002bb 	.word	0x080002bb
 8000168:	080002bb 	.word	0x080002bb
 800016c:	080002bb 	.word	0x080002bb
 8000170:	080002bb 	.word	0x080002bb
 8000174:	080002bb 	.word	0x080002bb
 8000178:	080002bb 	.word	0x080002bb
 800017c:	080002bb 	.word	0x080002bb
 8000180:	080002bb 	.word	0x080002bb
 8000184:	080002bb 	.word	0x080002bb
 8000188:	080002bb 	.word	0x080002bb
 800018c:	080002bb 	.word	0x080002bb
 8000190:	080002bb 	.word	0x080002bb
 8000194:	080002bb 	.word	0x080002bb
 8000198:	080002bb 	.word	0x080002bb
 800019c:	080002bb 	.word	0x080002bb
 80001a0:	080002bb 	.word	0x080002bb
 80001a4:	080002bb 	.word	0x080002bb
 80001a8:	080002bb 	.word	0x080002bb
 80001ac:	080002bb 	.word	0x080002bb
 80001b0:	080002bb 	.word	0x080002bb
 80001b4:	080002bb 	.word	0x080002bb
 80001b8:	080002bb 	.word	0x080002bb
 80001bc:	080002bb 	.word	0x080002bb
 80001c0:	080002bb 	.word	0x080002bb
 80001c4:	080002bb 	.word	0x080002bb
 80001c8:	080002bb 	.word	0x080002bb
 80001cc:	080002bb 	.word	0x080002bb
 80001d0:	080002bb 	.word	0x080002bb
 80001d4:	080002bb 	.word	0x080002bb
 80001d8:	080002bb 	.word	0x080002bb
 80001dc:	080002bb 	.word	0x080002bb

Disassembly of section .text:

080001e0 <_crt0_entry>:
                .align  2
                .thumb_func
                .global _crt0_entry
_crt0_entry:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 80001e0:	b672      	cpsid	i

#if CRT0_FORCE_MSP_INIT == TRUE
                /* MSP stack pointers initialization.*/
                ldr     r0, =__main_stack_end__
 80001e2:	4827      	ldr	r0, [pc, #156]	; (8000280 <endfiniloop+0x4>)
                msr     MSP, r0
 80001e4:	f380 8808 	msr	MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 80001e8:	4826      	ldr	r0, [pc, #152]	; (8000284 <endfiniloop+0x8>)
                msr     PSP, r0
 80001ea:	f380 8809 	msr	PSP, r0

#if CRT0_VTOR_INIT == TRUE
                ldr     r0, =_vectors
 80001ee:	4826      	ldr	r0, [pc, #152]	; (8000288 <endfiniloop+0xc>)
                movw    r1, #SCB_VTOR & 0xFFFF
 80001f0:	f64e 5108 	movw	r1, #60680	; 0xed08
                movt    r1, #SCB_VTOR >> 16
 80001f4:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 80001f8:	6008      	str	r0, [r1, #0]

                /* Enforcing FPCA bit in the CONTROL register.*/
                movs    r0, #CRT0_CONTROL_INIT | CONTROL_FPCA

#else
                movs    r0, #CRT0_CONTROL_INIT
 80001fa:	2002      	movs	r0, #2
#endif

                /* CONTROL register initialization as configured.*/
                msr     CONTROL, r0
 80001fc:	f380 8814 	msr	CONTROL, r0
                isb
 8000200:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __core_init
 8000204:	f003 f824 	bl	8003250 <__core_init>
#endif

                /* Early initialization.*/
                bl      __early_init
 8000208:	f002 fce2 	bl	8002bd0 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 800020c:	f04f 3055 	mov.w	r0, #1431655765	; 0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 8000210:	491e      	ldr	r1, [pc, #120]	; (800028c <endfiniloop+0x10>)
                ldr     r2, =__main_stack_end__
 8000212:	4a1b      	ldr	r2, [pc, #108]	; (8000280 <endfiniloop+0x4>)

08000214 <msloop>:
msloop:
                cmp     r1, r2
 8000214:	4291      	cmp	r1, r2
                itt     lo
 8000216:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000218:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     msloop
 800021c:	e7fa      	bcc.n	8000214 <msloop>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 800021e:	491c      	ldr	r1, [pc, #112]	; (8000290 <endfiniloop+0x14>)
                ldr     r2, =__process_stack_end__
 8000220:	4a18      	ldr	r2, [pc, #96]	; (8000284 <endfiniloop+0x8>)

08000222 <psloop>:
psloop:
                cmp     r1, r2
 8000222:	4291      	cmp	r1, r2
                itt     lo
 8000224:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000226:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     psloop
 800022a:	e7fa      	bcc.n	8000222 <psloop>
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =__textdata_base__
 800022c:	4919      	ldr	r1, [pc, #100]	; (8000294 <endfiniloop+0x18>)
                ldr     r2, =__data_base__
 800022e:	4a1a      	ldr	r2, [pc, #104]	; (8000298 <endfiniloop+0x1c>)
                ldr     r3, =__data_end__
 8000230:	4b1a      	ldr	r3, [pc, #104]	; (800029c <endfiniloop+0x20>)

08000232 <dloop>:
dloop:
                cmp     r2, r3
 8000232:	429a      	cmp	r2, r3
                ittt    lo
 8000234:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
 8000236:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
 800023a:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     dloop
 800023e:	e7f8      	bcc.n	8000232 <dloop>
#endif

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
 8000240:	2000      	movs	r0, #0
                ldr     r1, =__bss_base__
 8000242:	4917      	ldr	r1, [pc, #92]	; (80002a0 <endfiniloop+0x24>)
                ldr     r2, =__bss_end__
 8000244:	4a17      	ldr	r2, [pc, #92]	; (80002a4 <endfiniloop+0x28>)

08000246 <bloop>:
bloop:
                cmp     r1, r2
 8000246:	4291      	cmp	r1, r2
                itt     lo
 8000248:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 800024a:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     bloop
 800024e:	e7fa      	bcc.n	8000246 <bloop>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 8000250:	f002 ffce 	bl	80031f0 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 8000254:	f002 fff4 	bl	8003240 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_base__
 8000258:	4c13      	ldr	r4, [pc, #76]	; (80002a8 <endfiniloop+0x2c>)
                ldr     r5, =__init_array_end__
 800025a:	4d14      	ldr	r5, [pc, #80]	; (80002ac <endfiniloop+0x30>)

0800025c <initloop>:
initloop:
                cmp     r4, r5
 800025c:	42ac      	cmp	r4, r5
                bge     endinitloop
 800025e:	da03      	bge.n	8000268 <endinitloop>
                ldr     r1, [r4], #4
 8000260:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 8000264:	4788      	blx	r1
                b       initloop
 8000266:	e7f9      	b.n	800025c <initloop>

08000268 <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 8000268:	f002 fc72 	bl	8002b50 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_base__
 800026c:	4c10      	ldr	r4, [pc, #64]	; (80002b0 <endfiniloop+0x34>)
                ldr     r5, =__fini_array_end__
 800026e:	4d11      	ldr	r5, [pc, #68]	; (80002b4 <endfiniloop+0x38>)

08000270 <finiloop>:
finiloop:
                cmp     r4, r5
 8000270:	42ac      	cmp	r4, r5
                bge     endfiniloop
 8000272:	da03      	bge.n	800027c <endfiniloop>
                ldr     r1, [r4], #4
 8000274:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 8000278:	4788      	blx	r1
                b       finiloop
 800027a:	e7f9      	b.n	8000270 <finiloop>

0800027c <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
 800027c:	f002 bfd8 	b.w	8003230 <__default_exit>
                ldr     r0, =__main_stack_end__
 8000280:	20000400 	.word	0x20000400
                ldr     r0, =__process_stack_end__
 8000284:	20000800 	.word	0x20000800
                ldr     r0, =_vectors
 8000288:	08000000 	.word	0x08000000
                ldr     r1, =__main_stack_base__
 800028c:	20000000 	.word	0x20000000
                ldr     r1, =__process_stack_base__
 8000290:	20000400 	.word	0x20000400
                ldr     r1, =__textdata_base__
 8000294:	08003584 	.word	0x08003584
                ldr     r2, =__data_base__
 8000298:	20000800 	.word	0x20000800
                ldr     r3, =__data_end__
 800029c:	20000bfc 	.word	0x20000bfc
                ldr     r1, =__bss_base__
 80002a0:	20000c00 	.word	0x20000c00
                ldr     r2, =__bss_end__
 80002a4:	20001210 	.word	0x20001210
                ldr     r4, =__init_array_base__
 80002a8:	080001e0 	.word	0x080001e0
                ldr     r5, =__init_array_end__
 80002ac:	080001e0 	.word	0x080001e0
                ldr     r4, =__fini_array_base__
 80002b0:	080001e0 	.word	0x080001e0
                ldr     r5, =__fini_array_end__
 80002b4:	080001e0 	.word	0x080001e0

080002b8 <Reset_Handler>:

        .align      2
        .thumb_func
        .weak       Reset_Handler
Reset_Handler:
         b          _crt0_entry
 80002b8:	e792      	b.n	80001e0 <_crt0_entry>

080002ba <BusFault_Handler>:
        .thumb_func
Vector3F8:
        .thumb_func
Vector3FC:
#endif
        bl          _unhandled_exception
 80002ba:	f000 f800 	bl	80002be <_unhandled_exception>

080002be <_unhandled_exception>:

        .thumb_func
        .weak       _unhandled_exception
_unhandled_exception:
.stay:
        b           .stay
 80002be:	e7fe      	b.n	80002be <_unhandled_exception>

080002c0 <_port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_switch
_port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
 80002c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if PORT_SWITCHED_REGIONS_NUMBER == 4
                push    {r4, r5, r6, r7, r8, r9, r10, r11}
#endif
#endif

                str     sp, [r1, #CONTEXT_OFFSET]
 80002c4:	f8c1 d00c 	str.w	sp, [r1, #12]
#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) &&                                \
    ((CORTEX_MODEL == 3) || (CORTEX_MODEL == 4))
                /* Workaround for ARM errata 752419, only applied if
                   condition exists for it to be triggered.*/
                ldr     r3, [r0, #CONTEXT_OFFSET]
 80002c8:	68c3      	ldr	r3, [r0, #12]
                mov     sp, r3
 80002ca:	469d      	mov	sp, r3

#if CORTEX_USE_FPU
                /* Restoring FPU context.*/
                vpop    {s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
 80002cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080002d0 <_port_thread_start>:
                bl      _stats_stop_measure_crit_thd
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
 80002d0:	2300      	movs	r3, #0
                msr     BASEPRI, r3
 80002d2:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
 80002d6:	4628      	mov	r0, r5
                blx     r4
 80002d8:	47a0      	blx	r4
                movs    r0, #0              /* MSG_OK */
 80002da:	2000      	movs	r0, #0
                bl      chThdExit
 80002dc:	f002 fc58 	bl	8002b90 <chThdExit>

080002e0 <_zombies>:
_zombies:       b       _zombies
 80002e0:	e7fe      	b.n	80002e0 <_zombies>

080002e2 <_port_switch_from_isr>:
                bl      _stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_lock
#endif
                bl      chSchDoReschedule
 80002e2:	f002 fc5d 	bl	8002ba0 <chSchDoReschedule>

080002e6 <_port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
 80002e6:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
.L1:            b       .L1
 80002e8:	e7fe      	b.n	80002e8 <_port_exit_from_isr+0x2>
	...

080002ec <memcpy>:
 80002ec:	4684      	mov	ip, r0
 80002ee:	ea41 0300 	orr.w	r3, r1, r0
 80002f2:	f013 0303 	ands.w	r3, r3, #3
 80002f6:	d16d      	bne.n	80003d4 <memcpy+0xe8>
 80002f8:	3a40      	subs	r2, #64	; 0x40
 80002fa:	d341      	bcc.n	8000380 <memcpy+0x94>
 80002fc:	f851 3b04 	ldr.w	r3, [r1], #4
 8000300:	f840 3b04 	str.w	r3, [r0], #4
 8000304:	f851 3b04 	ldr.w	r3, [r1], #4
 8000308:	f840 3b04 	str.w	r3, [r0], #4
 800030c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000310:	f840 3b04 	str.w	r3, [r0], #4
 8000314:	f851 3b04 	ldr.w	r3, [r1], #4
 8000318:	f840 3b04 	str.w	r3, [r0], #4
 800031c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000320:	f840 3b04 	str.w	r3, [r0], #4
 8000324:	f851 3b04 	ldr.w	r3, [r1], #4
 8000328:	f840 3b04 	str.w	r3, [r0], #4
 800032c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000330:	f840 3b04 	str.w	r3, [r0], #4
 8000334:	f851 3b04 	ldr.w	r3, [r1], #4
 8000338:	f840 3b04 	str.w	r3, [r0], #4
 800033c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000340:	f840 3b04 	str.w	r3, [r0], #4
 8000344:	f851 3b04 	ldr.w	r3, [r1], #4
 8000348:	f840 3b04 	str.w	r3, [r0], #4
 800034c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000350:	f840 3b04 	str.w	r3, [r0], #4
 8000354:	f851 3b04 	ldr.w	r3, [r1], #4
 8000358:	f840 3b04 	str.w	r3, [r0], #4
 800035c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000360:	f840 3b04 	str.w	r3, [r0], #4
 8000364:	f851 3b04 	ldr.w	r3, [r1], #4
 8000368:	f840 3b04 	str.w	r3, [r0], #4
 800036c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000370:	f840 3b04 	str.w	r3, [r0], #4
 8000374:	f851 3b04 	ldr.w	r3, [r1], #4
 8000378:	f840 3b04 	str.w	r3, [r0], #4
 800037c:	3a40      	subs	r2, #64	; 0x40
 800037e:	d2bd      	bcs.n	80002fc <memcpy+0x10>
 8000380:	3230      	adds	r2, #48	; 0x30
 8000382:	d311      	bcc.n	80003a8 <memcpy+0xbc>
 8000384:	f851 3b04 	ldr.w	r3, [r1], #4
 8000388:	f840 3b04 	str.w	r3, [r0], #4
 800038c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000390:	f840 3b04 	str.w	r3, [r0], #4
 8000394:	f851 3b04 	ldr.w	r3, [r1], #4
 8000398:	f840 3b04 	str.w	r3, [r0], #4
 800039c:	f851 3b04 	ldr.w	r3, [r1], #4
 80003a0:	f840 3b04 	str.w	r3, [r0], #4
 80003a4:	3a10      	subs	r2, #16
 80003a6:	d2ed      	bcs.n	8000384 <memcpy+0x98>
 80003a8:	320c      	adds	r2, #12
 80003aa:	d305      	bcc.n	80003b8 <memcpy+0xcc>
 80003ac:	f851 3b04 	ldr.w	r3, [r1], #4
 80003b0:	f840 3b04 	str.w	r3, [r0], #4
 80003b4:	3a04      	subs	r2, #4
 80003b6:	d2f9      	bcs.n	80003ac <memcpy+0xc0>
 80003b8:	3204      	adds	r2, #4
 80003ba:	d008      	beq.n	80003ce <memcpy+0xe2>
 80003bc:	07d2      	lsls	r2, r2, #31
 80003be:	bf1c      	itt	ne
 80003c0:	f811 3b01 	ldrbne.w	r3, [r1], #1
 80003c4:	f800 3b01 	strbne.w	r3, [r0], #1
 80003c8:	d301      	bcc.n	80003ce <memcpy+0xe2>
 80003ca:	880b      	ldrh	r3, [r1, #0]
 80003cc:	8003      	strh	r3, [r0, #0]
 80003ce:	4660      	mov	r0, ip
 80003d0:	4770      	bx	lr
 80003d2:	bf00      	nop
 80003d4:	2a08      	cmp	r2, #8
 80003d6:	d313      	bcc.n	8000400 <memcpy+0x114>
 80003d8:	078b      	lsls	r3, r1, #30
 80003da:	d08d      	beq.n	80002f8 <memcpy+0xc>
 80003dc:	f010 0303 	ands.w	r3, r0, #3
 80003e0:	d08a      	beq.n	80002f8 <memcpy+0xc>
 80003e2:	f1c3 0304 	rsb	r3, r3, #4
 80003e6:	1ad2      	subs	r2, r2, r3
 80003e8:	07db      	lsls	r3, r3, #31
 80003ea:	bf1c      	itt	ne
 80003ec:	f811 3b01 	ldrbne.w	r3, [r1], #1
 80003f0:	f800 3b01 	strbne.w	r3, [r0], #1
 80003f4:	d380      	bcc.n	80002f8 <memcpy+0xc>
 80003f6:	f831 3b02 	ldrh.w	r3, [r1], #2
 80003fa:	f820 3b02 	strh.w	r3, [r0], #2
 80003fe:	e77b      	b.n	80002f8 <memcpy+0xc>
 8000400:	3a04      	subs	r2, #4
 8000402:	d3d9      	bcc.n	80003b8 <memcpy+0xcc>
 8000404:	3a01      	subs	r2, #1
 8000406:	f811 3b01 	ldrb.w	r3, [r1], #1
 800040a:	f800 3b01 	strb.w	r3, [r0], #1
 800040e:	d2f9      	bcs.n	8000404 <memcpy+0x118>
 8000410:	780b      	ldrb	r3, [r1, #0]
 8000412:	7003      	strb	r3, [r0, #0]
 8000414:	784b      	ldrb	r3, [r1, #1]
 8000416:	7043      	strb	r3, [r0, #1]
 8000418:	788b      	ldrb	r3, [r1, #2]
 800041a:	7083      	strb	r3, [r0, #2]
 800041c:	4660      	mov	r0, ip
 800041e:	4770      	bx	lr

08000420 <long_to_string_with_divisor>:
#define FLOAT_PRECISION 9

static char *long_to_string_with_divisor(char *p,
                                         long num,
                                         unsigned radix,
                                         long divisor) {
 8000420:	b4f0      	push	{r4, r5, r6, r7}
 8000422:	460c      	mov	r4, r1
  int i;
  char *q;
  long l, ll;

  l = num;
  if (divisor == 0) {
 8000424:	461e      	mov	r6, r3
 8000426:	b903      	cbnz	r3, 800042a <long_to_string_with_divisor+0xa>
    ll = num;
 8000428:	460e      	mov	r6, r1
  } else {
    ll = divisor;
  }

  q = p + MAX_FILLER;
 800042a:	f100 050b 	add.w	r5, r0, #11
 800042e:	462b      	mov	r3, r5
 8000430:	e006      	b.n	8000440 <long_to_string_with_divisor+0x20>
    i = (int)(l % radix);
    i += '0';
    if (i > '9') {
      i += 'A' - '0' - 10;
    }
    *--q = i;
 8000432:	f803 4d01 	strb.w	r4, [r3, #-1]!
    l /= radix;
 8000436:	fbb7 f4f2 	udiv	r4, r7, r2
  } while ((ll /= radix) != 0);
 800043a:	fbb6 f6f2 	udiv	r6, r6, r2
 800043e:	b15e      	cbz	r6, 8000458 <long_to_string_with_divisor+0x38>
    i = (int)(l % radix);
 8000440:	4627      	mov	r7, r4
 8000442:	fbb4 f1f2 	udiv	r1, r4, r2
 8000446:	fb02 4111 	mls	r1, r2, r1, r4
    i += '0';
 800044a:	f101 0430 	add.w	r4, r1, #48	; 0x30
    if (i > '9') {
 800044e:	2c39      	cmp	r4, #57	; 0x39
 8000450:	ddef      	ble.n	8000432 <long_to_string_with_divisor+0x12>
      i += 'A' - '0' - 10;
 8000452:	f101 0437 	add.w	r4, r1, #55	; 0x37
 8000456:	e7ec      	b.n	8000432 <long_to_string_with_divisor+0x12>

  i = (int)(p + MAX_FILLER - q);
 8000458:	1aec      	subs	r4, r5, r3
  do
    *p++ = *q++;
 800045a:	7819      	ldrb	r1, [r3, #0]
 800045c:	3301      	adds	r3, #1
 800045e:	7001      	strb	r1, [r0, #0]
 8000460:	3001      	adds	r0, #1
  while (--i);
 8000462:	3c01      	subs	r4, #1
 8000464:	d1f9      	bne.n	800045a <long_to_string_with_divisor+0x3a>

  return p;
}
 8000466:	bcf0      	pop	{r4, r5, r6, r7}
 8000468:	4770      	bx	lr
 800046a:	bf00      	nop
 800046c:	0000      	movs	r0, r0
	...

08000470 <ch_ltoa>:

static char *ch_ltoa(char *p, long num, unsigned radix) {
 8000470:	b508      	push	{r3, lr}

  return long_to_string_with_divisor(p, num, radix, 0);
 8000472:	2300      	movs	r3, #0
 8000474:	f7ff ffd4 	bl	8000420 <long_to_string_with_divisor>
}
 8000478:	bd08      	pop	{r3, pc}
 800047a:	bf00      	nop
 800047c:	0000      	movs	r0, r0
	...

08000480 <chvprintf>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 8000480:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000484:	b087      	sub	sp, #28
 8000486:	4606      	mov	r6, r0
 8000488:	4689      	mov	r9, r1
 800048a:	9201      	str	r2, [sp, #4]
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
 800048c:	2700      	movs	r7, #0
 800048e:	e005      	b.n	800049c <chvprintf+0x1c>
    if (c == 0) {
      return n;
    }
    
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
 8000490:	6833      	ldr	r3, [r6, #0]
 8000492:	68db      	ldr	r3, [r3, #12]
 8000494:	4630      	mov	r0, r6
 8000496:	4798      	blx	r3
      n++;
 8000498:	3701      	adds	r7, #1
    c = *fmt++;
 800049a:	46a9      	mov	r9, r5
 800049c:	464d      	mov	r5, r9
 800049e:	f815 1b01 	ldrb.w	r1, [r5], #1
    if (c == 0) {
 80004a2:	2900      	cmp	r1, #0
 80004a4:	d07b      	beq.n	800059e <chvprintf+0x11e>
    if (c != '%') {
 80004a6:	2925      	cmp	r1, #37	; 0x25
 80004a8:	d1f2      	bne.n	8000490 <chvprintf+0x10>
    p = tmpbuf;
    s = tmpbuf;

    /* Alignment mode.*/
    left_align = false;
    if (*fmt == '-') {
 80004aa:	782b      	ldrb	r3, [r5, #0]
 80004ac:	2b2d      	cmp	r3, #45	; 0x2d
 80004ae:	d043      	beq.n	8000538 <chvprintf+0xb8>
    left_align = false;
 80004b0:	f04f 0a00 	mov.w	sl, #0
      left_align = true;
    }

    /* Sign mode.*/
    do_sign = false;
    if (*fmt == '+') {
 80004b4:	782b      	ldrb	r3, [r5, #0]
 80004b6:	2b2b      	cmp	r3, #43	; 0x2b
 80004b8:	d043      	beq.n	8000542 <chvprintf+0xc2>
    do_sign = false;
 80004ba:	2200      	movs	r2, #0
      do_sign = true;
    }

    /* Filler mode.*/
    filler = ' ';
    if (*fmt == '0') {
 80004bc:	f895 8000 	ldrb.w	r8, [r5]
 80004c0:	f1b8 0f30 	cmp.w	r8, #48	; 0x30
 80004c4:	d040      	beq.n	8000548 <chvprintf+0xc8>
    filler = ' ';
 80004c6:	f04f 0820 	mov.w	r8, #32
      fmt++;
      filler = '0';
    }
    
    /* Width modifier.*/
    if (c == '*') {
 80004ca:	292a      	cmp	r1, #42	; 0x2a
 80004cc:	d13e      	bne.n	800054c <chvprintf+0xcc>
      width = va_arg(ap, int);
 80004ce:	9b01      	ldr	r3, [sp, #4]
 80004d0:	1d18      	adds	r0, r3, #4
 80004d2:	9001      	str	r0, [sp, #4]
 80004d4:	681c      	ldr	r4, [r3, #0]
      }
    }
    
    /* Precision modifier.*/
    precision = 0;
    if (c == '.') {
 80004d6:	292e      	cmp	r1, #46	; 0x2e
 80004d8:	d046      	beq.n	8000568 <chvprintf+0xe8>
    precision = 0;
 80004da:	2300      	movs	r3, #0
        }
      }
    }
    
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 80004dc:	296c      	cmp	r1, #108	; 0x6c
 80004de:	d064      	beq.n	80005aa <chvprintf+0x12a>
 80004e0:	294c      	cmp	r1, #76	; 0x4c
 80004e2:	d062      	beq.n	80005aa <chvprintf+0x12a>
      if (c == 0) {
        return n;
      }
    }
    else {
      is_long = (c >= 'A') && (c <= 'Z');
 80004e4:	f1a1 0041 	sub.w	r0, r1, #65	; 0x41
 80004e8:	b2c0      	uxtb	r0, r0
 80004ea:	2819      	cmp	r0, #25
 80004ec:	bf8c      	ite	hi
 80004ee:	2000      	movhi	r0, #0
 80004f0:	2001      	movls	r0, #1
 80004f2:	46a9      	mov	r9, r5
    }

    /* Command decoding.*/
    switch (c) {
 80004f4:	f1a1 0544 	sub.w	r5, r1, #68	; 0x44
 80004f8:	2d34      	cmp	r5, #52	; 0x34
 80004fa:	f200 80c8 	bhi.w	800068e <chvprintf+0x20e>
 80004fe:	e8df f005 	tbb	[pc, r5]
 8000502:	c67f      	.short	0xc67f
 8000504:	7fc6c6c6 	.word	0x7fc6c6c6
 8000508:	c6c6c6c6 	.word	0xc6c6c6c6
 800050c:	c6c65bc6 	.word	0xc6c65bc6
 8000510:	9fc6c6c6 	.word	0x9fc6c6c6
 8000514:	c6bfc6c6 	.word	0xc6bfc6c6
 8000518:	c6c6c6c6 	.word	0xc6c6c6c6
 800051c:	c6c6c6c6 	.word	0xc6c6c6c6
 8000520:	c67f5dc6 	.word	0xc67f5dc6
 8000524:	7fc6c6c6 	.word	0x7fc6c6c6
 8000528:	c6c6c6c6 	.word	0xc6c6c6c6
 800052c:	c6c65bc6 	.word	0xc6c65bc6
 8000530:	9fc669c6 	.word	0x9fc669c6
 8000534:	c6c6      	.short	0xc6c6
 8000536:	bf          	.byte	0xbf
 8000537:	00          	.byte	0x00
      fmt++;
 8000538:	f109 0502 	add.w	r5, r9, #2
      left_align = true;
 800053c:	f04f 0a01 	mov.w	sl, #1
 8000540:	e7b8      	b.n	80004b4 <chvprintf+0x34>
      fmt++;
 8000542:	3501      	adds	r5, #1
      do_sign = true;
 8000544:	2201      	movs	r2, #1
 8000546:	e7b9      	b.n	80004bc <chvprintf+0x3c>
      fmt++;
 8000548:	3501      	adds	r5, #1
      filler = '0';
 800054a:	e7be      	b.n	80004ca <chvprintf+0x4a>
      width = 0;
 800054c:	2400      	movs	r4, #0
        c = *fmt++;
 800054e:	f815 1b01 	ldrb.w	r1, [r5], #1
        if (c == 0) {
 8000552:	b321      	cbz	r1, 800059e <chvprintf+0x11e>
        if (c >= '0' && c <= '9') {
 8000554:	f1a1 0330 	sub.w	r3, r1, #48	; 0x30
 8000558:	b2db      	uxtb	r3, r3
 800055a:	2b09      	cmp	r3, #9
 800055c:	d8bb      	bhi.n	80004d6 <chvprintf+0x56>
          width = width * 10 + c;
 800055e:	eb04 0484 	add.w	r4, r4, r4, lsl #2
 8000562:	eb03 0444 	add.w	r4, r3, r4, lsl #1
      while (true) {
 8000566:	e7f2      	b.n	800054e <chvprintf+0xce>
      c = *fmt++;
 8000568:	4628      	mov	r0, r5
 800056a:	f810 1b01 	ldrb.w	r1, [r0], #1
      if (c == 0) {
 800056e:	b1b1      	cbz	r1, 800059e <chvprintf+0x11e>
      if (c == '*') {
 8000570:	292a      	cmp	r1, #42	; 0x2a
 8000572:	d106      	bne.n	8000582 <chvprintf+0x102>
        precision = va_arg(ap, int);
 8000574:	9b01      	ldr	r3, [sp, #4]
 8000576:	1d19      	adds	r1, r3, #4
 8000578:	9101      	str	r1, [sp, #4]
 800057a:	681b      	ldr	r3, [r3, #0]
        c = *fmt++;
 800057c:	7869      	ldrb	r1, [r5, #1]
 800057e:	3502      	adds	r5, #2
 8000580:	e7ac      	b.n	80004dc <chvprintf+0x5c>
    precision = 0;
 8000582:	2300      	movs	r3, #0
        while (c >= '0' && c <= '9') {
 8000584:	f1a1 0530 	sub.w	r5, r1, #48	; 0x30
 8000588:	b2ed      	uxtb	r5, r5
 800058a:	2d09      	cmp	r5, #9
 800058c:	d80b      	bhi.n	80005a6 <chvprintf+0x126>
          precision = precision * 10 + c;
 800058e:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8000592:	eb05 0343 	add.w	r3, r5, r3, lsl #1
          c = *fmt++;
 8000596:	f810 1b01 	ldrb.w	r1, [r0], #1
          if (c == 0) {
 800059a:	2900      	cmp	r1, #0
 800059c:	d1f2      	bne.n	8000584 <chvprintf+0x104>
      streamPut(chp, (uint8_t)filler);
      n++;
      width--;
    }
  }
}
 800059e:	4638      	mov	r0, r7
 80005a0:	b007      	add	sp, #28
 80005a2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        while (c >= '0' && c <= '9') {
 80005a6:	4605      	mov	r5, r0
 80005a8:	e798      	b.n	80004dc <chvprintf+0x5c>
      c = *fmt++;
 80005aa:	46a9      	mov	r9, r5
 80005ac:	f819 1b01 	ldrb.w	r1, [r9], #1
      if (c == 0) {
 80005b0:	2900      	cmp	r1, #0
 80005b2:	d0f4      	beq.n	800059e <chvprintf+0x11e>
      is_long = true;
 80005b4:	2001      	movs	r0, #1
 80005b6:	e79d      	b.n	80004f4 <chvprintf+0x74>
      c = 16;
 80005b8:	2208      	movs	r2, #8
 80005ba:	e042      	b.n	8000642 <chvprintf+0x1c2>
      *p++ = va_arg(ap, int);
 80005bc:	9b01      	ldr	r3, [sp, #4]
 80005be:	1d1a      	adds	r2, r3, #4
 80005c0:	9201      	str	r2, [sp, #4]
 80005c2:	681b      	ldr	r3, [r3, #0]
 80005c4:	f88d 300c 	strb.w	r3, [sp, #12]
      filler = ' ';
 80005c8:	f04f 0820 	mov.w	r8, #32
    s = tmpbuf;
 80005cc:	ad03      	add	r5, sp, #12
      *p++ = va_arg(ap, int);
 80005ce:	f10d 000d 	add.w	r0, sp, #13
 80005d2:	e03f      	b.n	8000654 <chvprintf+0x1d4>
      if ((s = va_arg(ap, char *)) == 0) {
 80005d4:	9a01      	ldr	r2, [sp, #4]
 80005d6:	1d11      	adds	r1, r2, #4
 80005d8:	9101      	str	r1, [sp, #4]
 80005da:	6815      	ldr	r5, [r2, #0]
 80005dc:	b115      	cbz	r5, 80005e4 <chvprintf+0x164>
      if (precision == 0) {
 80005de:	b163      	cbz	r3, 80005fa <chvprintf+0x17a>
        precision = 32767;
 80005e0:	4628      	mov	r0, r5
 80005e2:	e002      	b.n	80005ea <chvprintf+0x16a>
        s = "(null)";
 80005e4:	4d40      	ldr	r5, [pc, #256]	; (80006e8 <chvprintf+0x268>)
 80005e6:	e7fa      	b.n	80005de <chvprintf+0x15e>
      for (p = s; *p && (--precision >= 0); p++)
 80005e8:	3001      	adds	r0, #1
 80005ea:	7802      	ldrb	r2, [r0, #0]
 80005ec:	2a00      	cmp	r2, #0
 80005ee:	d054      	beq.n	800069a <chvprintf+0x21a>
 80005f0:	3b01      	subs	r3, #1
 80005f2:	d5f9      	bpl.n	80005e8 <chvprintf+0x168>
      filler = ' ';
 80005f4:	f04f 0820 	mov.w	r8, #32
 80005f8:	e02c      	b.n	8000654 <chvprintf+0x1d4>
        precision = 32767;
 80005fa:	f647 73ff 	movw	r3, #32767	; 0x7fff
 80005fe:	e7ef      	b.n	80005e0 <chvprintf+0x160>
      if (is_long) {
 8000600:	b160      	cbz	r0, 800061c <chvprintf+0x19c>
        l = va_arg(ap, long);
 8000602:	9b01      	ldr	r3, [sp, #4]
 8000604:	1d19      	adds	r1, r3, #4
 8000606:	9101      	str	r1, [sp, #4]
 8000608:	6819      	ldr	r1, [r3, #0]
      if (l < 0) {
 800060a:	2900      	cmp	r1, #0
 800060c:	db0b      	blt.n	8000626 <chvprintf+0x1a6>
        if (do_sign) {
 800060e:	b1aa      	cbz	r2, 800063c <chvprintf+0x1bc>
          *p++ = '+';
 8000610:	232b      	movs	r3, #43	; 0x2b
 8000612:	f88d 300c 	strb.w	r3, [sp, #12]
 8000616:	f10d 000d 	add.w	r0, sp, #13
 800061a:	e00a      	b.n	8000632 <chvprintf+0x1b2>
        l = va_arg(ap, int);
 800061c:	9b01      	ldr	r3, [sp, #4]
 800061e:	1d19      	adds	r1, r3, #4
 8000620:	9101      	str	r1, [sp, #4]
 8000622:	6819      	ldr	r1, [r3, #0]
 8000624:	e7f1      	b.n	800060a <chvprintf+0x18a>
        *p++ = '-';
 8000626:	232d      	movs	r3, #45	; 0x2d
 8000628:	f88d 300c 	strb.w	r3, [sp, #12]
        l = -l;
 800062c:	4249      	negs	r1, r1
        *p++ = '-';
 800062e:	f10d 000d 	add.w	r0, sp, #13
      p = ch_ltoa(p, l, 10);
 8000632:	220a      	movs	r2, #10
 8000634:	f7ff ff1c 	bl	8000470 <ch_ltoa>
    s = tmpbuf;
 8000638:	ad03      	add	r5, sp, #12
 800063a:	e00b      	b.n	8000654 <chvprintf+0x1d4>
    p = tmpbuf;
 800063c:	a803      	add	r0, sp, #12
 800063e:	e7f8      	b.n	8000632 <chvprintf+0x1b2>
      c = 10;
 8000640:	220a      	movs	r2, #10
      if (is_long) {
 8000642:	b1f8      	cbz	r0, 8000684 <chvprintf+0x204>
        l = va_arg(ap, unsigned long);
 8000644:	9b01      	ldr	r3, [sp, #4]
 8000646:	1d19      	adds	r1, r3, #4
 8000648:	9101      	str	r1, [sp, #4]
 800064a:	6819      	ldr	r1, [r3, #0]
      p = ch_ltoa(p, l, c);
 800064c:	a803      	add	r0, sp, #12
 800064e:	f7ff ff0f 	bl	8000470 <ch_ltoa>
    s = tmpbuf;
 8000652:	ad03      	add	r5, sp, #12
    i = (int)(p - s);
 8000654:	eba0 0b05 	sub.w	fp, r0, r5
    if ((width -= i) < 0) {
 8000658:	ebb4 040b 	subs.w	r4, r4, fp
 800065c:	d420      	bmi.n	80006a0 <chvprintf+0x220>
    if (left_align == false) {
 800065e:	f1ba 0f00 	cmp.w	sl, #0
 8000662:	d100      	bne.n	8000666 <chvprintf+0x1e6>
      width = -width;
 8000664:	4264      	negs	r4, r4
    if (width < 0) {
 8000666:	2c00      	cmp	r4, #0
 8000668:	db1c      	blt.n	80006a4 <chvprintf+0x224>
    while (--i >= 0) {
 800066a:	f1bb 0b01 	subs.w	fp, fp, #1
 800066e:	d438      	bmi.n	80006e2 <chvprintf+0x262>
      streamPut(chp, (uint8_t)*s++);
 8000670:	6833      	ldr	r3, [r6, #0]
 8000672:	68db      	ldr	r3, [r3, #12]
 8000674:	f815 1b01 	ldrb.w	r1, [r5], #1
 8000678:	4630      	mov	r0, r6
 800067a:	4798      	blx	r3
      n++;
 800067c:	3701      	adds	r7, #1
 800067e:	e7f4      	b.n	800066a <chvprintf+0x1ea>
      c = 16;
 8000680:	2210      	movs	r2, #16
 8000682:	e7de      	b.n	8000642 <chvprintf+0x1c2>
        l = va_arg(ap, unsigned int);
 8000684:	9b01      	ldr	r3, [sp, #4]
 8000686:	1d19      	adds	r1, r3, #4
 8000688:	9101      	str	r1, [sp, #4]
 800068a:	6819      	ldr	r1, [r3, #0]
 800068c:	e7de      	b.n	800064c <chvprintf+0x1cc>
      *p++ = c;
 800068e:	f88d 100c 	strb.w	r1, [sp, #12]
    s = tmpbuf;
 8000692:	ad03      	add	r5, sp, #12
      *p++ = c;
 8000694:	f10d 000d 	add.w	r0, sp, #13
 8000698:	e7dc      	b.n	8000654 <chvprintf+0x1d4>
      filler = ' ';
 800069a:	f04f 0820 	mov.w	r8, #32
 800069e:	e7d9      	b.n	8000654 <chvprintf+0x1d4>
      width = 0;
 80006a0:	2400      	movs	r4, #0
 80006a2:	e7dc      	b.n	800065e <chvprintf+0x1de>
      if (*s == '-' && filler == '0') {
 80006a4:	7829      	ldrb	r1, [r5, #0]
 80006a6:	292d      	cmp	r1, #45	; 0x2d
 80006a8:	d008      	beq.n	80006bc <chvprintf+0x23c>
        streamPut(chp, (uint8_t)filler);
 80006aa:	6833      	ldr	r3, [r6, #0]
 80006ac:	68db      	ldr	r3, [r3, #12]
 80006ae:	4641      	mov	r1, r8
 80006b0:	4630      	mov	r0, r6
 80006b2:	4798      	blx	r3
        n++;
 80006b4:	3701      	adds	r7, #1
      } while (++width != 0);
 80006b6:	3401      	adds	r4, #1
 80006b8:	d1f7      	bne.n	80006aa <chvprintf+0x22a>
 80006ba:	e7d6      	b.n	800066a <chvprintf+0x1ea>
      if (*s == '-' && filler == '0') {
 80006bc:	f1b8 0f30 	cmp.w	r8, #48	; 0x30
 80006c0:	d1f3      	bne.n	80006aa <chvprintf+0x22a>
        streamPut(chp, (uint8_t)*s++);
 80006c2:	3501      	adds	r5, #1
 80006c4:	6833      	ldr	r3, [r6, #0]
 80006c6:	68db      	ldr	r3, [r3, #12]
 80006c8:	4630      	mov	r0, r6
 80006ca:	4798      	blx	r3
        n++;
 80006cc:	3701      	adds	r7, #1
        i--;
 80006ce:	f10b 3bff 	add.w	fp, fp, #4294967295	; 0xffffffff
 80006d2:	e7ea      	b.n	80006aa <chvprintf+0x22a>
      streamPut(chp, (uint8_t)filler);
 80006d4:	6833      	ldr	r3, [r6, #0]
 80006d6:	68db      	ldr	r3, [r3, #12]
 80006d8:	4641      	mov	r1, r8
 80006da:	4630      	mov	r0, r6
 80006dc:	4798      	blx	r3
      n++;
 80006de:	3701      	adds	r7, #1
      width--;
 80006e0:	3c01      	subs	r4, #1
    while (width) {
 80006e2:	2c00      	cmp	r4, #0
 80006e4:	d1f6      	bne.n	80006d4 <chvprintf+0x254>
 80006e6:	e6d9      	b.n	800049c <chvprintf+0x1c>
 80006e8:	08003258 	.word	0x08003258
 80006ec:	00000000 	.word	0x00000000

080006f0 <ax5043ObjectInit>:
 * @param[out] devp     pointer to the @p AX5043Driver object
 *
 * @init
 */
void ax5043ObjectInit(AX5043Driver *devp) {
  devp->vmt = &vmt_device;
 80006f0:	4b02      	ldr	r3, [pc, #8]	; (80006fc <ax5043ObjectInit+0xc>)
 80006f2:	6003      	str	r3, [r0, #0]

  devp->config = NULL;
 80006f4:	2300      	movs	r3, #0
 80006f6:	6083      	str	r3, [r0, #8]

  devp->state = AX5043_UNINIT;
 80006f8:	7103      	strb	r3, [r0, #4]
}
 80006fa:	4770      	bx	lr
 80006fc:	08003580 	.word	0x08003580

08000700 <ax5043_set_conf_val>:
uint8_t ax5043_set_conf_val(AX5043Driver *devp, uint8_t conf_name, uint32_t value) {
 8000700:	b470      	push	{r4, r5, r6}
  ax5043_confval_t* entry = devp->config->conf_values;
 8000702:	6883      	ldr	r3, [r0, #8]
 8000704:	68dd      	ldr	r5, [r3, #12]
  int i = 0;
 8000706:	2300      	movs	r3, #0
  while (entry[i].conf_name != AXRADIO_PHY_END) {
 8000708:	eb05 06c3 	add.w	r6, r5, r3, lsl #3
 800070c:	f815 4033 	ldrb.w	r4, [r5, r3, lsl #3]
 8000710:	2cc8      	cmp	r4, #200	; 0xc8
 8000712:	d006      	beq.n	8000722 <ax5043_set_conf_val+0x22>
    if (entry[i].conf_name == conf_name){
 8000714:	428c      	cmp	r4, r1
 8000716:	d001      	beq.n	800071c <ax5043_set_conf_val+0x1c>
    i++;
 8000718:	3301      	adds	r3, #1
 800071a:	e7f5      	b.n	8000708 <ax5043_set_conf_val+0x8>
      entry[i].val = value;
 800071c:	6072      	str	r2, [r6, #4]
      return 0;
 800071e:	2000      	movs	r0, #0
 8000720:	e003      	b.n	800072a <ax5043_set_conf_val+0x2a>
  devp->error_code = AXRADIO_ERR_VAL_NOT_IN_CONF;
 8000722:	2311      	movs	r3, #17
 8000724:	f880 310a 	strb.w	r3, [r0, #266]	; 0x10a
  return AXRADIO_ERR_VAL_NOT_IN_CONF;
 8000728:	4618      	mov	r0, r3
}
 800072a:	bc70      	pop	{r4, r5, r6}
 800072c:	4770      	bx	lr
 800072e:	bf00      	nop

08000730 <ax5043_get_conf_val>:
uint32_t ax5043_get_conf_val(AX5043Driver *devp, uint8_t conf_name) {
 8000730:	b430      	push	{r4, r5}
  ax5043_confval_t* entry = devp->config->conf_values;
 8000732:	6883      	ldr	r3, [r0, #8]
 8000734:	68dc      	ldr	r4, [r3, #12]
  int i = 0;
 8000736:	2300      	movs	r3, #0
  while (entry[i].conf_name != AXRADIO_PHY_END) {
 8000738:	eb04 05c3 	add.w	r5, r4, r3, lsl #3
 800073c:	f814 2033 	ldrb.w	r2, [r4, r3, lsl #3]
 8000740:	2ac8      	cmp	r2, #200	; 0xc8
 8000742:	d005      	beq.n	8000750 <ax5043_get_conf_val+0x20>
    if (entry[i].conf_name == conf_name){
 8000744:	428a      	cmp	r2, r1
 8000746:	d001      	beq.n	800074c <ax5043_get_conf_val+0x1c>
    i++;
 8000748:	3301      	adds	r3, #1
 800074a:	e7f5      	b.n	8000738 <ax5043_get_conf_val+0x8>
      return entry[i].val;
 800074c:	6868      	ldr	r0, [r5, #4]
 800074e:	e003      	b.n	8000758 <ax5043_get_conf_val+0x28>
  devp->error_code = AXRADIO_ERR_VAL_NOT_IN_CONF;
 8000750:	2311      	movs	r3, #17
 8000752:	f880 310a 	strb.w	r3, [r0, #266]	; 0x10a
  return 0;
 8000756:	2000      	movs	r0, #0
}
 8000758:	bc30      	pop	{r4, r5}
 800075a:	4770      	bx	lr
 800075c:	0000      	movs	r0, r0
	...

08000760 <port_init>:
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000760:	2300      	movs	r3, #0
 8000762:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
 8000766:	b662      	cpsie	i
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8000768:	4b0c      	ldr	r3, [pc, #48]	; (800079c <port_init+0x3c>)
 800076a:	68d9      	ldr	r1, [r3, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800076c:	f421 61e0 	bic.w	r1, r1, #1792	; 0x700
 8000770:	0409      	lsls	r1, r1, #16
 8000772:	0c09      	lsrs	r1, r1, #16
  reg_value  =  (reg_value                                   |
 8000774:	4a0a      	ldr	r2, [pc, #40]	; (80007a0 <port_init+0x40>)
 8000776:	430a      	orrs	r2, r1
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
  SCB->AIRCR =  reg_value;
 8000778:	60da      	str	r2, [r3, #12]

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 800077a:	490a      	ldr	r1, [pc, #40]	; (80007a4 <port_init+0x44>)
 800077c:	68ca      	ldr	r2, [r1, #12]
 800077e:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8000782:	60ca      	str	r2, [r1, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8000784:	4908      	ldr	r1, [pc, #32]	; (80007a8 <port_init+0x48>)
 8000786:	680a      	ldr	r2, [r1, #0]
 8000788:	f042 0201 	orr.w	r2, r2, #1
 800078c:	600a      	str	r2, [r1, #0]
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800078e:	2210      	movs	r2, #16
 8000790:	77da      	strb	r2, [r3, #31]
 8000792:	2220      	movs	r2, #32
 8000794:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22

#if PORT_USE_SYSCALL == TRUE
  /* MPU is enabled.*/
  mpuEnable(MPU_CTRL_PRIVDEFENA);
#endif
}
 8000798:	4770      	bx	lr
 800079a:	bf00      	nop
 800079c:	e000ed00 	.word	0xe000ed00
 80007a0:	05fa0300 	.word	0x05fa0300
 80007a4:	e000edf0 	.word	0xe000edf0
 80007a8:	e0001000 	.word	0xe0001000
 80007ac:	00000000 	.word	0x00000000

080007b0 <chPoolObjectInitAligned>:
 *                      automatically
 *
 * @init
 */
void chPoolObjectInitAligned(memory_pool_t *mp, size_t size,
                             unsigned align, memgetfunc_t provider) {
 80007b0:	b410      	push	{r4}
  chDbgCheck((mp != NULL) &&
             (size >= sizeof(void *)) &&
             (align >= PORT_NATURAL_ALIGN) &&
             MEM_IS_VALID_ALIGNMENT(align));

  mp->next = NULL;
 80007b2:	2400      	movs	r4, #0
 80007b4:	6004      	str	r4, [r0, #0]
  mp->object_size = size;
 80007b6:	6041      	str	r1, [r0, #4]
  mp->align = align;
 80007b8:	6082      	str	r2, [r0, #8]
  mp->provider = provider;
 80007ba:	60c3      	str	r3, [r0, #12]
}
 80007bc:	bc10      	pop	{r4}
 80007be:	4770      	bx	lr

080007c0 <chCoreAllocFromTopI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocFromTopI(size_t size, unsigned align, size_t offset) {
 80007c0:	b410      	push	{r4}
  uint8_t *p, *prev;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 80007c2:	4b09      	ldr	r3, [pc, #36]	; (80007e8 <chCoreAllocFromTopI+0x28>)
 80007c4:	685c      	ldr	r4, [r3, #4]
 80007c6:	1a20      	subs	r0, r4, r0
 80007c8:	4249      	negs	r1, r1
 80007ca:	4008      	ands	r0, r1
  prev = p - offset;
 80007cc:	1a82      	subs	r2, r0, r2

  /* Considering also the case where there is numeric overflow.*/
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 80007ce:	681b      	ldr	r3, [r3, #0]
 80007d0:	4293      	cmp	r3, r2
 80007d2:	d805      	bhi.n	80007e0 <chCoreAllocFromTopI+0x20>
 80007d4:	4294      	cmp	r4, r2
 80007d6:	d305      	bcc.n	80007e4 <chCoreAllocFromTopI+0x24>
    return NULL;
  }

  ch_memcore.topmem = prev;
 80007d8:	4b03      	ldr	r3, [pc, #12]	; (80007e8 <chCoreAllocFromTopI+0x28>)
 80007da:	605a      	str	r2, [r3, #4]

  return p;
}
 80007dc:	bc10      	pop	{r4}
 80007de:	4770      	bx	lr
    return NULL;
 80007e0:	2000      	movs	r0, #0
 80007e2:	e7fb      	b.n	80007dc <chCoreAllocFromTopI+0x1c>
 80007e4:	2000      	movs	r0, #0
 80007e6:	e7f9      	b.n	80007dc <chCoreAllocFromTopI+0x1c>
 80007e8:	20001100 	.word	0x20001100
 80007ec:	00000000 	.word	0x00000000

080007f0 <chCoreAllocAlignedI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {
 80007f0:	b508      	push	{r3, lr}

  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
 80007f2:	2200      	movs	r2, #0
 80007f4:	f7ff ffe4 	bl	80007c0 <chCoreAllocFromTopI>
}
 80007f8:	bd08      	pop	{r3, pc}
 80007fa:	bf00      	nop
 80007fc:	0000      	movs	r0, r0
	...

08000800 <chCoreAllocFromTop>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocFromTop(size_t size, unsigned align, size_t offset) {
 8000800:	b508      	push	{r3, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000802:	2320      	movs	r3, #32
 8000804:	f383 8811 	msr	BASEPRI, r3
  void *p;

  chSysLock();
  p = chCoreAllocFromTopI(size, align, offset);
 8000808:	f7ff ffda 	bl	80007c0 <chCoreAllocFromTopI>
 800080c:	2300      	movs	r3, #0
 800080e:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return p;
}
 8000812:	bd08      	pop	{r3, pc}
	...

08000820 <_core_init>:
  ch_memcore.basemem = __heap_base__;
 8000820:	4b02      	ldr	r3, [pc, #8]	; (800082c <_core_init+0xc>)
 8000822:	4a03      	ldr	r2, [pc, #12]	; (8000830 <_core_init+0x10>)
 8000824:	601a      	str	r2, [r3, #0]
  ch_memcore.topmem  = __heap_end__;
 8000826:	4a03      	ldr	r2, [pc, #12]	; (8000834 <_core_init+0x14>)
 8000828:	605a      	str	r2, [r3, #4]
}
 800082a:	4770      	bx	lr
 800082c:	20001100 	.word	0x20001100
 8000830:	20001210 	.word	0x20001210
 8000834:	20020000 	.word	0x20020000
	...

08000840 <chMBObjectInit>:
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, size_t n) {

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (size_t)0));

  mbp->buffer = buf;
 8000840:	6001      	str	r1, [r0, #0]
  mbp->rdptr  = buf;
 8000842:	60c1      	str	r1, [r0, #12]
  mbp->wrptr  = buf;
 8000844:	6081      	str	r1, [r0, #8]
  mbp->top    = &buf[n];
 8000846:	eb01 0182 	add.w	r1, r1, r2, lsl #2
 800084a:	6041      	str	r1, [r0, #4]
  mbp->cnt    = (size_t)0;
 800084c:	2300      	movs	r3, #0
 800084e:	6103      	str	r3, [r0, #16]
  mbp->reset  = false;
 8000850:	7503      	strb	r3, [r0, #20]
  chThdQueueObjectInit(&mbp->qw);
 8000852:	f100 0318 	add.w	r3, r0, #24
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000856:	6183      	str	r3, [r0, #24]
  tqp->prev = (thread_t *)tqp;
 8000858:	61c3      	str	r3, [r0, #28]
  chThdQueueObjectInit(&mbp->qr);
 800085a:	f100 0320 	add.w	r3, r0, #32
  tqp->next = (thread_t *)tqp;
 800085e:	6203      	str	r3, [r0, #32]
  tqp->prev = (thread_t *)tqp;
 8000860:	6243      	str	r3, [r0, #36]	; 0x24
}
 8000862:	4770      	bx	lr
	...

08000870 <chMtxObjectInit>:
  tqp->next = (thread_t *)tqp;
 8000870:	6000      	str	r0, [r0, #0]
  tqp->prev = (thread_t *)tqp;
 8000872:	6040      	str	r0, [r0, #4]
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->queue);
  mp->owner = NULL;
 8000874:	2300      	movs	r3, #0
 8000876:	6083      	str	r3, [r0, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->cnt = (cnt_t)0;
#endif
}
 8000878:	4770      	bx	lr
 800087a:	bf00      	nop
 800087c:	0000      	movs	r0, r0
	...

08000880 <_factory_init>:
/**
 * @brief   Initializes the objects factory.
 *
 * @init
 */
void _factory_init(void) {
 8000880:	b538      	push	{r3, r4, r5, lr}

#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&ch_factory.mtx);
 8000882:	4c12      	ldr	r4, [pc, #72]	; (80008cc <_factory_init+0x4c>)
 8000884:	4620      	mov	r0, r4
 8000886:	f7ff fff3 	bl	8000870 <chMtxObjectInit>
  dlp->next = (dyn_element_t *)dlp;
 800088a:	f104 0310 	add.w	r3, r4, #16
 800088e:	6123      	str	r3, [r4, #16]
 */
static inline void chPoolObjectInit(memory_pool_t *mp,
                                    size_t size,
                                    memgetfunc_t provider) {

  chPoolObjectInitAligned(mp, size, PORT_NATURAL_ALIGN, provider);
 8000890:	4d0f      	ldr	r5, [pc, #60]	; (80008d0 <_factory_init+0x50>)
 8000892:	462b      	mov	r3, r5
 8000894:	2204      	movs	r2, #4
 8000896:	2114      	movs	r1, #20
 8000898:	1860      	adds	r0, r4, r1
 800089a:	f7ff ff89 	bl	80007b0 <chPoolObjectInitAligned>
 800089e:	f104 0324 	add.w	r3, r4, #36	; 0x24
 80008a2:	6263      	str	r3, [r4, #36]	; 0x24
 80008a4:	f104 0328 	add.w	r3, r4, #40	; 0x28
 80008a8:	62a3      	str	r3, [r4, #40]	; 0x28
 80008aa:	462b      	mov	r3, r5
 80008ac:	2204      	movs	r2, #4
 80008ae:	211c      	movs	r1, #28
 80008b0:	f104 002c 	add.w	r0, r4, #44	; 0x2c
 80008b4:	f7ff ff7c 	bl	80007b0 <chPoolObjectInitAligned>
 80008b8:	f104 033c 	add.w	r3, r4, #60	; 0x3c
 80008bc:	63e3      	str	r3, [r4, #60]	; 0x3c
 80008be:	f104 0340 	add.w	r3, r4, #64	; 0x40
 80008c2:	6423      	str	r3, [r4, #64]	; 0x40
 80008c4:	f104 0344 	add.w	r3, r4, #68	; 0x44
 80008c8:	6463      	str	r3, [r4, #68]	; 0x44
  dyn_list_init(&ch_factory.fifo_list);
#endif
#if CH_CFG_FACTORY_PIPES == TRUE
  dyn_list_init(&ch_factory.pipe_list);
#endif
}
 80008ca:	bd38      	pop	{r3, r4, r5, pc}
 80008cc:	20000fe0 	.word	0x20000fe0
 80008d0:	080007f1 	.word	0x080007f1
	...

080008e0 <_heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void _heap_init(void) {
 80008e0:	b508      	push	{r3, lr}

  default_heap.provider = chCoreAllocAlignedWithOffset;
 80008e2:	4805      	ldr	r0, [pc, #20]	; (80008f8 <_heap_init+0x18>)
 80008e4:	4b05      	ldr	r3, [pc, #20]	; (80008fc <_heap_init+0x1c>)
 80008e6:	6003      	str	r3, [r0, #0]
  H_NEXT(&default_heap.header) = NULL;
 80008e8:	2300      	movs	r3, #0
 80008ea:	6043      	str	r3, [r0, #4]
  H_PAGES(&default_heap.header) = 0;
 80008ec:	6083      	str	r3, [r0, #8]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
 80008ee:	300c      	adds	r0, #12
 80008f0:	f7ff ffbe 	bl	8000870 <chMtxObjectInit>
#else
  chSemObjectInit(&default_heap.sem, (cnt_t)1);
#endif
}
 80008f4:	bd08      	pop	{r3, pc}
 80008f6:	bf00      	nop
 80008f8:	20001108 	.word	0x20001108
 80008fc:	08000801 	.word	0x08000801

08000900 <chTMStopMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 8000900:	b430      	push	{r4, r5}
 *
 * @return              The realtime counter value.
 */
__STATIC_FORCEINLINE rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8000902:	4b0e      	ldr	r3, [pc, #56]	; (800093c <chTMStopMeasurementX+0x3c>)
 8000904:	685b      	ldr	r3, [r3, #4]

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 8000906:	4a0e      	ldr	r2, [pc, #56]	; (8000940 <chTMStopMeasurementX+0x40>)
 8000908:	6f51      	ldr	r1, [r2, #116]	; 0x74
  tmp->n++;
 800090a:	68c2      	ldr	r2, [r0, #12]
 800090c:	3201      	adds	r2, #1
 800090e:	60c2      	str	r2, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
 8000910:	6882      	ldr	r2, [r0, #8]
 8000912:	1a9b      	subs	r3, r3, r2
 8000914:	1a5b      	subs	r3, r3, r1
 8000916:	6083      	str	r3, [r0, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 8000918:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
 800091c:	18e4      	adds	r4, r4, r3
 800091e:	f145 0500 	adc.w	r5, r5, #0
 8000922:	e9c0 4504 	strd	r4, r5, [r0, #16]
  if (tmp->last > tmp->worst) {
 8000926:	6842      	ldr	r2, [r0, #4]
 8000928:	4293      	cmp	r3, r2
 800092a:	d900      	bls.n	800092e <chTMStopMeasurementX+0x2e>
    tmp->worst = tmp->last;
 800092c:	6043      	str	r3, [r0, #4]
  if (tmp->last < tmp->best) {
 800092e:	6802      	ldr	r2, [r0, #0]
 8000930:	4293      	cmp	r3, r2
 8000932:	d200      	bcs.n	8000936 <chTMStopMeasurementX+0x36>
    tmp->best = tmp->last;
 8000934:	6003      	str	r3, [r0, #0]
}
 8000936:	bc30      	pop	{r4, r5}
 8000938:	4770      	bx	lr
 800093a:	bf00      	nop
 800093c:	e0001000 	.word	0xe0001000
 8000940:	20000f68 	.word	0x20000f68
	...

08000950 <chTMStartMeasurementX>:
 8000950:	4b01      	ldr	r3, [pc, #4]	; (8000958 <chTMStartMeasurementX+0x8>)
 8000952:	685b      	ldr	r3, [r3, #4]
  tmp->last = chSysGetRealtimeCounterX();
 8000954:	6083      	str	r3, [r0, #8]
}
 8000956:	4770      	bx	lr
 8000958:	e0001000 	.word	0xe0001000
 800095c:	00000000 	.word	0x00000000

08000960 <chTMObjectInit>:
  tmp->best       = (rtcnt_t)-1;
 8000960:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8000964:	6003      	str	r3, [r0, #0]
  tmp->worst      = (rtcnt_t)0;
 8000966:	2300      	movs	r3, #0
 8000968:	6043      	str	r3, [r0, #4]
  tmp->last       = (rtcnt_t)0;
 800096a:	6083      	str	r3, [r0, #8]
  tmp->n          = (ucnt_t)0;
 800096c:	60c3      	str	r3, [r0, #12]
  tmp->cumulative = (rttime_t)0;
 800096e:	2200      	movs	r2, #0
 8000970:	2300      	movs	r3, #0
 8000972:	e9c0 2304 	strd	r2, r3, [r0, #16]
}
 8000976:	4770      	bx	lr
	...

08000980 <_tm_init>:
void _tm_init(void) {
 8000980:	b510      	push	{r4, lr}
 8000982:	b086      	sub	sp, #24
  ch.tm.offset = (rtcnt_t)0;
 8000984:	4c07      	ldr	r4, [pc, #28]	; (80009a4 <_tm_init+0x24>)
 8000986:	2300      	movs	r3, #0
 8000988:	6763      	str	r3, [r4, #116]	; 0x74
  chTMObjectInit(&tm);
 800098a:	4668      	mov	r0, sp
 800098c:	f7ff ffe8 	bl	8000960 <chTMObjectInit>
  chTMStartMeasurementX(&tm);
 8000990:	4668      	mov	r0, sp
 8000992:	f7ff ffdd 	bl	8000950 <chTMStartMeasurementX>
  chTMStopMeasurementX(&tm);
 8000996:	4668      	mov	r0, sp
 8000998:	f7ff ffb2 	bl	8000900 <chTMStopMeasurementX>
  ch.tm.offset = tm.last;
 800099c:	9b02      	ldr	r3, [sp, #8]
 800099e:	6763      	str	r3, [r4, #116]	; 0x74
}
 80009a0:	b006      	add	sp, #24
 80009a2:	bd10      	pop	{r4, pc}
 80009a4:	20000f68 	.word	0x20000f68
	...

080009b0 <_thread_init>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {
 80009b0:	b410      	push	{r4}

  tp->prio      = prio;
 80009b2:	6082      	str	r2, [r0, #8]
  tp->state     = CH_STATE_WTSTART;
 80009b4:	2402      	movs	r4, #2
 80009b6:	f880 4020 	strb.w	r4, [r0, #32]
  tp->flags     = CH_FLAG_MODE_STATIC;
 80009ba:	2400      	movs	r4, #0
 80009bc:	f880 4021 	strb.w	r4, [r0, #33]	; 0x21
#if CH_CFG_TIME_QUANTUM > 0
  tp->ticks     = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 80009c0:	63c2      	str	r2, [r0, #60]	; 0x3c
  tp->mtxlist   = NULL;
 80009c2:	6384      	str	r4, [r0, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 80009c4:	6344      	str	r4, [r0, #52]	; 0x34
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 80009c6:	2201      	movs	r2, #1
 80009c8:	f880 2022 	strb.w	r2, [r0, #34]	; 0x22
  tp->name      = name;
 80009cc:	6181      	str	r1, [r0, #24]
  REG_INSERT(tp);
 80009ce:	4a07      	ldr	r2, [pc, #28]	; (80009ec <_thread_init+0x3c>)
 80009d0:	6102      	str	r2, [r0, #16]
 80009d2:	6951      	ldr	r1, [r2, #20]
 80009d4:	6141      	str	r1, [r0, #20]
 80009d6:	6108      	str	r0, [r1, #16]
 80009d8:	6150      	str	r0, [r2, #20]
#else
  (void)name;
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
 80009da:	f100 0228 	add.w	r2, r0, #40	; 0x28
  tlp->next = (thread_t *)tlp;
 80009de:	6282      	str	r2, [r0, #40]	; 0x28
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->msgqueue);
 80009e0:	f100 022c 	add.w	r2, r0, #44	; 0x2c
  tqp->next = (thread_t *)tqp;
 80009e4:	62c2      	str	r2, [r0, #44]	; 0x2c
  tqp->prev = (thread_t *)tqp;
 80009e6:	6302      	str	r2, [r0, #48]	; 0x30
#if CH_DBG_STATISTICS == TRUE
  chTMObjectInit(&tp->stats);
#endif
  CH_CFG_THREAD_INIT_HOOK(tp);
  return tp;
}
 80009e8:	bc10      	pop	{r4}
 80009ea:	4770      	bx	lr
 80009ec:	20000f68 	.word	0x20000f68

080009f0 <chThdCreateSuspendedI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
 80009f0:	b508      	push	{r3, lr}
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)tdp->wend -
 80009f2:	6883      	ldr	r3, [r0, #8]
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 80009f4:	6842      	ldr	r2, [r0, #4]
 80009f6:	f843 2c2c 	str.w	r2, [r3, #-44]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 80009fa:	f1a3 026c 	sub.w	r2, r3, #108	; 0x6c
 80009fe:	f843 2c3c 	str.w	r2, [r3, #-60]
 8000a02:	6901      	ldr	r1, [r0, #16]
 8000a04:	f843 1c6c 	str.w	r1, [r3, #-108]
 8000a08:	6941      	ldr	r1, [r0, #20]
 8000a0a:	f843 1c68 	str.w	r1, [r3, #-104]
 8000a0e:	4905      	ldr	r1, [pc, #20]	; (8000a24 <chThdCreateSuspendedI+0x34>)
 8000a10:	f843 1c4c 	str.w	r1, [r3, #-76]

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
 8000a14:	68c2      	ldr	r2, [r0, #12]
 8000a16:	6801      	ldr	r1, [r0, #0]
 8000a18:	f1a3 0048 	sub.w	r0, r3, #72	; 0x48
 8000a1c:	f7ff ffc8 	bl	80009b0 <_thread_init>
}
 8000a20:	bd08      	pop	{r3, pc}
 8000a22:	bf00      	nop
 8000a24:	080002d1 	.word	0x080002d1
	...

08000a30 <chSchIsPreemptionRequired>:
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
 8000a30:	4b04      	ldr	r3, [pc, #16]	; (8000a44 <chSchIsPreemptionRequired+0x14>)
 8000a32:	681a      	ldr	r2, [r3, #0]
 8000a34:	6890      	ldr	r0, [r2, #8]
  tprio_t p2 = currp->prio;
 8000a36:	699b      	ldr	r3, [r3, #24]
 8000a38:	689b      	ldr	r3, [r3, #8]
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
#endif
}
 8000a3a:	4298      	cmp	r0, r3
 8000a3c:	bf94      	ite	ls
 8000a3e:	2000      	movls	r0, #0
 8000a40:	2001      	movhi	r0, #1
 8000a42:	4770      	bx	lr
 8000a44:	20000f68 	.word	0x20000f68
	...

08000a50 <_port_irq_epilogue>:
 8000a50:	2320      	movs	r3, #32
 8000a52:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8000a56:	4b0d      	ldr	r3, [pc, #52]	; (8000a8c <_port_irq_epilogue+0x3c>)
 8000a58:	685b      	ldr	r3, [r3, #4]
 8000a5a:	f413 6f00 	tst.w	r3, #2048	; 0x800
 8000a5e:	d103      	bne.n	8000a68 <_port_irq_epilogue+0x18>
 8000a60:	2300      	movs	r3, #0
 8000a62:	f383 8811 	msr	BASEPRI, r3
 8000a66:	4770      	bx	lr
void _port_irq_epilogue(void) {
 8000a68:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8000a6a:	f3ef 8409 	mrs	r4, PSP
    s_psp = __get_PSP();
#endif

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    s_psp -= sizeof (struct port_extctx);
 8000a6e:	3c20      	subs	r4, #32

    /* The port_extctx structure is pointed by the S-PSP register.*/
    ectxp = (struct port_extctx *)s_psp;

    /* Setting up a fake XPSR register value.*/
    ectxp->xpsr = 0x01000000U;
 8000a70:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8000a74:	61e3      	str	r3, [r4, #28]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8000a76:	f384 8809 	msr	PSP, r4
    /* Writing back the modified S-PSP value.*/
    __set_PSP(s_psp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8000a7a:	f7ff ffd9 	bl	8000a30 <chSchIsPreemptionRequired>
 8000a7e:	b110      	cbz	r0, 8000a86 <_port_irq_epilogue+0x36>
      /* Preemption is required we need to enforce a context switch.*/
      ectxp->pc = (uint32_t)_port_switch_from_isr;
 8000a80:	4b03      	ldr	r3, [pc, #12]	; (8000a90 <_port_irq_epilogue+0x40>)
 8000a82:	61a3      	str	r3, [r4, #24]
    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
  }
  port_unlock_from_isr();
}
 8000a84:	bd10      	pop	{r4, pc}
      ectxp->pc = (uint32_t)_port_exit_from_isr;
 8000a86:	4b03      	ldr	r3, [pc, #12]	; (8000a94 <_port_irq_epilogue+0x44>)
 8000a88:	61a3      	str	r3, [r4, #24]
    return;
 8000a8a:	e7fb      	b.n	8000a84 <_port_irq_epilogue+0x34>
 8000a8c:	e000ed00 	.word	0xe000ed00
 8000a90:	080002e3 	.word	0x080002e3
 8000a94:	080002e6 	.word	0x080002e6
	...

08000aa0 <chSchReadyAheadI>:
  tp->state = CH_STATE_READY;
 8000aa0:	2300      	movs	r3, #0
 8000aa2:	f880 3020 	strb.w	r3, [r0, #32]
  cp = (thread_t *)&ch.rlist.queue;
 8000aa6:	4b06      	ldr	r3, [pc, #24]	; (8000ac0 <chSchReadyAheadI+0x20>)
    cp = cp->queue.next;
 8000aa8:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio > tp->prio);
 8000aaa:	6899      	ldr	r1, [r3, #8]
 8000aac:	6882      	ldr	r2, [r0, #8]
 8000aae:	4291      	cmp	r1, r2
 8000ab0:	d8fa      	bhi.n	8000aa8 <chSchReadyAheadI+0x8>
  tp->queue.next             = cp;
 8000ab2:	6003      	str	r3, [r0, #0]
  tp->queue.prev             = cp->queue.prev;
 8000ab4:	685a      	ldr	r2, [r3, #4]
 8000ab6:	6042      	str	r2, [r0, #4]
  tp->queue.prev->queue.next = tp;
 8000ab8:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 8000aba:	6058      	str	r0, [r3, #4]
}
 8000abc:	4770      	bx	lr
 8000abe:	bf00      	nop
 8000ac0:	20000f68 	.word	0x20000f68
	...

08000ad0 <chSchReadyI>:
  tp->state = CH_STATE_READY;
 8000ad0:	2300      	movs	r3, #0
 8000ad2:	f880 3020 	strb.w	r3, [r0, #32]
  cp = (thread_t *)&ch.rlist.queue;
 8000ad6:	4b06      	ldr	r3, [pc, #24]	; (8000af0 <chSchReadyI+0x20>)
    cp = cp->queue.next;
 8000ad8:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8000ada:	6899      	ldr	r1, [r3, #8]
 8000adc:	6882      	ldr	r2, [r0, #8]
 8000ade:	4291      	cmp	r1, r2
 8000ae0:	d2fa      	bcs.n	8000ad8 <chSchReadyI+0x8>
  tp->queue.next             = cp;
 8000ae2:	6003      	str	r3, [r0, #0]
  tp->queue.prev             = cp->queue.prev;
 8000ae4:	685a      	ldr	r2, [r3, #4]
 8000ae6:	6042      	str	r2, [r0, #4]
  tp->queue.prev->queue.next = tp;
 8000ae8:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 8000aea:	6058      	str	r0, [r3, #4]
}
 8000aec:	4770      	bx	lr
 8000aee:	bf00      	nop
 8000af0:	20000f68 	.word	0x20000f68
	...

08000b00 <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {
 8000b00:	b508      	push	{r3, lr}

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
 8000b02:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8000b04:	4319      	orrs	r1, r3
 8000b06:	6341      	str	r1, [r0, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 8000b08:	f890 3020 	ldrb.w	r3, [r0, #32]
 8000b0c:	2b0a      	cmp	r3, #10
 8000b0e:	d002      	beq.n	8000b16 <chEvtSignalI+0x16>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 8000b10:	2b0b      	cmp	r3, #11
 8000b12:	d008      	beq.n	8000b26 <chEvtSignalI+0x26>
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
    (void) chSchReadyI(tp);
  }
}
 8000b14:	bd08      	pop	{r3, pc}
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 8000b16:	6a42      	ldr	r2, [r0, #36]	; 0x24
  if (((tp->state == CH_STATE_WTOREVT) &&
 8000b18:	4211      	tst	r1, r2
 8000b1a:	d0f9      	beq.n	8000b10 <chEvtSignalI+0x10>
    tp->u.rdymsg = MSG_OK;
 8000b1c:	2300      	movs	r3, #0
 8000b1e:	6243      	str	r3, [r0, #36]	; 0x24
    (void) chSchReadyI(tp);
 8000b20:	f7ff ffd6 	bl	8000ad0 <chSchReadyI>
 8000b24:	e7f6      	b.n	8000b14 <chEvtSignalI+0x14>
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
 8000b26:	6a43      	ldr	r3, [r0, #36]	; 0x24
      ((tp->state == CH_STATE_WTANDEVT) &&
 8000b28:	438b      	bics	r3, r1
 8000b2a:	d1f3      	bne.n	8000b14 <chEvtSignalI+0x14>
 8000b2c:	e7f6      	b.n	8000b1c <chEvtSignalI+0x1c>
 8000b2e:	bf00      	nop

08000b30 <chEvtBroadcastFlagsI>:
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8000b30:	b570      	push	{r4, r5, r6, lr}
 8000b32:	4606      	mov	r6, r0
 8000b34:	460d      	mov	r5, r1
  elp = esp->next;
 8000b36:	6804      	ldr	r4, [r0, #0]
  while (elp != (event_listener_t *)esp) {
 8000b38:	e004      	b.n	8000b44 <chEvtBroadcastFlagsI+0x14>
      chEvtSignalI(elp->listener, elp->events);
 8000b3a:	68a1      	ldr	r1, [r4, #8]
 8000b3c:	6860      	ldr	r0, [r4, #4]
 8000b3e:	f7ff ffdf 	bl	8000b00 <chEvtSignalI>
    elp = elp->next;
 8000b42:	6824      	ldr	r4, [r4, #0]
  while (elp != (event_listener_t *)esp) {
 8000b44:	42b4      	cmp	r4, r6
 8000b46:	d008      	beq.n	8000b5a <chEvtBroadcastFlagsI+0x2a>
    elp->flags |= flags;
 8000b48:	68e3      	ldr	r3, [r4, #12]
 8000b4a:	432b      	orrs	r3, r5
 8000b4c:	60e3      	str	r3, [r4, #12]
    if ((flags == (eventflags_t)0) ||
 8000b4e:	2d00      	cmp	r5, #0
 8000b50:	d0f3      	beq.n	8000b3a <chEvtBroadcastFlagsI+0xa>
        ((flags & elp->wflags) != (eventflags_t)0)) {
 8000b52:	6923      	ldr	r3, [r4, #16]
    if ((flags == (eventflags_t)0) ||
 8000b54:	422b      	tst	r3, r5
 8000b56:	d0f4      	beq.n	8000b42 <chEvtBroadcastFlagsI+0x12>
 8000b58:	e7ef      	b.n	8000b3a <chEvtBroadcastFlagsI+0xa>
}
 8000b5a:	bd70      	pop	{r4, r5, r6, pc}
 8000b5c:	0000      	movs	r0, r0
	...

08000b60 <chThdDequeueAllI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 8000b60:	b538      	push	{r3, r4, r5, lr}
 8000b62:	4604      	mov	r4, r0
 8000b64:	460d      	mov	r5, r1
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 8000b66:	6820      	ldr	r0, [r4, #0]

  while (queue_notempty(tqp)) {
 8000b68:	4284      	cmp	r4, r0
 8000b6a:	d006      	beq.n	8000b7a <chThdDequeueAllI+0x1a>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8000b6c:	6803      	ldr	r3, [r0, #0]
 8000b6e:	6023      	str	r3, [r4, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8000b70:	605c      	str	r4, [r3, #4]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
 8000b72:	6245      	str	r5, [r0, #36]	; 0x24
  (void) chSchReadyI(tp);
 8000b74:	f7ff ffac 	bl	8000ad0 <chSchReadyI>
 8000b78:	e7f5      	b.n	8000b66 <chThdDequeueAllI+0x6>
    chThdDoDequeueNextI(tqp, msg);
  }
}
 8000b7a:	bd38      	pop	{r3, r4, r5, pc}
 8000b7c:	0000      	movs	r0, r0
	...

08000b80 <chThdDequeueNextI>:
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8000b80:	b508      	push	{r3, lr}
 8000b82:	4603      	mov	r3, r0
  return (bool)(tqp->next != (const thread_t *)tqp);
 8000b84:	6800      	ldr	r0, [r0, #0]
  if (queue_notempty(tqp)) {
 8000b86:	4283      	cmp	r3, r0
 8000b88:	d005      	beq.n	8000b96 <chThdDequeueNextI+0x16>
  tqp->next             = tp->queue.next;
 8000b8a:	6802      	ldr	r2, [r0, #0]
 8000b8c:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8000b8e:	6053      	str	r3, [r2, #4]
  tp->u.rdymsg = msg;
 8000b90:	6241      	str	r1, [r0, #36]	; 0x24
  (void) chSchReadyI(tp);
 8000b92:	f7ff ff9d 	bl	8000ad0 <chSchReadyI>
}
 8000b96:	bd08      	pop	{r3, pc}
	...

08000ba0 <chThdResumeI>:
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
 8000ba0:	b508      	push	{r3, lr}
 8000ba2:	4603      	mov	r3, r0
  if (*trp != NULL) {
 8000ba4:	6800      	ldr	r0, [r0, #0]
 8000ba6:	b120      	cbz	r0, 8000bb2 <chThdResumeI+0x12>
    *trp = NULL;
 8000ba8:	2200      	movs	r2, #0
 8000baa:	601a      	str	r2, [r3, #0]
    tp->u.rdymsg = msg;
 8000bac:	6241      	str	r1, [r0, #36]	; 0x24
    (void) chSchReadyI(tp);
 8000bae:	f7ff ff8f 	bl	8000ad0 <chSchReadyI>
}
 8000bb2:	bd08      	pop	{r3, pc}
	...

08000bc0 <wakeup>:
static void wakeup(void *p) {
 8000bc0:	b508      	push	{r3, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000bc2:	2320      	movs	r3, #32
 8000bc4:	f383 8811 	msr	BASEPRI, r3
  switch (tp->state) {
 8000bc8:	f890 3020 	ldrb.w	r3, [r0, #32]
 8000bcc:	2b07      	cmp	r3, #7
 8000bce:	d816      	bhi.n	8000bfe <wakeup+0x3e>
 8000bd0:	e8df f003 	tbb	[pc, r3]
 8000bd4:	08151504 	.word	0x08151504
 8000bd8:	10150c10 	.word	0x10150c10
 8000bdc:	2300      	movs	r3, #0
 8000bde:	f383 8811 	msr	BASEPRI, r3
 8000be2:	e014      	b.n	8000c0e <wakeup+0x4e>
    *tp->u.wttrp = NULL;
 8000be4:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8000be6:	2200      	movs	r2, #0
 8000be8:	601a      	str	r2, [r3, #0]
    break;
 8000bea:	e008      	b.n	8000bfe <wakeup+0x3e>
    chSemFastSignalI(tp->u.wtsemp);
 8000bec:	6a42      	ldr	r2, [r0, #36]	; 0x24
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->cnt++;
 8000bee:	6893      	ldr	r3, [r2, #8]
 8000bf0:	3301      	adds	r3, #1
 8000bf2:	6093      	str	r3, [r2, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 8000bf4:	6842      	ldr	r2, [r0, #4]
 8000bf6:	6803      	ldr	r3, [r0, #0]
 8000bf8:	6013      	str	r3, [r2, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8000bfa:	6842      	ldr	r2, [r0, #4]
 8000bfc:	605a      	str	r2, [r3, #4]
  tp->u.rdymsg = MSG_TIMEOUT;
 8000bfe:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8000c02:	6243      	str	r3, [r0, #36]	; 0x24
  (void) chSchReadyI(tp);
 8000c04:	f7ff ff64 	bl	8000ad0 <chSchReadyI>
 8000c08:	2300      	movs	r3, #0
 8000c0a:	f383 8811 	msr	BASEPRI, r3
}
 8000c0e:	bd08      	pop	{r3, pc}

08000c10 <_scheduler_init>:
  tqp->next = (thread_t *)tqp;
 8000c10:	4b03      	ldr	r3, [pc, #12]	; (8000c20 <_scheduler_init+0x10>)
 8000c12:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8000c14:	605b      	str	r3, [r3, #4]
  ch.rlist.prio = NOPRIO;
 8000c16:	2200      	movs	r2, #0
 8000c18:	609a      	str	r2, [r3, #8]
  ch.rlist.newer = (thread_t *)&ch.rlist;
 8000c1a:	611b      	str	r3, [r3, #16]
  ch.rlist.older = (thread_t *)&ch.rlist;
 8000c1c:	615b      	str	r3, [r3, #20]
}
 8000c1e:	4770      	bx	lr
 8000c20:	20000f68 	.word	0x20000f68
	...

08000c30 <_vt_init>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 8000c30:	4b05      	ldr	r3, [pc, #20]	; (8000c48 <_vt_init+0x18>)
 8000c32:	f103 021c 	add.w	r2, r3, #28
 8000c36:	61da      	str	r2, [r3, #28]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
 8000c38:	621a      	str	r2, [r3, #32]
  ch.vtlist.delta = (sysinterval_t)-1;
 8000c3a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8000c3e:	625a      	str	r2, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.lasttime = (systime_t)0;
 8000c40:	2200      	movs	r2, #0
 8000c42:	629a      	str	r2, [r3, #40]	; 0x28
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8000c44:	4770      	bx	lr
 8000c46:	bf00      	nop
 8000c48:	20000f68 	.word	0x20000f68
 8000c4c:	00000000 	.word	0x00000000

08000c50 <chSysHalt>:
  __ASM volatile ("cpsid i" : : : "memory");
 8000c50:	b672      	cpsid	i

  /* Logging the event.*/
  _trace_halt(reason);

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 8000c52:	4a01      	ldr	r2, [pc, #4]	; (8000c58 <chSysHalt+0x8>)
 8000c54:	62d0      	str	r0, [r2, #44]	; 0x2c

  /* Halt hook code, usually empty.*/
  CH_CFG_SYSTEM_HALT_HOOK(reason);

  /* Harmless infinite loop.*/
  while (true) {
 8000c56:	e7fe      	b.n	8000c56 <chSysHalt+0x6>
 8000c58:	20000f68 	.word	0x20000f68
 8000c5c:	00000000 	.word	0x00000000

08000c60 <_idle_thread>:
}
 8000c60:	e7fe      	b.n	8000c60 <_idle_thread>
 8000c62:	bf00      	nop
	...

08000c70 <gpio_init>:
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000c70:	684b      	ldr	r3, [r1, #4]
 8000c72:	6043      	str	r3, [r0, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8000c74:	688b      	ldr	r3, [r1, #8]
 8000c76:	6083      	str	r3, [r0, #8]
  gpiop->PUPDR   = config->pupdr;
 8000c78:	68cb      	ldr	r3, [r1, #12]
 8000c7a:	60c3      	str	r3, [r0, #12]
  gpiop->ODR     = config->odr;
 8000c7c:	690b      	ldr	r3, [r1, #16]
 8000c7e:	6143      	str	r3, [r0, #20]
  gpiop->AFRL    = config->afrl;
 8000c80:	694b      	ldr	r3, [r1, #20]
 8000c82:	6203      	str	r3, [r0, #32]
  gpiop->AFRH    = config->afrh;
 8000c84:	698b      	ldr	r3, [r1, #24]
 8000c86:	6243      	str	r3, [r0, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000c88:	680b      	ldr	r3, [r1, #0]
 8000c8a:	6003      	str	r3, [r0, #0]
}
 8000c8c:	4770      	bx	lr
 8000c8e:	bf00      	nop

08000c90 <stm32_gpio_init>:

static void stm32_gpio_init(void) {
 8000c90:	b510      	push	{r4, lr}

  /* Enabling GPIO-related clocks, the mask comes from the
     registry header file.*/
  rccResetAHB1(STM32_GPIO_EN_MASK);
 8000c92:	4b1e      	ldr	r3, [pc, #120]	; (8000d0c <stm32_gpio_init+0x7c>)
 8000c94:	691a      	ldr	r2, [r3, #16]
 8000c96:	f042 02ff 	orr.w	r2, r2, #255	; 0xff
 8000c9a:	611a      	str	r2, [r3, #16]
 8000c9c:	691a      	ldr	r2, [r3, #16]
 8000c9e:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
 8000ca2:	611a      	str	r2, [r3, #16]
 8000ca4:	691a      	ldr	r2, [r3, #16]
  rccEnableAHB1(STM32_GPIO_EN_MASK, true);
 8000ca6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000ca8:	f042 02ff 	orr.w	r2, r2, #255	; 0xff
 8000cac:	631a      	str	r2, [r3, #48]	; 0x30
 8000cae:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8000cb0:	f042 02ff 	orr.w	r2, r2, #255	; 0xff
 8000cb4:	651a      	str	r2, [r3, #80]	; 0x50
 8000cb6:	6d1b      	ldr	r3, [r3, #80]	; 0x50

  /* Initializing all the defined GPIO ports.*/
#if STM32_HAS_GPIOA
  gpio_init(GPIOA, &gpio_default_config.PAData);
 8000cb8:	4c15      	ldr	r4, [pc, #84]	; (8000d10 <stm32_gpio_init+0x80>)
 8000cba:	4621      	mov	r1, r4
 8000cbc:	4815      	ldr	r0, [pc, #84]	; (8000d14 <stm32_gpio_init+0x84>)
 8000cbe:	f7ff ffd7 	bl	8000c70 <gpio_init>
#endif
#if STM32_HAS_GPIOB
  gpio_init(GPIOB, &gpio_default_config.PBData);
 8000cc2:	f104 011c 	add.w	r1, r4, #28
 8000cc6:	4814      	ldr	r0, [pc, #80]	; (8000d18 <stm32_gpio_init+0x88>)
 8000cc8:	f7ff ffd2 	bl	8000c70 <gpio_init>
#endif
#if STM32_HAS_GPIOC
  gpio_init(GPIOC, &gpio_default_config.PCData);
 8000ccc:	f104 0138 	add.w	r1, r4, #56	; 0x38
 8000cd0:	4812      	ldr	r0, [pc, #72]	; (8000d1c <stm32_gpio_init+0x8c>)
 8000cd2:	f7ff ffcd 	bl	8000c70 <gpio_init>
#endif
#if STM32_HAS_GPIOD
  gpio_init(GPIOD, &gpio_default_config.PDData);
 8000cd6:	f104 0154 	add.w	r1, r4, #84	; 0x54
 8000cda:	4811      	ldr	r0, [pc, #68]	; (8000d20 <stm32_gpio_init+0x90>)
 8000cdc:	f7ff ffc8 	bl	8000c70 <gpio_init>
#endif
#if STM32_HAS_GPIOE
  gpio_init(GPIOE, &gpio_default_config.PEData);
 8000ce0:	f104 0170 	add.w	r1, r4, #112	; 0x70
 8000ce4:	480f      	ldr	r0, [pc, #60]	; (8000d24 <stm32_gpio_init+0x94>)
 8000ce6:	f7ff ffc3 	bl	8000c70 <gpio_init>
#endif
#if STM32_HAS_GPIOF
  gpio_init(GPIOF, &gpio_default_config.PFData);
 8000cea:	f104 018c 	add.w	r1, r4, #140	; 0x8c
 8000cee:	480e      	ldr	r0, [pc, #56]	; (8000d28 <stm32_gpio_init+0x98>)
 8000cf0:	f7ff ffbe 	bl	8000c70 <gpio_init>
#endif
#if STM32_HAS_GPIOG
  gpio_init(GPIOG, &gpio_default_config.PGData);
 8000cf4:	f104 01a8 	add.w	r1, r4, #168	; 0xa8
 8000cf8:	480c      	ldr	r0, [pc, #48]	; (8000d2c <stm32_gpio_init+0x9c>)
 8000cfa:	f7ff ffb9 	bl	8000c70 <gpio_init>
#endif
#if STM32_HAS_GPIOH
  gpio_init(GPIOH, &gpio_default_config.PHData);
 8000cfe:	f104 01c4 	add.w	r1, r4, #196	; 0xc4
 8000d02:	480b      	ldr	r0, [pc, #44]	; (8000d30 <stm32_gpio_init+0xa0>)
 8000d04:	f7ff ffb4 	bl	8000c70 <gpio_init>
  gpio_init(GPIOJ, &gpio_default_config.PJData);
#endif
#if STM32_HAS_GPIOK
  gpio_init(GPIOK, &gpio_default_config.PKData);
#endif
}
 8000d08:	bd10      	pop	{r4, pc}
 8000d0a:	bf00      	nop
 8000d0c:	40023800 	.word	0x40023800
 8000d10:	080033b8 	.word	0x080033b8
 8000d14:	40020000 	.word	0x40020000
 8000d18:	40020400 	.word	0x40020400
 8000d1c:	40020800 	.word	0x40020800
 8000d20:	40020c00 	.word	0x40020c00
 8000d24:	40021000 	.word	0x40021000
 8000d28:	40021400 	.word	0x40021400
 8000d2c:	40021800 	.word	0x40021800
 8000d30:	40021c00 	.word	0x40021c00
	...

08000d40 <notify2>:

#if STM32_SERIAL_USE_USART2 || defined(__DOXYGEN__)
static void notify2(io_queue_t *qp) {

  (void)qp;
  USART2->CR1 |= USART_CR1_TXEIE | USART_CR1_TCIE;
 8000d40:	4a02      	ldr	r2, [pc, #8]	; (8000d4c <notify2+0xc>)
 8000d42:	68d3      	ldr	r3, [r2, #12]
 8000d44:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 8000d48:	60d3      	str	r3, [r2, #12]
}
 8000d4a:	4770      	bx	lr
 8000d4c:	40004400 	.word	0x40004400

08000d50 <set_error>:
static void set_error(SerialDriver *sdp, uint16_t sr) {
 8000d50:	b508      	push	{r3, lr}
 8000d52:	460b      	mov	r3, r1
  if (sr & USART_SR_ORE)
 8000d54:	f011 0f08 	tst.w	r1, #8
 8000d58:	d113      	bne.n	8000d82 <set_error+0x32>
  eventflags_t sts = 0;
 8000d5a:	2100      	movs	r1, #0
  if (sr & USART_SR_PE)
 8000d5c:	f013 0f01 	tst.w	r3, #1
 8000d60:	d001      	beq.n	8000d66 <set_error+0x16>
    sts |= SD_PARITY_ERROR;
 8000d62:	f041 0120 	orr.w	r1, r1, #32
  if (sr & USART_SR_FE)
 8000d66:	f013 0f02 	tst.w	r3, #2
 8000d6a:	d001      	beq.n	8000d70 <set_error+0x20>
    sts |= SD_FRAMING_ERROR;
 8000d6c:	f041 0140 	orr.w	r1, r1, #64	; 0x40
  if (sr & USART_SR_NE)
 8000d70:	f013 0f04 	tst.w	r3, #4
 8000d74:	d001      	beq.n	8000d7a <set_error+0x2a>
    sts |= SD_NOISE_ERROR;
 8000d76:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 8000d7a:	3004      	adds	r0, #4
 8000d7c:	f7ff fed8 	bl	8000b30 <chEvtBroadcastFlagsI>
}
 8000d80:	bd08      	pop	{r3, pc}
    sts |= SD_OVERRUN_ERROR;
 8000d82:	2180      	movs	r1, #128	; 0x80
 8000d84:	e7ea      	b.n	8000d5c <set_error+0xc>
 8000d86:	bf00      	nop
	...

08000d90 <usart_init>:
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
 8000d90:	b410      	push	{r4}
  USART_TypeDef *u = sdp->usart;
 8000d92:	6f43      	ldr	r3, [r0, #116]	; 0x74
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
 8000d94:	4a1e      	ldr	r2, [pc, #120]	; (8000e10 <usart_init+0x80>)
 8000d96:	4293      	cmp	r3, r2
 8000d98:	d008      	beq.n	8000dac <usart_init+0x1c>
 8000d9a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8000d9e:	4293      	cmp	r3, r2
 8000da0:	d004      	beq.n	8000dac <usart_init+0x1c>
    fck = STM32_PCLK1 / config->speed;
 8000da2:	680c      	ldr	r4, [r1, #0]
 8000da4:	4a1b      	ldr	r2, [pc, #108]	; (8000e14 <usart_init+0x84>)
 8000da6:	fbb2 f2f4 	udiv	r2, r2, r4
 8000daa:	e003      	b.n	8000db4 <usart_init+0x24>
    fck = STM32_PCLK2 / config->speed;
 8000dac:	680c      	ldr	r4, [r1, #0]
 8000dae:	4a1a      	ldr	r2, [pc, #104]	; (8000e18 <usart_init+0x88>)
 8000db0:	fbb2 f2f4 	udiv	r2, r2, r4
  if (config->cr1 & USART_CR1_OVER8)
 8000db4:	f9b1 4004 	ldrsh.w	r4, [r1, #4]
 8000db8:	2c00      	cmp	r4, #0
 8000dba:	db1d      	blt.n	8000df8 <usart_init+0x68>
  u->BRR = fck;
 8000dbc:	609a      	str	r2, [r3, #8]
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8000dbe:	88ca      	ldrh	r2, [r1, #6]
 8000dc0:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8000dc4:	611a      	str	r2, [r3, #16]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8000dc6:	890a      	ldrh	r2, [r1, #8]
 8000dc8:	f042 0201 	orr.w	r2, r2, #1
 8000dcc:	615a      	str	r2, [r3, #20]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8000dce:	888a      	ldrh	r2, [r1, #4]
                         USART_CR1_RXNEIE | USART_CR1_TE |
 8000dd0:	f442 5204 	orr.w	r2, r2, #8448	; 0x2100
 8000dd4:	f042 022c 	orr.w	r2, r2, #44	; 0x2c
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8000dd8:	60da      	str	r2, [r3, #12]
  u->SR = 0;
 8000dda:	2200      	movs	r2, #0
 8000ddc:	601a      	str	r2, [r3, #0]
  (void)u->SR;  /* SR reset step 1.*/
 8000dde:	681a      	ldr	r2, [r3, #0]
  (void)u->DR;  /* SR reset step 2.*/
 8000de0:	685b      	ldr	r3, [r3, #4]
  if ((config->cr1 & (USART_CR1_M | USART_CR1_PCE)) == USART_CR1_PCE) {
 8000de2:	888b      	ldrh	r3, [r1, #4]
 8000de4:	f403 53a0 	and.w	r3, r3, #5120	; 0x1400
 8000de8:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8000dec:	d00b      	beq.n	8000e06 <usart_init+0x76>
    sdp->rxmask = 0xFF;
 8000dee:	23ff      	movs	r3, #255	; 0xff
 8000df0:	f880 3078 	strb.w	r3, [r0, #120]	; 0x78
}
 8000df4:	bc10      	pop	{r4}
 8000df6:	4770      	bx	lr
    fck = ((fck & ~7) * 2) | (fck & 7);
 8000df8:	f022 0407 	bic.w	r4, r2, #7
 8000dfc:	f002 0207 	and.w	r2, r2, #7
 8000e00:	ea42 0244 	orr.w	r2, r2, r4, lsl #1
 8000e04:	e7da      	b.n	8000dbc <usart_init+0x2c>
    sdp->rxmask = 0x7F;
 8000e06:	237f      	movs	r3, #127	; 0x7f
 8000e08:	f880 3078 	strb.w	r3, [r0, #120]	; 0x78
 8000e0c:	e7f2      	b.n	8000df4 <usart_init+0x64>
 8000e0e:	bf00      	nop
 8000e10:	40011000 	.word	0x40011000
 8000e14:	02aea540 	.word	0x02aea540
 8000e18:	055d4a80 	.word	0x055d4a80
 8000e1c:	00000000 	.word	0x00000000

08000e20 <spi_lld_exchange>:
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @notapi
 */
void spi_lld_exchange(SPIDriver *spip, size_t n,
                      const void *txbuf, void *rxbuf) {
 8000e20:	b410      	push	{r4}

  osalDbgAssert(n < 65536, "unsupported DMA transfer size");

  dmaStreamSetMemory0(spip->dmarx, rxbuf);
 8000e22:	6a04      	ldr	r4, [r0, #32]
 8000e24:	6824      	ldr	r4, [r4, #0]
 8000e26:	60e3      	str	r3, [r4, #12]
  dmaStreamSetTransactionSize(spip->dmarx, n);
 8000e28:	6a03      	ldr	r3, [r0, #32]
 8000e2a:	681b      	ldr	r3, [r3, #0]
 8000e2c:	6059      	str	r1, [r3, #4]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode| STM32_DMA_CR_MINC);
 8000e2e:	6a03      	ldr	r3, [r0, #32]
 8000e30:	681c      	ldr	r4, [r3, #0]
 8000e32:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8000e34:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8000e38:	6023      	str	r3, [r4, #0]

  dmaStreamSetMemory0(spip->dmatx, txbuf);
 8000e3a:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8000e3c:	681b      	ldr	r3, [r3, #0]
 8000e3e:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmatx, n);
 8000e40:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8000e42:	681b      	ldr	r3, [r3, #0]
 8000e44:	6059      	str	r1, [r3, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 8000e46:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8000e48:	681a      	ldr	r2, [r3, #0]
 8000e4a:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8000e4c:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8000e50:	6013      	str	r3, [r2, #0]

  dmaStreamEnable(spip->dmarx);
 8000e52:	6a03      	ldr	r3, [r0, #32]
 8000e54:	681a      	ldr	r2, [r3, #0]
 8000e56:	6813      	ldr	r3, [r2, #0]
 8000e58:	f043 0301 	orr.w	r3, r3, #1
 8000e5c:	6013      	str	r3, [r2, #0]
  dmaStreamEnable(spip->dmatx);
 8000e5e:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8000e60:	681a      	ldr	r2, [r3, #0]
 8000e62:	6813      	ldr	r3, [r2, #0]
 8000e64:	f043 0301 	orr.w	r3, r3, #1
 8000e68:	6013      	str	r3, [r2, #0]
}
 8000e6a:	bc10      	pop	{r4}
 8000e6c:	4770      	bx	lr
 8000e6e:	bf00      	nop

08000e70 <spi_lld_serve_rx_interrupt>:
static void spi_lld_serve_rx_interrupt(SPIDriver *spip, uint32_t flags) {
 8000e70:	b538      	push	{r3, r4, r5, lr}
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8000e72:	f011 0f0c 	tst.w	r1, #12
 8000e76:	d11c      	bne.n	8000eb2 <spi_lld_serve_rx_interrupt+0x42>
 8000e78:	4604      	mov	r4, r0
 8000e7a:	460d      	mov	r5, r1
  if (spip->config->circular) {
 8000e7c:	6843      	ldr	r3, [r0, #4]
 8000e7e:	781a      	ldrb	r2, [r3, #0]
 8000e80:	b1d2      	cbz	r2, 8000eb8 <spi_lld_serve_rx_interrupt+0x48>
    if ((flags & STM32_DMA_ISR_HTIF) != 0U) {
 8000e82:	f011 0f10 	tst.w	r1, #16
 8000e86:	d002      	beq.n	8000e8e <spi_lld_serve_rx_interrupt+0x1e>
      _spi_isr_half_code(spip);
 8000e88:	685b      	ldr	r3, [r3, #4]
 8000e8a:	b103      	cbz	r3, 8000e8e <spi_lld_serve_rx_interrupt+0x1e>
 8000e8c:	4798      	blx	r3
    if ((flags & STM32_DMA_ISR_TCIF) != 0U) {
 8000e8e:	f015 0f20 	tst.w	r5, #32
 8000e92:	d049      	beq.n	8000f28 <spi_lld_serve_rx_interrupt+0xb8>
      _spi_isr_full_code(spip);
 8000e94:	6863      	ldr	r3, [r4, #4]
 8000e96:	685a      	ldr	r2, [r3, #4]
 8000e98:	2a00      	cmp	r2, #0
 8000e9a:	d045      	beq.n	8000f28 <spi_lld_serve_rx_interrupt+0xb8>
 8000e9c:	2204      	movs	r2, #4
 8000e9e:	7022      	strb	r2, [r4, #0]
 8000ea0:	685b      	ldr	r3, [r3, #4]
 8000ea2:	4620      	mov	r0, r4
 8000ea4:	4798      	blx	r3
 8000ea6:	7823      	ldrb	r3, [r4, #0]
 8000ea8:	2b04      	cmp	r3, #4
 8000eaa:	d13d      	bne.n	8000f28 <spi_lld_serve_rx_interrupt+0xb8>
 8000eac:	2303      	movs	r3, #3
 8000eae:	7023      	strb	r3, [r4, #0]
 8000eb0:	e03a      	b.n	8000f28 <spi_lld_serve_rx_interrupt+0xb8>
  chSysHalt(reason);
 8000eb2:	4821      	ldr	r0, [pc, #132]	; (8000f38 <spi_lld_serve_rx_interrupt+0xc8>)
 8000eb4:	f7ff fecc 	bl	8000c50 <chSysHalt>
    dmaStreamDisable(spip->dmatx);
 8000eb8:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8000eba:	681a      	ldr	r2, [r3, #0]
 8000ebc:	6813      	ldr	r3, [r2, #0]
 8000ebe:	f023 031f 	bic.w	r3, r3, #31
 8000ec2:	6013      	str	r3, [r2, #0]
 8000ec4:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8000ec6:	681a      	ldr	r2, [r3, #0]
 8000ec8:	6812      	ldr	r2, [r2, #0]
 8000eca:	f012 0f01 	tst.w	r2, #1
 8000ece:	d1f9      	bne.n	8000ec4 <spi_lld_serve_rx_interrupt+0x54>
 8000ed0:	685a      	ldr	r2, [r3, #4]
 8000ed2:	7a59      	ldrb	r1, [r3, #9]
 8000ed4:	233d      	movs	r3, #61	; 0x3d
 8000ed6:	408b      	lsls	r3, r1
 8000ed8:	6013      	str	r3, [r2, #0]
    dmaStreamDisable(spip->dmarx);
 8000eda:	6a23      	ldr	r3, [r4, #32]
 8000edc:	681a      	ldr	r2, [r3, #0]
 8000ede:	6813      	ldr	r3, [r2, #0]
 8000ee0:	f023 031f 	bic.w	r3, r3, #31
 8000ee4:	6013      	str	r3, [r2, #0]
 8000ee6:	6a23      	ldr	r3, [r4, #32]
 8000ee8:	681a      	ldr	r2, [r3, #0]
 8000eea:	6812      	ldr	r2, [r2, #0]
 8000eec:	f012 0f01 	tst.w	r2, #1
 8000ef0:	d1f9      	bne.n	8000ee6 <spi_lld_serve_rx_interrupt+0x76>
 8000ef2:	685a      	ldr	r2, [r3, #4]
 8000ef4:	7a59      	ldrb	r1, [r3, #9]
 8000ef6:	233d      	movs	r3, #61	; 0x3d
 8000ef8:	408b      	lsls	r3, r1
 8000efa:	6013      	str	r3, [r2, #0]
    _spi_isr_code(spip);
 8000efc:	6863      	ldr	r3, [r4, #4]
 8000efe:	685a      	ldr	r2, [r3, #4]
 8000f00:	b1b2      	cbz	r2, 8000f30 <spi_lld_serve_rx_interrupt+0xc0>
 8000f02:	2204      	movs	r2, #4
 8000f04:	7022      	strb	r2, [r4, #0]
 8000f06:	685b      	ldr	r3, [r3, #4]
 8000f08:	4620      	mov	r0, r4
 8000f0a:	4798      	blx	r3
 8000f0c:	7823      	ldrb	r3, [r4, #0]
 8000f0e:	2b04      	cmp	r3, #4
 8000f10:	d00b      	beq.n	8000f2a <spi_lld_serve_rx_interrupt+0xba>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000f12:	2320      	movs	r3, #32
 8000f14:	f383 8811 	msr	BASEPRI, r3
  chThdResumeI(trp, msg);
 8000f18:	2100      	movs	r1, #0
 8000f1a:	f104 0008 	add.w	r0, r4, #8
 8000f1e:	f7ff fe3f 	bl	8000ba0 <chThdResumeI>
 8000f22:	2300      	movs	r3, #0
 8000f24:	f383 8811 	msr	BASEPRI, r3
}
 8000f28:	bd38      	pop	{r3, r4, r5, pc}
    _spi_isr_code(spip);
 8000f2a:	2302      	movs	r3, #2
 8000f2c:	7023      	strb	r3, [r4, #0]
 8000f2e:	e7f0      	b.n	8000f12 <spi_lld_serve_rx_interrupt+0xa2>
 8000f30:	2302      	movs	r3, #2
 8000f32:	7023      	strb	r3, [r4, #0]
 8000f34:	e7ed      	b.n	8000f12 <spi_lld_serve_rx_interrupt+0xa2>
 8000f36:	bf00      	nop
 8000f38:	08003260 	.word	0x08003260
 8000f3c:	00000000 	.word	0x00000000

08000f40 <spi_lld_serve_tx_interrupt>:
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8000f40:	f011 0f0c 	tst.w	r1, #12
 8000f44:	d100      	bne.n	8000f48 <spi_lld_serve_tx_interrupt+0x8>
 8000f46:	4770      	bx	lr
static void spi_lld_serve_tx_interrupt(SPIDriver *spip, uint32_t flags) {
 8000f48:	b508      	push	{r3, lr}
  chSysHalt(reason);
 8000f4a:	4801      	ldr	r0, [pc, #4]	; (8000f50 <spi_lld_serve_tx_interrupt+0x10>)
 8000f4c:	f7ff fe80 	bl	8000c50 <chSysHalt>
 8000f50:	08003260 	.word	0x08003260
	...

08000f60 <_pal_lld_enablepadevent>:
 *
 * @notapi
 */
void _pal_lld_enablepadevent(ioportid_t port,
                             iopadid_t pad,
                             ioeventmode_t mode) {
 8000f60:	b4f0      	push	{r4, r5, r6, r7}

  uint32_t padmask, cridx, croff, crmask, portidx;

  /* Mask of the pad.*/
  padmask = 1U << (uint32_t)pad;
 8000f62:	2301      	movs	r3, #1
 8000f64:	408b      	lsls	r3, r1
     multiple ports.*/
  osalDbgAssert(((EXTI->RTSR1 & padmask) == 0U) &&
                ((EXTI->FTSR1 & padmask) == 0U), "channel already in use");

  /* Index and mask of the SYSCFG CR register to be used.*/
  cridx  = (uint32_t)pad >> 2U;
 8000f66:	088d      	lsrs	r5, r1, #2
  croff = ((uint32_t)pad & 3U) * 4U;
 8000f68:	f001 0103 	and.w	r1, r1, #3
 8000f6c:	0089      	lsls	r1, r1, #2
  crmask = ~(0xFU << croff);
 8000f6e:	240f      	movs	r4, #15
 8000f70:	fa04 f601 	lsl.w	r6, r4, r1

  /* Port index is obtained assuming that GPIO ports are placed at regular
     0x400 intervals in memory space. So far this is true for all devices.*/
  portidx = (((uint32_t)port - (uint32_t)GPIOA) >> 10U) & 0xFU;
 8000f74:	f3c0 2083 	ubfx	r0, r0, #10, #4

  /* Port selection in SYSCFG.*/
#if STM32_EXTI_TYPE == 0
  SYSCFG->EXTICR[cridx] = (SYSCFG->EXTICR[cridx] & crmask) | (portidx << croff);
 8000f78:	4f17      	ldr	r7, [pc, #92]	; (8000fd8 <_pal_lld_enablepadevent+0x78>)
 8000f7a:	3502      	adds	r5, #2
 8000f7c:	f857 4025 	ldr.w	r4, [r7, r5, lsl #2]
 8000f80:	ea24 0406 	bic.w	r4, r4, r6
 8000f84:	fa00 f101 	lsl.w	r1, r0, r1
 8000f88:	4321      	orrs	r1, r4
 8000f8a:	f847 1025 	str.w	r1, [r7, r5, lsl #2]
#else
  EXTI->EXTICR[cridx] = (EXTI->EXTICR[cridx] & crmask) | (portidx << croff);
#endif

  /* Programming edge registers.*/
  if (mode & PAL_EVENT_MODE_RISING_EDGE)
 8000f8e:	f012 0f01 	tst.w	r2, #1
 8000f92:	d014      	beq.n	8000fbe <_pal_lld_enablepadevent+0x5e>
    EXTI->RTSR1 |= padmask;
 8000f94:	4811      	ldr	r0, [pc, #68]	; (8000fdc <_pal_lld_enablepadevent+0x7c>)
 8000f96:	6881      	ldr	r1, [r0, #8]
 8000f98:	4319      	orrs	r1, r3
 8000f9a:	6081      	str	r1, [r0, #8]
  else
    EXTI->RTSR1 &= ~padmask;
  if (mode & PAL_EVENT_MODE_FALLING_EDGE)
 8000f9c:	f012 0f02 	tst.w	r2, #2
 8000fa0:	d013      	beq.n	8000fca <_pal_lld_enablepadevent+0x6a>
    EXTI->FTSR1 |= padmask;
 8000fa2:	490e      	ldr	r1, [pc, #56]	; (8000fdc <_pal_lld_enablepadevent+0x7c>)
 8000fa4:	68ca      	ldr	r2, [r1, #12]
 8000fa6:	431a      	orrs	r2, r3
 8000fa8:	60ca      	str	r2, [r1, #12]
  /* Programming interrupt and event registers.*/
#if defined(STM32_EXTI_ENHANCED)
  EXTI_D1->IMR1 |= padmask;
  EXTI_D1->EMR1 &= ~padmask;
#else
  EXTI->IMR1 |= padmask;
 8000faa:	4a0c      	ldr	r2, [pc, #48]	; (8000fdc <_pal_lld_enablepadevent+0x7c>)
 8000fac:	6811      	ldr	r1, [r2, #0]
 8000fae:	4319      	orrs	r1, r3
 8000fb0:	6011      	str	r1, [r2, #0]
  EXTI->EMR1 &= ~padmask;
 8000fb2:	6851      	ldr	r1, [r2, #4]
 8000fb4:	ea21 0303 	bic.w	r3, r1, r3
 8000fb8:	6053      	str	r3, [r2, #4]
#endif
}
 8000fba:	bcf0      	pop	{r4, r5, r6, r7}
 8000fbc:	4770      	bx	lr
    EXTI->RTSR1 &= ~padmask;
 8000fbe:	4807      	ldr	r0, [pc, #28]	; (8000fdc <_pal_lld_enablepadevent+0x7c>)
 8000fc0:	6881      	ldr	r1, [r0, #8]
 8000fc2:	ea21 0103 	bic.w	r1, r1, r3
 8000fc6:	6081      	str	r1, [r0, #8]
 8000fc8:	e7e8      	b.n	8000f9c <_pal_lld_enablepadevent+0x3c>
    EXTI->FTSR1 &= ~padmask;
 8000fca:	4904      	ldr	r1, [pc, #16]	; (8000fdc <_pal_lld_enablepadevent+0x7c>)
 8000fcc:	68ca      	ldr	r2, [r1, #12]
 8000fce:	ea22 0203 	bic.w	r2, r2, r3
 8000fd2:	60ca      	str	r2, [r1, #12]
 8000fd4:	e7e9      	b.n	8000faa <_pal_lld_enablepadevent+0x4a>
 8000fd6:	bf00      	nop
 8000fd8:	40013800 	.word	0x40013800
 8000fdc:	40013c00 	.word	0x40013c00

08000fe0 <_pal_lld_init>:
  for (i = 0; i < 16; i++) {
 8000fe0:	2300      	movs	r3, #0
 8000fe2:	2b0f      	cmp	r3, #15
 8000fe4:	d807      	bhi.n	8000ff6 <_pal_lld_init+0x16>
    _pal_init_event(i);
 8000fe6:	4904      	ldr	r1, [pc, #16]	; (8000ff8 <_pal_lld_init+0x18>)
 8000fe8:	eb01 02c3 	add.w	r2, r1, r3, lsl #3
  tqp->next = (thread_t *)tqp;
 8000fec:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
  tqp->prev = (thread_t *)tqp;
 8000ff0:	6052      	str	r2, [r2, #4]
  for (i = 0; i < 16; i++) {
 8000ff2:	3301      	adds	r3, #1
 8000ff4:	e7f5      	b.n	8000fe2 <_pal_lld_init+0x2>
}
 8000ff6:	4770      	bx	lr
 8000ff8:	20000cdc 	.word	0x20000cdc
 8000ffc:	00000000 	.word	0x00000000

08001000 <dmaInit>:
 * @init
 */
void dmaInit(void) {
  unsigned i;

  dma.allocated_mask = 0U;
 8001000:	2300      	movs	r3, #0
 8001002:	4a0d      	ldr	r2, [pc, #52]	; (8001038 <dmaInit+0x38>)
 8001004:	6013      	str	r3, [r2, #0]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 8001006:	2b0f      	cmp	r3, #15
 8001008:	d80c      	bhi.n	8001024 <dmaInit+0x24>
    _stm32_dma_streams[i].stream->CR = STM32_DMA_CR_RESET_VALUE;
 800100a:	eb03 0143 	add.w	r1, r3, r3, lsl #1
 800100e:	008a      	lsls	r2, r1, #2
 8001010:	490a      	ldr	r1, [pc, #40]	; (800103c <dmaInit+0x3c>)
 8001012:	588a      	ldr	r2, [r1, r2]
 8001014:	2100      	movs	r1, #0
 8001016:	6011      	str	r1, [r2, #0]
    dma.streams[i].func = NULL;
 8001018:	4a07      	ldr	r2, [pc, #28]	; (8001038 <dmaInit+0x38>)
 800101a:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
 800101e:	6051      	str	r1, [r2, #4]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 8001020:	3301      	adds	r3, #1
 8001022:	e7f0      	b.n	8001006 <dmaInit+0x6>
  }
  DMA1->LIFCR = 0xFFFFFFFFU;
 8001024:	4a06      	ldr	r2, [pc, #24]	; (8001040 <dmaInit+0x40>)
 8001026:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800102a:	6093      	str	r3, [r2, #8]
  DMA1->HIFCR = 0xFFFFFFFFU;
 800102c:	60d3      	str	r3, [r2, #12]
  DMA2->LIFCR = 0xFFFFFFFFU;
 800102e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001032:	6093      	str	r3, [r2, #8]
  DMA2->HIFCR = 0xFFFFFFFFU;
 8001034:	60d3      	str	r3, [r2, #12]
}
 8001036:	4770      	bx	lr
 8001038:	20001124 	.word	0x20001124
 800103c:	080032d4 	.word	0x080032d4
 8001040:	40026000 	.word	0x40026000
	...

08001050 <stm32_clock_init>:
#if !STM32_NO_INIT
  /* PWR clock enable.*/
#if defined(HAL_USE_RTC) && defined(RCC_APB1ENR_RTCAPBEN)
  RCC->APB1ENR = RCC_APB1ENR_PWREN | RCC_APB1ENR_RTCAPBEN;
#else
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8001050:	4b56      	ldr	r3, [pc, #344]	; (80011ac <stm32_clock_init+0x15c>)
 8001052:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8001056:	641a      	str	r2, [r3, #64]	; 0x40
#endif

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 8001058:	4a55      	ldr	r2, [pc, #340]	; (80011b0 <stm32_clock_init+0x160>)
 800105a:	f44f 4140 	mov.w	r1, #49152	; 0xc000
 800105e:	6011      	str	r1, [r2, #0]
  PWR->CR = 0;
#endif

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8001060:	681a      	ldr	r2, [r3, #0]
 8001062:	f042 0201 	orr.w	r2, r2, #1
 8001066:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8001068:	4b50      	ldr	r3, [pc, #320]	; (80011ac <stm32_clock_init+0x15c>)
 800106a:	681b      	ldr	r3, [r3, #0]
 800106c:	f013 0f02 	tst.w	r3, #2
 8001070:	d0fa      	beq.n	8001068 <stm32_clock_init+0x18>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW, selecting HSI.     */
 8001072:	4a4e      	ldr	r2, [pc, #312]	; (80011ac <stm32_clock_init+0x15c>)
 8001074:	6893      	ldr	r3, [r2, #8]
 8001076:	f023 0303 	bic.w	r3, r3, #3
 800107a:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 800107c:	4b4b      	ldr	r3, [pc, #300]	; (80011ac <stm32_clock_init+0x15c>)
 800107e:	689b      	ldr	r3, [r3, #8]
 8001080:	f013 0f0c 	tst.w	r3, #12
 8001084:	d1fa      	bne.n	800107c <stm32_clock_init+0x2c>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8001086:	4b49      	ldr	r3, [pc, #292]	; (80011ac <stm32_clock_init+0x15c>)
 8001088:	681a      	ldr	r2, [r3, #0]
 800108a:	f002 02f9 	and.w	r2, r2, #249	; 0xf9
 800108e:	601a      	str	r2, [r3, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8001090:	2200      	movs	r2, #0
 8001092:	609a      	str	r2, [r3, #8]

#if STM32_HSE_ENABLED
  /* HSE activation.*/
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
 8001094:	681a      	ldr	r2, [r3, #0]
 8001096:	f442 22a0 	orr.w	r2, r2, #327680	; 0x50000
 800109a:	601a      	str	r2, [r3, #0]
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 800109c:	4b43      	ldr	r3, [pc, #268]	; (80011ac <stm32_clock_init+0x15c>)
 800109e:	681b      	ldr	r3, [r3, #0]
 80010a0:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 80010a4:	d0fa      	beq.n	800109c <stm32_clock_init+0x4c>
    ;                           /* Waits until HSE is stable.               */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 80010a6:	4a41      	ldr	r2, [pc, #260]	; (80011ac <stm32_clock_init+0x15c>)
 80010a8:	6f53      	ldr	r3, [r2, #116]	; 0x74
 80010aa:	f043 0301 	orr.w	r3, r3, #1
 80010ae:	6753      	str	r3, [r2, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 80010b0:	4b3e      	ldr	r3, [pc, #248]	; (80011ac <stm32_clock_init+0x15c>)
 80010b2:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80010b4:	f013 0f02 	tst.w	r3, #2
 80010b8:	d0fa      	beq.n	80010b0 <stm32_clock_init+0x60>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
 80010ba:	4b3c      	ldr	r3, [pc, #240]	; (80011ac <stm32_clock_init+0x15c>)
 80010bc:	4a3d      	ldr	r2, [pc, #244]	; (80011b4 <stm32_clock_init+0x164>)
 80010be:	605a      	str	r2, [r3, #4]
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 80010c0:	681a      	ldr	r2, [r3, #0]
 80010c2:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 80010c6:	601a      	str	r2, [r3, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 80010c8:	4b39      	ldr	r3, [pc, #228]	; (80011b0 <stm32_clock_init+0x160>)
 80010ca:	685b      	ldr	r3, [r3, #4]
 80010cc:	f413 4f80 	tst.w	r3, #16384	; 0x4000
 80010d0:	d0fa      	beq.n	80010c8 <stm32_clock_init+0x78>
    ;                           /* Waits until power regulator is stable.   */

#if STM32_OVERDRIVE_REQUIRED
  /* Overdrive activation performed after activating the PLL in order to save
     time as recommended in RM in "Entering Over-drive mode" paragraph.*/
  PWR->CR |= PWR_CR_ODEN;
 80010d2:	4a37      	ldr	r2, [pc, #220]	; (80011b0 <stm32_clock_init+0x160>)
 80010d4:	6813      	ldr	r3, [r2, #0]
 80010d6:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80010da:	6013      	str	r3, [r2, #0]
  while (!(PWR->CSR & PWR_CSR_ODRDY))
 80010dc:	4b34      	ldr	r3, [pc, #208]	; (80011b0 <stm32_clock_init+0x160>)
 80010de:	685b      	ldr	r3, [r3, #4]
 80010e0:	f413 3f80 	tst.w	r3, #65536	; 0x10000
 80010e4:	d0fa      	beq.n	80010dc <stm32_clock_init+0x8c>
      ;
  PWR->CR |= PWR_CR_ODSWEN;
 80010e6:	4a32      	ldr	r2, [pc, #200]	; (80011b0 <stm32_clock_init+0x160>)
 80010e8:	6813      	ldr	r3, [r2, #0]
 80010ea:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80010ee:	6013      	str	r3, [r2, #0]
  while (!(PWR->CSR & PWR_CSR_ODSWRDY))
 80010f0:	4b2f      	ldr	r3, [pc, #188]	; (80011b0 <stm32_clock_init+0x160>)
 80010f2:	685b      	ldr	r3, [r3, #4]
 80010f4:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 80010f8:	d0fa      	beq.n	80010f0 <stm32_clock_init+0xa0>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */
#endif /* defined(STM32F4XX) */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
 80010fa:	4b2c      	ldr	r3, [pc, #176]	; (80011ac <stm32_clock_init+0x15c>)
 80010fc:	681b      	ldr	r3, [r3, #0]
 80010fe:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8001102:	d0fa      	beq.n	80010fa <stm32_clock_init+0xaa>
    ;
#endif /* STM32_ACTIVATE_PLL */

#if STM32_ACTIVATE_PLLI2S
  /* PLLI2S activation.*/
  RCC->PLLI2SCFGR = STM32_PLLI2SR | STM32_PLLI2SN | STM32_PLLI2SP |
 8001104:	4b29      	ldr	r3, [pc, #164]	; (80011ac <stm32_clock_init+0x15c>)
 8001106:	4a2c      	ldr	r2, [pc, #176]	; (80011b8 <stm32_clock_init+0x168>)
 8001108:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
                    STM32_PLLI2SSRC | STM32_PLLI2SQ | STM32_PLLI2SM;
  RCC->CR |= RCC_CR_PLLI2SON;
 800110c:	681a      	ldr	r2, [r3, #0]
 800110e:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 8001112:	601a      	str	r2, [r3, #0]

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLI2SRDY))
 8001114:	4b25      	ldr	r3, [pc, #148]	; (80011ac <stm32_clock_init+0x15c>)
 8001116:	681b      	ldr	r3, [r3, #0]
 8001118:	f013 6f00 	tst.w	r3, #134217728	; 0x8000000
 800111c:	d0fa      	beq.n	8001114 <stm32_clock_init+0xc4>
    ;
#endif /* STM32_ACTIVATE_PLLI2S */

#if STM32_ACTIVATE_PLLSAI
  /* PLLSAI activation.*/
  RCC->PLLSAICFGR = STM32_PLLSAIR | STM32_PLLSAIN | STM32_PLLSAIP |
 800111e:	4b23      	ldr	r3, [pc, #140]	; (80011ac <stm32_clock_init+0x15c>)
 8001120:	4a26      	ldr	r2, [pc, #152]	; (80011bc <stm32_clock_init+0x16c>)
 8001122:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
                    STM32_PLLSAIQ | STM32_PLLSAIM;
  RCC->CR |= RCC_CR_PLLSAION;
 8001126:	681a      	ldr	r2, [r3, #0]
 8001128:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800112c:	601a      	str	r2, [r3, #0]

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLSAIRDY))
 800112e:	4b1f      	ldr	r3, [pc, #124]	; (80011ac <stm32_clock_init+0x15c>)
 8001130:	681b      	ldr	r3, [r3, #0]
 8001132:	f013 5f00 	tst.w	r3, #536870912	; 0x20000000
 8001136:	d0fa      	beq.n	800112e <stm32_clock_init+0xde>
    ;
#endif /* STM32_ACTIVATE_PLLSAI */

  /* Other clock-related settings (dividers, MCO etc).*/
#if !defined(STM32F413xx)
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
 8001138:	4b1c      	ldr	r3, [pc, #112]	; (80011ac <stm32_clock_init+0x15c>)
 800113a:	4a21      	ldr	r2, [pc, #132]	; (80011c0 <stm32_clock_init+0x170>)
 800113c:	609a      	str	r2, [r3, #8]
  /* Special case, in those devices STM32_CK48MSEL is located in the
     DCKCFGR register.*/
    dckcfgr |= STM32_CK48MSEL;
#endif
#if !defined(STM32F413xx)
    RCC->DCKCFGR = dckcfgr |
 800113e:	4a21      	ldr	r2, [pc, #132]	; (80011c4 <stm32_clock_init+0x174>)
 8001140:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
  }
#endif

#if STM32_HAS_RCC_DCKCFGR2
  /* DCKCFGR2 register initialization.*/
  RCC->DCKCFGR2 = STM32_CK48MSEL;
 8001144:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8001148:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94

  /* Flash setup.*/
#if !defined(STM32_REMOVE_REVISION_A_FIX)
  /* Some old revisions of F4x MCUs randomly crashes with compiler
     optimizations enabled AND flash caches enabled. */
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 800114c:	4b1e      	ldr	r3, [pc, #120]	; (80011c8 <stm32_clock_init+0x178>)
 800114e:	681a      	ldr	r2, [r3, #0]
 8001150:	4b1e      	ldr	r3, [pc, #120]	; (80011cc <stm32_clock_init+0x17c>)
 8001152:	429a      	cmp	r2, r3
 8001154:	d01f      	beq.n	8001196 <stm32_clock_init+0x146>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 8001156:	4b1e      	ldr	r3, [pc, #120]	; (80011d0 <stm32_clock_init+0x180>)
 8001158:	f240 7205 	movw	r2, #1797	; 0x705
 800115c:	601a      	str	r2, [r3, #0]
                 FLASH_ACR_DCEN | STM32_FLASHBITS;
#else
  FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
               FLASH_ACR_DCEN | STM32_FLASHBITS;
#endif
  while ((FLASH->ACR & FLASH_ACR_LATENCY_Msk) !=
 800115e:	4b1c      	ldr	r3, [pc, #112]	; (80011d0 <stm32_clock_init+0x180>)
 8001160:	681b      	ldr	r3, [r3, #0]
 8001162:	f003 030f 	and.w	r3, r3, #15
 8001166:	2b05      	cmp	r3, #5
 8001168:	d1f9      	bne.n	800115e <stm32_clock_init+0x10e>
         (STM32_FLASHBITS & FLASH_ACR_LATENCY_Msk)) {
  }

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 800116a:	4a10      	ldr	r2, [pc, #64]	; (80011ac <stm32_clock_init+0x15c>)
 800116c:	6893      	ldr	r3, [r2, #8]
 800116e:	f043 0302 	orr.w	r3, r3, #2
 8001172:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8001174:	4b0d      	ldr	r3, [pc, #52]	; (80011ac <stm32_clock_init+0x15c>)
 8001176:	689b      	ldr	r3, [r3, #8]
 8001178:	f003 030c 	and.w	r3, r3, #12
 800117c:	2b08      	cmp	r3, #8
 800117e:	d1f9      	bne.n	8001174 <stm32_clock_init+0x124>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, true);
 8001180:	4b0a      	ldr	r3, [pc, #40]	; (80011ac <stm32_clock_init+0x15c>)
 8001182:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8001184:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8001188:	645a      	str	r2, [r3, #68]	; 0x44
 800118a:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 800118c:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8001190:	665a      	str	r2, [r3, #100]	; 0x64
 8001192:	6e5b      	ldr	r3, [r3, #100]	; 0x64
}
 8001194:	4770      	bx	lr
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 8001196:	4b0f      	ldr	r3, [pc, #60]	; (80011d4 <stm32_clock_init+0x184>)
 8001198:	681a      	ldr	r2, [r3, #0]
 800119a:	4b0f      	ldr	r3, [pc, #60]	; (80011d8 <stm32_clock_init+0x188>)
 800119c:	429a      	cmp	r2, r3
 800119e:	d1da      	bne.n	8001156 <stm32_clock_init+0x106>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
 80011a0:	4b0b      	ldr	r3, [pc, #44]	; (80011d0 <stm32_clock_init+0x180>)
 80011a2:	f240 1205 	movw	r2, #261	; 0x105
 80011a6:	601a      	str	r2, [r3, #0]
 80011a8:	e7d9      	b.n	800115e <stm32_clock_init+0x10e>
 80011aa:	bf00      	nop
 80011ac:	40023800 	.word	0x40023800
 80011b0:	40007000 	.word	0x40007000
 80011b4:	07405a08 	.word	0x07405a08
 80011b8:	44413004 	.word	0x44413004
 80011bc:	44033004 	.word	0x44033004
 80011c0:	40089400 	.word	0x40089400
 80011c4:	00800003 	.word	0x00800003
 80011c8:	e0042000 	.word	0xe0042000
 80011cc:	20006411 	.word	0x20006411
 80011d0:	40023c00 	.word	0x40023c00
 80011d4:	e000ed00 	.word	0xe000ed00
 80011d8:	410fc241 	.word	0x410fc241
 80011dc:	00000000 	.word	0x00000000

080011e0 <hal_lld_backup_domain_init>:
  PWR->CR |= PWR_CR_DBP;
 80011e0:	4a0b      	ldr	r2, [pc, #44]	; (8001210 <hal_lld_backup_domain_init+0x30>)
 80011e2:	6813      	ldr	r3, [r2, #0]
 80011e4:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80011e8:	6013      	str	r3, [r2, #0]
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 80011ea:	4b0a      	ldr	r3, [pc, #40]	; (8001214 <hal_lld_backup_domain_init+0x34>)
 80011ec:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80011ee:	f403 7340 	and.w	r3, r3, #768	; 0x300
 80011f2:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80011f6:	d005      	beq.n	8001204 <hal_lld_backup_domain_init+0x24>
    RCC->BDCR = RCC_BDCR_BDRST;
 80011f8:	4b06      	ldr	r3, [pc, #24]	; (8001214 <hal_lld_backup_domain_init+0x34>)
 80011fa:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 80011fe:	671a      	str	r2, [r3, #112]	; 0x70
    RCC->BDCR = 0;
 8001200:	2200      	movs	r2, #0
 8001202:	671a      	str	r2, [r3, #112]	; 0x70
  PWR->CSR &= ~PWR_CSR_BRE;
 8001204:	4a02      	ldr	r2, [pc, #8]	; (8001210 <hal_lld_backup_domain_init+0x30>)
 8001206:	6853      	ldr	r3, [r2, #4]
 8001208:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 800120c:	6053      	str	r3, [r2, #4]
}
 800120e:	4770      	bx	lr
 8001210:	40007000 	.word	0x40007000
 8001214:	40023800 	.word	0x40023800
	...

08001220 <nvicEnableVector>:

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001220:	0109      	lsls	r1, r1, #4
 8001222:	b2c9      	uxtb	r1, r1
 8001224:	4a07      	ldr	r2, [pc, #28]	; (8001244 <nvicEnableVector+0x24>)
 8001226:	1813      	adds	r3, r2, r0
 8001228:	f883 1300 	strb.w	r1, [r3, #768]	; 0x300
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800122c:	f000 011f 	and.w	r1, r0, #31
 8001230:	0940      	lsrs	r0, r0, #5
 8001232:	2301      	movs	r3, #1
 8001234:	408b      	lsls	r3, r1
 8001236:	f100 0160 	add.w	r1, r0, #96	; 0x60
 800123a:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800123e:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
}
 8001242:	4770      	bx	lr
 8001244:	e000e100 	.word	0xe000e100
	...

08001250 <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
 8001250:	b538      	push	{r3, r4, r5, lr}
 8001252:	4604      	mov	r4, r0

  if (config == NULL)
 8001254:	460d      	mov	r5, r1
 8001256:	b139      	cbz	r1, 8001268 <sd_lld_start+0x18>
    config = &default_config;

  if (sdp->state == SD_STOP) {
 8001258:	7a23      	ldrb	r3, [r4, #8]
 800125a:	2b01      	cmp	r3, #1
 800125c:	d006      	beq.n	800126c <sd_lld_start+0x1c>
      rccEnableUART8(true);
      nvicEnableVector(STM32_UART8_NUMBER, STM32_SERIAL_UART8_PRIORITY);
    }
#endif
  }
  usart_init(sdp, config);
 800125e:	4629      	mov	r1, r5
 8001260:	4620      	mov	r0, r4
 8001262:	f7ff fd95 	bl	8000d90 <usart_init>
}
 8001266:	bd38      	pop	{r3, r4, r5, pc}
    config = &default_config;
 8001268:	4d09      	ldr	r5, [pc, #36]	; (8001290 <sd_lld_start+0x40>)
 800126a:	e7f5      	b.n	8001258 <sd_lld_start+0x8>
    if (&SD2 == sdp) {
 800126c:	4b09      	ldr	r3, [pc, #36]	; (8001294 <sd_lld_start+0x44>)
 800126e:	429c      	cmp	r4, r3
 8001270:	d1f5      	bne.n	800125e <sd_lld_start+0xe>
      rccEnableUSART2(true);
 8001272:	4b09      	ldr	r3, [pc, #36]	; (8001298 <sd_lld_start+0x48>)
 8001274:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8001276:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 800127a:	641a      	str	r2, [r3, #64]	; 0x40
 800127c:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 800127e:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 8001282:	661a      	str	r2, [r3, #96]	; 0x60
 8001284:	6e1b      	ldr	r3, [r3, #96]	; 0x60
      nvicEnableVector(STM32_USART2_NUMBER, STM32_SERIAL_USART2_PRIORITY);
 8001286:	210c      	movs	r1, #12
 8001288:	2026      	movs	r0, #38	; 0x26
 800128a:	f7ff ffc9 	bl	8001220 <nvicEnableVector>
 800128e:	e7e6      	b.n	800125e <sd_lld_start+0xe>
 8001290:	080033ac 	.word	0x080033ac
 8001294:	20000c00 	.word	0x20000c00
 8001298:	40023800 	.word	0x40023800
 800129c:	00000000 	.word	0x00000000

080012a0 <st_lld_init>:
/**
 * @brief   Low level ST driver initialization.
 *
 * @notapi
 */
void st_lld_init(void) {
 80012a0:	b508      	push	{r3, lr}

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 80012a2:	4b12      	ldr	r3, [pc, #72]	; (80012ec <st_lld_init+0x4c>)
 80012a4:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80012a6:	f042 0201 	orr.w	r2, r2, #1
 80012aa:	641a      	str	r2, [r3, #64]	; 0x40
 80012ac:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 80012ae:	f042 0201 	orr.w	r2, r2, #1
 80012b2:	661a      	str	r2, [r3, #96]	; 0x60
 80012b4:	6e1b      	ldr	r3, [r3, #96]	; 0x60

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 80012b6:	4a0e      	ldr	r2, [pc, #56]	; (80012f0 <st_lld_init+0x50>)
 80012b8:	6893      	ldr	r3, [r2, #8]
 80012ba:	f043 0301 	orr.w	r3, r3, #1
 80012be:	6093      	str	r3, [r2, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 80012c0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80012c4:	f242 3227 	movw	r2, #8999	; 0x2327
 80012c8:	629a      	str	r2, [r3, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 80012ca:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80012ce:	62da      	str	r2, [r3, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 80012d0:	2200      	movs	r2, #0
 80012d2:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 80012d4:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->CCR[2] = 0;
#endif
#if ST_LLD_NUM_ALARMS > 3
  STM32_ST_TIM->CCR[3] = 0;
#endif
  STM32_ST_TIM->DIER   = 0;
 80012d6:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 80012d8:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 80012da:	2201      	movs	r2, #1
 80012dc:	615a      	str	r2, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 80012de:	601a      	str	r2, [r3, #0]

#if !defined(STM32_SYSTICK_SUPPRESS_ISR)
  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 80012e0:	2108      	movs	r1, #8
 80012e2:	201c      	movs	r0, #28
 80012e4:	f7ff ff9c 	bl	8001220 <nvicEnableVector>
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 80012e8:	bd08      	pop	{r3, pc}
 80012ea:	bf00      	nop
 80012ec:	40023800 	.word	0x40023800
 80012f0:	e0042000 	.word	0xe0042000
	...

08001300 <dmaStreamAllocI>:
 * @iclass
 */
const stm32_dma_stream_t *dmaStreamAllocI(uint32_t id,
                                          uint32_t priority,
                                          stm32_dmaisr_t func,
                                          void *param) {
 8001300:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t i, startid, endid;

  osalDbgCheckClassI();

  if (id < STM32_DMA_STREAMS) {
 8001302:	280f      	cmp	r0, #15
 8001304:	d805      	bhi.n	8001312 <dmaStreamAllocI+0x12>
  else {
    osalDbgCheck(false);
    return NULL;
  }

  for (i = startid; i <= endid; i++) {
 8001306:	4604      	mov	r4, r0
 8001308:	42a0      	cmp	r0, r4
 800130a:	d204      	bcs.n	8001316 <dmaStreamAllocI+0x16>

      return dmastp;
    }
  }

  return NULL;
 800130c:	2700      	movs	r7, #0
}
 800130e:	4638      	mov	r0, r7
 8001310:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return NULL;
 8001312:	2700      	movs	r7, #0
 8001314:	e7fb      	b.n	800130e <dmaStreamAllocI+0xe>
    uint32_t mask = (1U << i);
 8001316:	2501      	movs	r5, #1
 8001318:	40a5      	lsls	r5, r4
    if ((dma.allocated_mask & mask) == 0U) {
 800131a:	4e28      	ldr	r6, [pc, #160]	; (80013bc <dmaStreamAllocI+0xbc>)
 800131c:	6836      	ldr	r6, [r6, #0]
 800131e:	422e      	tst	r6, r5
 8001320:	d001      	beq.n	8001326 <dmaStreamAllocI+0x26>
  for (i = startid; i <= endid; i++) {
 8001322:	3401      	adds	r4, #1
 8001324:	e7f0      	b.n	8001308 <dmaStreamAllocI+0x8>
      const stm32_dma_stream_t *dmastp = STM32_DMA_STREAM(i);
 8001326:	4826      	ldr	r0, [pc, #152]	; (80013c0 <dmaStreamAllocI+0xc0>)
 8001328:	270c      	movs	r7, #12
 800132a:	fb07 0704 	mla	r7, r7, r4, r0
      dma.streams[i].func  = func;
 800132e:	4823      	ldr	r0, [pc, #140]	; (80013bc <dmaStreamAllocI+0xbc>)
 8001330:	eb00 0cc4 	add.w	ip, r0, r4, lsl #3
 8001334:	f8cc 2004 	str.w	r2, [ip, #4]
      dma.streams[i].param = param;
 8001338:	f8cc 3008 	str.w	r3, [ip, #8]
      dma.allocated_mask  |= mask;
 800133c:	432e      	orrs	r6, r5
 800133e:	6006      	str	r6, [r0, #0]
      if ((STM32_DMA1_STREAMS_MASK & mask) != 0U) {
 8001340:	f015 0fff 	tst.w	r5, #255	; 0xff
 8001344:	d009      	beq.n	800135a <dmaStreamAllocI+0x5a>
        rccEnableDMA1(true);
 8001346:	4b1f      	ldr	r3, [pc, #124]	; (80013c4 <dmaStreamAllocI+0xc4>)
 8001348:	6b18      	ldr	r0, [r3, #48]	; 0x30
 800134a:	f440 1000 	orr.w	r0, r0, #2097152	; 0x200000
 800134e:	6318      	str	r0, [r3, #48]	; 0x30
 8001350:	6d18      	ldr	r0, [r3, #80]	; 0x50
 8001352:	f440 1000 	orr.w	r0, r0, #2097152	; 0x200000
 8001356:	6518      	str	r0, [r3, #80]	; 0x50
 8001358:	6d1b      	ldr	r3, [r3, #80]	; 0x50
      if ((STM32_DMA2_STREAMS_MASK & mask) != 0U) {
 800135a:	f415 4f7f 	tst.w	r5, #65280	; 0xff00
 800135e:	d009      	beq.n	8001374 <dmaStreamAllocI+0x74>
        rccEnableDMA2(true);
 8001360:	4b18      	ldr	r3, [pc, #96]	; (80013c4 <dmaStreamAllocI+0xc4>)
 8001362:	6b18      	ldr	r0, [r3, #48]	; 0x30
 8001364:	f440 0080 	orr.w	r0, r0, #4194304	; 0x400000
 8001368:	6318      	str	r0, [r3, #48]	; 0x30
 800136a:	6d18      	ldr	r0, [r3, #80]	; 0x50
 800136c:	f440 0080 	orr.w	r0, r0, #4194304	; 0x400000
 8001370:	6518      	str	r0, [r3, #80]	; 0x50
 8001372:	6d1b      	ldr	r3, [r3, #80]	; 0x50
      dmaStreamDisable(dmastp);
 8001374:	230c      	movs	r3, #12
 8001376:	fb03 f304 	mul.w	r3, r3, r4
 800137a:	4811      	ldr	r0, [pc, #68]	; (80013c0 <dmaStreamAllocI+0xc0>)
 800137c:	58c0      	ldr	r0, [r0, r3]
 800137e:	6803      	ldr	r3, [r0, #0]
 8001380:	f023 031f 	bic.w	r3, r3, #31
 8001384:	6003      	str	r3, [r0, #0]
 8001386:	6803      	ldr	r3, [r0, #0]
 8001388:	f013 0f01 	tst.w	r3, #1
 800138c:	d1fb      	bne.n	8001386 <dmaStreamAllocI+0x86>
 800138e:	4d0c      	ldr	r5, [pc, #48]	; (80013c0 <dmaStreamAllocI+0xc0>)
 8001390:	230c      	movs	r3, #12
 8001392:	fb03 5304 	mla	r3, r3, r4, r5
 8001396:	7a5e      	ldrb	r6, [r3, #9]
 8001398:	685d      	ldr	r5, [r3, #4]
 800139a:	233d      	movs	r3, #61	; 0x3d
 800139c:	40b3      	lsls	r3, r6
 800139e:	602b      	str	r3, [r5, #0]
      dmastp->stream->CR = STM32_DMA_CR_RESET_VALUE;
 80013a0:	2300      	movs	r3, #0
 80013a2:	6003      	str	r3, [r0, #0]
      dmastp->stream->FCR = STM32_DMA_FCR_RESET_VALUE;
 80013a4:	2321      	movs	r3, #33	; 0x21
 80013a6:	6143      	str	r3, [r0, #20]
      if (func != NULL) {
 80013a8:	2a00      	cmp	r2, #0
 80013aa:	d0b0      	beq.n	800130e <dmaStreamAllocI+0xe>
        nvicEnableVector(dmastp->vector, priority);
 80013ac:	4a04      	ldr	r2, [pc, #16]	; (80013c0 <dmaStreamAllocI+0xc0>)
 80013ae:	230c      	movs	r3, #12
 80013b0:	fb03 2404 	mla	r4, r3, r4, r2
 80013b4:	7ae0      	ldrb	r0, [r4, #11]
 80013b6:	f7ff ff33 	bl	8001220 <nvicEnableVector>
      return dmastp;
 80013ba:	e7a8      	b.n	800130e <dmaStreamAllocI+0xe>
 80013bc:	20001124 	.word	0x20001124
 80013c0:	080032d4 	.word	0x080032d4
 80013c4:	40023800 	.word	0x40023800
	...

080013d0 <spi_lld_start>:
void spi_lld_start(SPIDriver *spip) {
 80013d0:	b510      	push	{r4, lr}
 80013d2:	4604      	mov	r4, r0
  if (spip->state == SPI_STOP) {
 80013d4:	7803      	ldrb	r3, [r0, #0]
 80013d6:	2b01      	cmp	r3, #1
 80013d8:	d02e      	beq.n	8001438 <spi_lld_start+0x68>
  if ((spip->config->cr1 & SPI_CR1_DFF) == 0) {
 80013da:	6863      	ldr	r3, [r4, #4]
 80013dc:	8a1a      	ldrh	r2, [r3, #16]
 80013de:	f412 6f00 	tst.w	r2, #2048	; 0x800
 80013e2:	d16c      	bne.n	80014be <spi_lld_start+0xee>
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 80013e4:	6aa2      	ldr	r2, [r4, #40]	; 0x28
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
 80013e6:	f422 42f0 	bic.w	r2, r2, #30720	; 0x7800
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 80013ea:	62a2      	str	r2, [r4, #40]	; 0x28
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 80013ec:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
 80013ee:	f422 42f0 	bic.w	r2, r2, #30720	; 0x7800
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 80013f2:	62e2      	str	r2, [r4, #44]	; 0x2c
  if (spip->config->circular) {
 80013f4:	781b      	ldrb	r3, [r3, #0]
 80013f6:	2b00      	cmp	r3, #0
 80013f8:	d06e      	beq.n	80014d8 <spi_lld_start+0x108>
    spip->rxdmamode |= (STM32_DMA_CR_CIRC | STM32_DMA_CR_HTIE);
 80013fa:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80013fc:	f443 7384 	orr.w	r3, r3, #264	; 0x108
 8001400:	62a3      	str	r3, [r4, #40]	; 0x28
    spip->txdmamode |= (STM32_DMA_CR_CIRC | STM32_DMA_CR_HTIE);
 8001402:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8001404:	f443 7384 	orr.w	r3, r3, #264	; 0x108
 8001408:	62e3      	str	r3, [r4, #44]	; 0x2c
  spip->spi->CR1 &= ~SPI_CR1_SPE;
 800140a:	69e2      	ldr	r2, [r4, #28]
 800140c:	6813      	ldr	r3, [r2, #0]
 800140e:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8001412:	6013      	str	r3, [r2, #0]
  spip->spi->CR1  = spip->config->cr1 | SPI_CR1_MSTR | SPI_CR1_SSM |
 8001414:	6863      	ldr	r3, [r4, #4]
 8001416:	8a1b      	ldrh	r3, [r3, #16]
 8001418:	69e2      	ldr	r2, [r4, #28]
 800141a:	f443 7341 	orr.w	r3, r3, #772	; 0x304
 800141e:	6013      	str	r3, [r2, #0]
  spip->spi->CR2  = spip->config->cr2 | SPI_CR2_SSOE | SPI_CR2_RXDMAEN |
 8001420:	6863      	ldr	r3, [r4, #4]
 8001422:	8a5b      	ldrh	r3, [r3, #18]
 8001424:	69e2      	ldr	r2, [r4, #28]
 8001426:	f043 0307 	orr.w	r3, r3, #7
 800142a:	6053      	str	r3, [r2, #4]
  spip->spi->CR1 |= SPI_CR1_SPE;
 800142c:	69e2      	ldr	r2, [r4, #28]
 800142e:	6813      	ldr	r3, [r2, #0]
 8001430:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8001434:	6013      	str	r3, [r2, #0]
}
 8001436:	bd10      	pop	{r4, pc}
    if (&SPID1 == spip) {
 8001438:	4b2c      	ldr	r3, [pc, #176]	; (80014ec <spi_lld_start+0x11c>)
 800143a:	4298      	cmp	r0, r3
 800143c:	d00d      	beq.n	800145a <spi_lld_start+0x8a>
    if (&SPID2 == spip) {
 800143e:	4b2c      	ldr	r3, [pc, #176]	; (80014f0 <spi_lld_start+0x120>)
 8001440:	429c      	cmp	r4, r3
 8001442:	d023      	beq.n	800148c <spi_lld_start+0xbc>
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
 8001444:	6a23      	ldr	r3, [r4, #32]
 8001446:	681a      	ldr	r2, [r3, #0]
 8001448:	69e3      	ldr	r3, [r4, #28]
 800144a:	330c      	adds	r3, #12
 800144c:	6093      	str	r3, [r2, #8]
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
 800144e:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8001450:	681a      	ldr	r2, [r3, #0]
 8001452:	69e3      	ldr	r3, [r4, #28]
 8001454:	330c      	adds	r3, #12
 8001456:	6093      	str	r3, [r2, #8]
 8001458:	e7bf      	b.n	80013da <spi_lld_start+0xa>
      spip->dmarx = dmaStreamAllocI(STM32_SPI_SPI1_RX_DMA_STREAM,
 800145a:	4603      	mov	r3, r0
 800145c:	4a25      	ldr	r2, [pc, #148]	; (80014f4 <spi_lld_start+0x124>)
 800145e:	210a      	movs	r1, #10
 8001460:	2008      	movs	r0, #8
 8001462:	f7ff ff4d 	bl	8001300 <dmaStreamAllocI>
 8001466:	6220      	str	r0, [r4, #32]
      spip->dmatx = dmaStreamAllocI(STM32_SPI_SPI1_TX_DMA_STREAM,
 8001468:	4623      	mov	r3, r4
 800146a:	4a23      	ldr	r2, [pc, #140]	; (80014f8 <spi_lld_start+0x128>)
 800146c:	210a      	movs	r1, #10
 800146e:	200b      	movs	r0, #11
 8001470:	f7ff ff46 	bl	8001300 <dmaStreamAllocI>
 8001474:	6260      	str	r0, [r4, #36]	; 0x24
      rccEnableSPI1(true);
 8001476:	4b21      	ldr	r3, [pc, #132]	; (80014fc <spi_lld_start+0x12c>)
 8001478:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800147a:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 800147e:	645a      	str	r2, [r3, #68]	; 0x44
 8001480:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 8001482:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8001486:	665a      	str	r2, [r3, #100]	; 0x64
 8001488:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800148a:	e7d8      	b.n	800143e <spi_lld_start+0x6e>
      spip->dmarx = dmaStreamAllocI(STM32_SPI_SPI2_RX_DMA_STREAM,
 800148c:	4623      	mov	r3, r4
 800148e:	4a19      	ldr	r2, [pc, #100]	; (80014f4 <spi_lld_start+0x124>)
 8001490:	210a      	movs	r1, #10
 8001492:	2003      	movs	r0, #3
 8001494:	f7ff ff34 	bl	8001300 <dmaStreamAllocI>
 8001498:	6220      	str	r0, [r4, #32]
      spip->dmatx = dmaStreamAllocI(STM32_SPI_SPI2_TX_DMA_STREAM,
 800149a:	4623      	mov	r3, r4
 800149c:	4a16      	ldr	r2, [pc, #88]	; (80014f8 <spi_lld_start+0x128>)
 800149e:	210a      	movs	r1, #10
 80014a0:	2004      	movs	r0, #4
 80014a2:	f7ff ff2d 	bl	8001300 <dmaStreamAllocI>
 80014a6:	6260      	str	r0, [r4, #36]	; 0x24
      rccEnableSPI2(true);
 80014a8:	4b14      	ldr	r3, [pc, #80]	; (80014fc <spi_lld_start+0x12c>)
 80014aa:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80014ac:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 80014b0:	641a      	str	r2, [r3, #64]	; 0x40
 80014b2:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 80014b4:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 80014b8:	661a      	str	r2, [r3, #96]	; 0x60
 80014ba:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80014bc:	e7c2      	b.n	8001444 <spi_lld_start+0x74>
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 80014be:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 80014c0:	f422 42f0 	bic.w	r2, r2, #30720	; 0x7800
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
 80014c4:	f442 5220 	orr.w	r2, r2, #10240	; 0x2800
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 80014c8:	62a2      	str	r2, [r4, #40]	; 0x28
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 80014ca:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80014cc:	f422 42f0 	bic.w	r2, r2, #30720	; 0x7800
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
 80014d0:	f442 5220 	orr.w	r2, r2, #10240	; 0x2800
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 80014d4:	62e2      	str	r2, [r4, #44]	; 0x2c
 80014d6:	e78d      	b.n	80013f4 <spi_lld_start+0x24>
    spip->rxdmamode &= ~(STM32_DMA_CR_CIRC | STM32_DMA_CR_HTIE);
 80014d8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80014da:	f423 7384 	bic.w	r3, r3, #264	; 0x108
 80014de:	62a3      	str	r3, [r4, #40]	; 0x28
    spip->txdmamode &= ~(STM32_DMA_CR_CIRC | STM32_DMA_CR_HTIE);
 80014e0:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80014e2:	f423 7384 	bic.w	r3, r3, #264	; 0x108
 80014e6:	62e3      	str	r3, [r4, #44]	; 0x2c
 80014e8:	e78f      	b.n	800140a <spi_lld_start+0x3a>
 80014ea:	bf00      	nop
 80014ec:	20000c7c 	.word	0x20000c7c
 80014f0:	20000cac 	.word	0x20000cac
 80014f4:	08000e71 	.word	0x08000e71
 80014f8:	08000f41 	.word	0x08000f41
 80014fc:	40023800 	.word	0x40023800

08001500 <irqInit>:
/**
 * @brief   Enables IRQ sources.
 *
 * @notapi
 */
void irqInit(void) {
 8001500:	b508      	push	{r3, lr}

#if HAL_USE_PAL
  nvicEnableVector(EXTI0_IRQn, STM32_IRQ_EXTI0_PRIORITY);
 8001502:	2106      	movs	r1, #6
 8001504:	4608      	mov	r0, r1
 8001506:	f7ff fe8b 	bl	8001220 <nvicEnableVector>
  nvicEnableVector(EXTI1_IRQn, STM32_IRQ_EXTI1_PRIORITY);
 800150a:	2106      	movs	r1, #6
 800150c:	2007      	movs	r0, #7
 800150e:	f7ff fe87 	bl	8001220 <nvicEnableVector>
  nvicEnableVector(EXTI2_IRQn, STM32_IRQ_EXTI2_PRIORITY);
 8001512:	2106      	movs	r1, #6
 8001514:	2008      	movs	r0, #8
 8001516:	f7ff fe83 	bl	8001220 <nvicEnableVector>
  nvicEnableVector(EXTI3_IRQn, STM32_IRQ_EXTI3_PRIORITY);
 800151a:	2106      	movs	r1, #6
 800151c:	2009      	movs	r0, #9
 800151e:	f7ff fe7f 	bl	8001220 <nvicEnableVector>
  nvicEnableVector(EXTI4_IRQn, STM32_IRQ_EXTI4_PRIORITY);
 8001522:	2106      	movs	r1, #6
 8001524:	200a      	movs	r0, #10
 8001526:	f7ff fe7b 	bl	8001220 <nvicEnableVector>
  nvicEnableVector(EXTI9_5_IRQn, STM32_IRQ_EXTI5_9_PRIORITY);
 800152a:	2106      	movs	r1, #6
 800152c:	2017      	movs	r0, #23
 800152e:	f7ff fe77 	bl	8001220 <nvicEnableVector>
  nvicEnableVector(EXTI15_10_IRQn, STM32_IRQ_EXTI10_15_PRIORITY);
 8001532:	2106      	movs	r1, #6
 8001534:	2028      	movs	r0, #40	; 0x28
 8001536:	f7ff fe73 	bl	8001220 <nvicEnableVector>
#endif
}
 800153a:	bd08      	pop	{r3, pc}
 800153c:	0000      	movs	r0, r0
	...

08001540 <hal_lld_init>:
void hal_lld_init(void) {
 8001540:	b508      	push	{r3, lr}
  rccResetAHB1(~STM32_GPIO_EN_MASK);
 8001542:	4b17      	ldr	r3, [pc, #92]	; (80015a0 <hal_lld_init+0x60>)
 8001544:	691a      	ldr	r2, [r3, #16]
 8001546:	f062 02ff 	orn	r2, r2, #255	; 0xff
 800154a:	611a      	str	r2, [r3, #16]
 800154c:	691a      	ldr	r2, [r3, #16]
 800154e:	b2d2      	uxtb	r2, r2
 8001550:	611a      	str	r2, [r3, #16]
 8001552:	691a      	ldr	r2, [r3, #16]
  rccResetAHB2(~0);
 8001554:	695a      	ldr	r2, [r3, #20]
 8001556:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800155a:	6158      	str	r0, [r3, #20]
 800155c:	695a      	ldr	r2, [r3, #20]
 800155e:	2100      	movs	r1, #0
 8001560:	6159      	str	r1, [r3, #20]
 8001562:	695a      	ldr	r2, [r3, #20]
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 8001564:	6a1a      	ldr	r2, [r3, #32]
 8001566:	f062 5280 	orn	r2, r2, #268435456	; 0x10000000
 800156a:	621a      	str	r2, [r3, #32]
 800156c:	6a1a      	ldr	r2, [r3, #32]
 800156e:	f002 5280 	and.w	r2, r2, #268435456	; 0x10000000
 8001572:	621a      	str	r2, [r3, #32]
 8001574:	6a1a      	ldr	r2, [r3, #32]
  rccResetAPB2(~0);
 8001576:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8001578:	6258      	str	r0, [r3, #36]	; 0x24
 800157a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800157c:	6259      	str	r1, [r3, #36]	; 0x24
 800157e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
  rccEnablePWRInterface(true);
 8001580:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8001582:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8001586:	641a      	str	r2, [r3, #64]	; 0x40
 8001588:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 800158a:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800158e:	661a      	str	r2, [r3, #96]	; 0x60
 8001590:	6e1b      	ldr	r3, [r3, #96]	; 0x60
  hal_lld_backup_domain_init();
 8001592:	f7ff fe25 	bl	80011e0 <hal_lld_backup_domain_init>
  dmaInit();
 8001596:	f7ff fd33 	bl	8001000 <dmaInit>
  irqInit();
 800159a:	f7ff ffb1 	bl	8001500 <irqInit>
}
 800159e:	bd08      	pop	{r3, pc}
 80015a0:	40023800 	.word	0x40023800
	...

080015b0 <spiStartExchange>:
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @api
 */
void spiStartExchange(SPIDriver *spip, size_t n,
                      const void *txbuf, void *rxbuf) {
 80015b0:	b538      	push	{r3, r4, r5, lr}
 80015b2:	2520      	movs	r5, #32
 80015b4:	f385 8811 	msr	BASEPRI, r5
  osalDbgCheck((spip != NULL) && (n > 0U) &&
               (rxbuf != NULL) && (txbuf != NULL));

  osalSysLock();
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  spiStartExchangeI(spip, n, txbuf, rxbuf);
 80015b8:	2503      	movs	r5, #3
 80015ba:	7005      	strb	r5, [r0, #0]
 80015bc:	f7ff fc30 	bl	8000e20 <spi_lld_exchange>
 80015c0:	2300      	movs	r3, #0
 80015c2:	f383 8811 	msr	BASEPRI, r3
  osalSysUnlock();
}
 80015c6:	bd38      	pop	{r3, r4, r5, pc}
	...

080015d0 <spiUnselect>:
 80015d0:	2320      	movs	r3, #32
 80015d2:	f383 8811 	msr	BASEPRI, r3
  spiUnselectI(spip);
 80015d6:	6843      	ldr	r3, [r0, #4]
 80015d8:	689a      	ldr	r2, [r3, #8]
 80015da:	68d9      	ldr	r1, [r3, #12]
 80015dc:	2301      	movs	r3, #1
 80015de:	408b      	lsls	r3, r1
 80015e0:	b29b      	uxth	r3, r3
 80015e2:	8313      	strh	r3, [r2, #24]
 80015e4:	2300      	movs	r3, #0
 80015e6:	f383 8811 	msr	BASEPRI, r3
}
 80015ea:	4770      	bx	lr
 80015ec:	0000      	movs	r0, r0
	...

080015f0 <spiSelect>:
 80015f0:	2320      	movs	r3, #32
 80015f2:	f383 8811 	msr	BASEPRI, r3
  spiSelectI(spip);
 80015f6:	6843      	ldr	r3, [r0, #4]
 80015f8:	689a      	ldr	r2, [r3, #8]
 80015fa:	68d9      	ldr	r1, [r3, #12]
 80015fc:	2301      	movs	r3, #1
 80015fe:	408b      	lsls	r3, r1
 8001600:	b29b      	uxth	r3, r3
 8001602:	8353      	strh	r3, [r2, #26]
 8001604:	2300      	movs	r3, #0
 8001606:	f383 8811 	msr	BASEPRI, r3
}
 800160a:	4770      	bx	lr
 800160c:	0000      	movs	r0, r0
	...

08001610 <ax5043_read_reg>:
uint8_t ax5043_read_reg(SPIDriver * spip, uint16_t reg, uint8_t value, uint8_t ret_value[]){
 8001610:	b530      	push	{r4, r5, lr}
 8001612:	b083      	sub	sp, #12
 8001614:	4604      	mov	r4, r0
 8001616:	461d      	mov	r5, r3
  uint8_t command_buf[3] = {0,0,0 };
 8001618:	4b19      	ldr	r3, [pc, #100]	; (8001680 <ax5043_read_reg+0x70>)
 800161a:	885b      	ldrh	r3, [r3, #2]
 800161c:	f88d 3006 	strb.w	r3, [sp, #6]
  if(reg <  0x0070){
 8001620:	296f      	cmp	r1, #111	; 0x6f
 8001622:	d814      	bhi.n	800164e <ax5043_read_reg+0x3e>
    command_buf[0]=reg;
 8001624:	f88d 1004 	strb.w	r1, [sp, #4]
    command_buf[1]=value;
 8001628:	f88d 2005 	strb.w	r2, [sp, #5]
    spiSelect(spip);
 800162c:	f7ff ffe0 	bl	80015f0 <spiSelect>
    spiStartExchange(spip, 2, command_buf, ret_value);
 8001630:	462b      	mov	r3, r5
 8001632:	aa01      	add	r2, sp, #4
 8001634:	2102      	movs	r1, #2
 8001636:	4620      	mov	r0, r4
 8001638:	f7ff ffba 	bl	80015b0 <spiStartExchange>
    while((*spip).state != SPI_READY) { }
 800163c:	7822      	ldrb	r2, [r4, #0]
 800163e:	2a02      	cmp	r2, #2
 8001640:	d1fc      	bne.n	800163c <ax5043_read_reg+0x2c>
    spiUnselect(spip);
 8001642:	4620      	mov	r0, r4
 8001644:	f7ff ffc4 	bl	80015d0 <spiUnselect>
    return ret_value[1];    
 8001648:	7868      	ldrb	r0, [r5, #1]
}
 800164a:	b003      	add	sp, #12
 800164c:	bd30      	pop	{r4, r5, pc}
    command_buf[0]=0x70|(reg>>8);
 800164e:	0a0b      	lsrs	r3, r1, #8
 8001650:	f043 0370 	orr.w	r3, r3, #112	; 0x70
 8001654:	f88d 3004 	strb.w	r3, [sp, #4]
    command_buf[1]=reg;
 8001658:	f88d 1005 	strb.w	r1, [sp, #5]
    command_buf[2]=value;
 800165c:	f88d 2006 	strb.w	r2, [sp, #6]
    spiSelect(spip);
 8001660:	f7ff ffc6 	bl	80015f0 <spiSelect>
    spiStartExchange(spip, 3, command_buf, ret_value);
 8001664:	462b      	mov	r3, r5
 8001666:	aa01      	add	r2, sp, #4
 8001668:	2103      	movs	r1, #3
 800166a:	4620      	mov	r0, r4
 800166c:	f7ff ffa0 	bl	80015b0 <spiStartExchange>
    while((*spip).state != SPI_READY) { }
 8001670:	7822      	ldrb	r2, [r4, #0]
 8001672:	2a02      	cmp	r2, #2
 8001674:	d1fc      	bne.n	8001670 <ax5043_read_reg+0x60>
    spiUnselect(spip);
 8001676:	4620      	mov	r0, r4
 8001678:	f7ff ffaa 	bl	80015d0 <spiUnselect>
    return ret_value[2];
 800167c:	78a8      	ldrb	r0, [r5, #2]
 800167e:	e7e4      	b.n	800164a <ax5043_read_reg+0x3a>
 8001680:	08003254 	.word	0x08003254
	...

08001690 <axradio_get_pllvcoi>:
uint8_t axradio_get_pllvcoi(AX5043Driver *devp){
 8001690:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8001694:	b083      	sub	sp, #12
 8001696:	4604      	mov	r4, r0
  uint8_t ret_value[3]={0,0,0};
 8001698:	4b1c      	ldr	r3, [pc, #112]	; (800170c <axradio_get_pllvcoi+0x7c>)
 800169a:	681b      	ldr	r3, [r3, #0]
 800169c:	f8ad 3004 	strh.w	r3, [sp, #4]
 80016a0:	0c1b      	lsrs	r3, r3, #16
 80016a2:	f88d 3006 	strb.w	r3, [sp, #6]
  SPIDriver *spip = devp->config->spip;
 80016a6:	6883      	ldr	r3, [r0, #8]
 80016a8:	f8d3 9000 	ldr.w	r9, [r3]
  uint8_t x = ax5043_get_conf_val(devp, AXRADIO_PHY_CHANVCOIINIT) ;
 80016ac:	2104      	movs	r1, #4
 80016ae:	f7ff f83f 	bl	8000730 <ax5043_get_conf_val>
 80016b2:	4605      	mov	r5, r0
 80016b4:	b2c7      	uxtb	r7, r0
  uint8_t pll_init_val = ax5043_get_conf_val(devp, AXRADIO_PHY_CHANPLLRNGINIT);
 80016b6:	2103      	movs	r1, #3
 80016b8:	4620      	mov	r0, r4
 80016ba:	f7ff f839 	bl	8000730 <ax5043_get_conf_val>
 80016be:	4606      	mov	r6, r0
 80016c0:	fa5f f880 	uxtb.w	r8, r0
  uint8_t pll_val = ax5043_get_conf_val(devp, AXRADIO_PHY_CHANPLLRNG);
 80016c4:	2105      	movs	r1, #5
 80016c6:	4620      	mov	r0, r4
 80016c8:	f7ff f832 	bl	8000730 <ax5043_get_conf_val>
  if (x & 0x80) {
 80016cc:	f015 0f80 	tst.w	r5, #128	; 0x80
 80016d0:	d10b      	bne.n	80016ea <axradio_get_pllvcoi+0x5a>
  return ax5043_read_reg(spip, AX5043_REG_PLLVCOI, (uint8_t)0x00, ret_value);
 80016d2:	ab01      	add	r3, sp, #4
 80016d4:	2200      	movs	r2, #0
 80016d6:	f44f 71c0 	mov.w	r1, #384	; 0x180
 80016da:	4648      	mov	r0, r9
 80016dc:	f7ff ff98 	bl	8001610 <ax5043_read_reg>
 80016e0:	4607      	mov	r7, r0
}
 80016e2:	4638      	mov	r0, r7
 80016e4:	b003      	add	sp, #12
 80016e6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80016ea:	b2c3      	uxtb	r3, r0
    if (!(pll_init_val & 0xF0)) {
 80016ec:	f016 0ff0 	tst.w	r6, #240	; 0xf0
 80016f0:	d1f7      	bne.n	80016e2 <axradio_get_pllvcoi+0x52>
      x += (pll_val & 0x0F) - (pll_init_val & 0x0F);
 80016f2:	f003 030f 	and.w	r3, r3, #15
 80016f6:	f008 000f 	and.w	r0, r8, #15
 80016fa:	1a1b      	subs	r3, r3, r0
 80016fc:	fa57 f083 	uxtab	r0, r7, r3
      x &= 0x3f;
 8001700:	f000 003f 	and.w	r0, r0, #63	; 0x3f
      x |= 0x80;
 8001704:	f040 0780 	orr.w	r7, r0, #128	; 0x80
    return x;
 8001708:	e7eb      	b.n	80016e2 <axradio_get_pllvcoi+0x52>
 800170a:	bf00      	nop
 800170c:	08003254 	.word	0x08003254

08001710 <ax5043_readfifo>:
uint8_t ax5043_readfifo(SPIDriver * spip, uint8_t axradio_rxbuffer[], uint8_t len) {
 8001710:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001712:	b083      	sub	sp, #12
 8001714:	4607      	mov	r7, r0
 8001716:	460e      	mov	r6, r1
  uint8_t ret_value[3]={0,0,0};
 8001718:	4b0c      	ldr	r3, [pc, #48]	; (800174c <ax5043_readfifo+0x3c>)
 800171a:	681b      	ldr	r3, [r3, #0]
 800171c:	f8ad 3004 	strh.w	r3, [sp, #4]
 8001720:	0c1b      	lsrs	r3, r3, #16
 8001722:	f88d 3006 	strb.w	r3, [sp, #6]
  uint8_t bytes_read = 0;
 8001726:	2400      	movs	r4, #0
  while (len--) {
 8001728:	1e53      	subs	r3, r2, #1
 800172a:	b2dd      	uxtb	r5, r3
 800172c:	b152      	cbz	r2, 8001744 <ax5043_readfifo+0x34>
    axradio_rxbuffer[bytes_read] = ax5043_read_reg(spip, AX5043_REG_FIFODATA, (uint8_t)0x00, ret_value);
 800172e:	ab01      	add	r3, sp, #4
 8001730:	2200      	movs	r2, #0
 8001732:	2129      	movs	r1, #41	; 0x29
 8001734:	4638      	mov	r0, r7
 8001736:	f7ff ff6b 	bl	8001610 <ax5043_read_reg>
 800173a:	5530      	strb	r0, [r6, r4]
    bytes_read++;
 800173c:	3401      	adds	r4, #1
 800173e:	b2e4      	uxtb	r4, r4
  while (len--) {
 8001740:	462a      	mov	r2, r5
 8001742:	e7f1      	b.n	8001728 <ax5043_readfifo+0x18>
}
 8001744:	4620      	mov	r0, r4
 8001746:	b003      	add	sp, #12
 8001748:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800174a:	bf00      	nop
 800174c:	08003254 	.word	0x08003254

08001750 <receive_loop>:
uint8_t receive_loop(AX5043Driver *devp, uint8_t axradio_rxbuffer[]) {
 8001750:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8001754:	b082      	sub	sp, #8
 8001756:	4606      	mov	r6, r0
 8001758:	4689      	mov	r9, r1
  uint8_t ret_value[3]={0,0,0};
 800175a:	4b78      	ldr	r3, [pc, #480]	; (800193c <receive_loop+0x1ec>)
 800175c:	681b      	ldr	r3, [r3, #0]
 800175e:	f8ad 3004 	strh.w	r3, [sp, #4]
 8001762:	0c1b      	lsrs	r3, r3, #16
 8001764:	f88d 3006 	strb.w	r3, [sp, #6]
  SPIDriver *spip = devp->config->spip;
 8001768:	6883      	ldr	r3, [r0, #8]
 800176a:	681f      	ldr	r7, [r3, #0]
  ax5043_read_reg(spip, AX5043_REG_RADIOEVENTREQ0, (uint8_t)0x00, ret_value);  
 800176c:	ab01      	add	r3, sp, #4
 800176e:	2200      	movs	r2, #0
 8001770:	210f      	movs	r1, #15
 8001772:	4638      	mov	r0, r7
 8001774:	f7ff ff4c 	bl	8001610 <ax5043_read_reg>
  devp->state = AX5043_RX_LOOP;
 8001778:	2306      	movs	r3, #6
 800177a:	7133      	strb	r3, [r6, #4]
  uint8_t bytesRead = 0;
 800177c:	f04f 0800 	mov.w	r8, #0
 8001780:	e094      	b.n	80018ac <receive_loop+0x15c>
      chunk_len = ax5043_read_reg(spip, AX5043_REG_FIFODATA, (uint8_t)0x00, ret_value); 
 8001782:	ab01      	add	r3, sp, #4
 8001784:	2200      	movs	r2, #0
 8001786:	2129      	movs	r1, #41	; 0x29
 8001788:	4638      	mov	r0, r7
 800178a:	f7ff ff41 	bl	8001610 <ax5043_read_reg>
 800178e:	4682      	mov	sl, r0
 8001790:	e0a2      	b.n	80018d8 <receive_loop+0x188>
      if (chunk_len!=0){
 8001792:	f1ba 0f00 	cmp.w	sl, #0
 8001796:	f000 8087 	beq.w	80018a8 <receive_loop+0x158>
        ax5043_read_reg(spip, AX5043_REG_FIFODATA, (uint8_t)0x00, ret_value); 
 800179a:	ab01      	add	r3, sp, #4
 800179c:	2200      	movs	r2, #0
 800179e:	2129      	movs	r1, #41	; 0x29
 80017a0:	4638      	mov	r0, r7
 80017a2:	f7ff ff35 	bl	8001610 <ax5043_read_reg>
        chunk_len = chunk_len - 1;
 80017a6:	f10a 32ff 	add.w	r2, sl, #4294967295	; 0xffffffff
        bytesRead = ax5043_readfifo(spip, axradio_rxbuffer, chunk_len);
 80017aa:	b2d2      	uxtb	r2, r2
 80017ac:	4649      	mov	r1, r9
 80017ae:	4638      	mov	r0, r7
 80017b0:	f7ff ffae 	bl	8001710 <ax5043_readfifo>
 80017b4:	4680      	mov	r8, r0
 80017b6:	e077      	b.n	80018a8 <receive_loop+0x158>
      if (chunk_len == 3){
 80017b8:	f1ba 0f03 	cmp.w	sl, #3
 80017bc:	d00f      	beq.n	80017de <receive_loop+0x8e>
        for(i=0;i<chunk_len;i++){
 80017be:	4554      	cmp	r4, sl
 80017c0:	d272      	bcs.n	80018a8 <receive_loop+0x158>
          devp->dropped[i] = ax5043_read_reg(spip, AX5043_REG_FIFODATA, (uint8_t)0x00, ret_value);
 80017c2:	ab01      	add	r3, sp, #4
 80017c4:	2200      	movs	r2, #0
 80017c6:	2129      	movs	r1, #41	; 0x29
 80017c8:	4638      	mov	r0, r7
 80017ca:	f7ff ff21 	bl	8001610 <ax5043_read_reg>
 80017ce:	1933      	adds	r3, r6, r4
 80017d0:	7418      	strb	r0, [r3, #16]
          devp->error_code = AXRADIO_ERR_FIFO_CHUNK;
 80017d2:	230c      	movs	r3, #12
 80017d4:	f886 310a 	strb.w	r3, [r6, #266]	; 0x10a
        for(i=0;i<chunk_len;i++){
 80017d8:	3401      	adds	r4, #1
 80017da:	b2e4      	uxtb	r4, r4
 80017dc:	e7ef      	b.n	80017be <receive_loop+0x6e>
        devp->rf_freq_off3 = ax5043_read_reg(spip, AX5043_REG_FIFODATA, (uint8_t)0x00, ret_value);
 80017de:	ab01      	add	r3, sp, #4
 80017e0:	2200      	movs	r2, #0
 80017e2:	2129      	movs	r1, #41	; 0x29
 80017e4:	4638      	mov	r0, r7
 80017e6:	f7ff ff13 	bl	8001610 <ax5043_read_reg>
 80017ea:	73b0      	strb	r0, [r6, #14]
        devp->rf_freq_off2 = ax5043_read_reg(spip, AX5043_REG_FIFODATA, (uint8_t)0x00, ret_value);
 80017ec:	ab01      	add	r3, sp, #4
 80017ee:	2200      	movs	r2, #0
 80017f0:	2129      	movs	r1, #41	; 0x29
 80017f2:	4638      	mov	r0, r7
 80017f4:	f7ff ff0c 	bl	8001610 <ax5043_read_reg>
 80017f8:	7370      	strb	r0, [r6, #13]
        devp->rf_freq_off1 = ax5043_read_reg(spip, AX5043_REG_FIFODATA, (uint8_t)0x00, ret_value);
 80017fa:	ab01      	add	r3, sp, #4
 80017fc:	2200      	movs	r2, #0
 80017fe:	2129      	movs	r1, #41	; 0x29
 8001800:	4638      	mov	r0, r7
 8001802:	f7ff ff05 	bl	8001610 <ax5043_read_reg>
 8001806:	7330      	strb	r0, [r6, #12]
 8001808:	e04e      	b.n	80018a8 <receive_loop+0x158>
      if (chunk_len == 2){
 800180a:	f1ba 0f02 	cmp.w	sl, #2
 800180e:	d00f      	beq.n	8001830 <receive_loop+0xe0>
        for(i=0;i<chunk_len;i++){
 8001810:	4554      	cmp	r4, sl
 8001812:	d249      	bcs.n	80018a8 <receive_loop+0x158>
          devp->dropped[i] = ax5043_read_reg(spip, AX5043_REG_FIFODATA, (uint8_t)0x00, ret_value);
 8001814:	ab01      	add	r3, sp, #4
 8001816:	2200      	movs	r2, #0
 8001818:	2129      	movs	r1, #41	; 0x29
 800181a:	4638      	mov	r0, r7
 800181c:	f7ff fef8 	bl	8001610 <ax5043_read_reg>
 8001820:	1933      	adds	r3, r6, r4
 8001822:	7418      	strb	r0, [r3, #16]
          devp->error_code = AXRADIO_ERR_FIFO_CHUNK;
 8001824:	230c      	movs	r3, #12
 8001826:	f886 310a 	strb.w	r3, [r6, #266]	; 0x10a
        for(i=0;i<chunk_len;i++){
 800182a:	3401      	adds	r4, #1
 800182c:	b2e4      	uxtb	r4, r4
 800182e:	e7ef      	b.n	8001810 <receive_loop+0xc0>
        devp->rf_freq_off3 = 0;
 8001830:	2400      	movs	r4, #0
 8001832:	73b4      	strb	r4, [r6, #14]
        devp->rf_freq_off2 = ax5043_read_reg(spip, AX5043_REG_FIFODATA, (uint8_t)0x00, ret_value);
 8001834:	ab01      	add	r3, sp, #4
 8001836:	4622      	mov	r2, r4
 8001838:	2129      	movs	r1, #41	; 0x29
 800183a:	4638      	mov	r0, r7
 800183c:	f7ff fee8 	bl	8001610 <ax5043_read_reg>
 8001840:	7370      	strb	r0, [r6, #13]
        devp->rf_freq_off1 = ax5043_read_reg(spip, AX5043_REG_FIFODATA, (uint8_t)0x00, ret_value);
 8001842:	ab01      	add	r3, sp, #4
 8001844:	4622      	mov	r2, r4
 8001846:	2129      	movs	r1, #41	; 0x29
 8001848:	4638      	mov	r0, r7
 800184a:	f7ff fee1 	bl	8001610 <ax5043_read_reg>
 800184e:	7330      	strb	r0, [r6, #12]
 8001850:	e02a      	b.n	80018a8 <receive_loop+0x158>
      if (chunk_len == 1){
 8001852:	f1ba 0f01 	cmp.w	sl, #1
 8001856:	d00f      	beq.n	8001878 <receive_loop+0x128>
        for(i=0;i<chunk_len;i++){
 8001858:	4554      	cmp	r4, sl
 800185a:	d225      	bcs.n	80018a8 <receive_loop+0x158>
          devp->dropped[i] = ax5043_read_reg(spip, AX5043_REG_FIFODATA, (uint8_t)0x00, ret_value);
 800185c:	ab01      	add	r3, sp, #4
 800185e:	2200      	movs	r2, #0
 8001860:	2129      	movs	r1, #41	; 0x29
 8001862:	4638      	mov	r0, r7
 8001864:	f7ff fed4 	bl	8001610 <ax5043_read_reg>
 8001868:	1933      	adds	r3, r6, r4
 800186a:	7418      	strb	r0, [r3, #16]
          devp->error_code = AXRADIO_ERR_FIFO_CHUNK;
 800186c:	230c      	movs	r3, #12
 800186e:	f886 310a 	strb.w	r3, [r6, #266]	; 0x10a
        for(i=0;i<chunk_len;i++){
 8001872:	3401      	adds	r4, #1
 8001874:	b2e4      	uxtb	r4, r4
 8001876:	e7ef      	b.n	8001858 <receive_loop+0x108>
        devp->rssi = ax5043_read_reg(spip, AX5043_REG_FIFODATA, (uint8_t)0x00, ret_value);
 8001878:	ab01      	add	r3, sp, #4
 800187a:	2200      	movs	r2, #0
 800187c:	2129      	movs	r1, #41	; 0x29
 800187e:	4638      	mov	r0, r7
 8001880:	f7ff fec6 	bl	8001610 <ax5043_read_reg>
 8001884:	73f0      	strb	r0, [r6, #15]
 8001886:	e00f      	b.n	80018a8 <receive_loop+0x158>
      devp->error_code = AXRADIO_ERR_FIFO_CMD;
 8001888:	230d      	movs	r3, #13
 800188a:	f886 310a 	strb.w	r3, [r6, #266]	; 0x10a
      for(i=0;i<chunk_len;i++){
 800188e:	e009      	b.n	80018a4 <receive_loop+0x154>
        devp->dropped[i] = ax5043_read_reg(spip, AX5043_REG_FIFODATA, (uint8_t)0x00, ret_value);
 8001890:	ab01      	add	r3, sp, #4
 8001892:	2200      	movs	r2, #0
 8001894:	2129      	movs	r1, #41	; 0x29
 8001896:	4638      	mov	r0, r7
 8001898:	f7ff feba 	bl	8001610 <ax5043_read_reg>
 800189c:	1933      	adds	r3, r6, r4
 800189e:	7418      	strb	r0, [r3, #16]
      for(i=0;i<chunk_len;i++){
 80018a0:	3401      	adds	r4, #1
 80018a2:	b2e4      	uxtb	r4, r4
 80018a4:	4554      	cmp	r4, sl
 80018a6:	d3f3      	bcc.n	8001890 <receive_loop+0x140>
    devp->state = AX5043_RX;
 80018a8:	2305      	movs	r3, #5
 80018aa:	7133      	strb	r3, [r6, #4]
  while ((ax5043_read_reg(spip, AX5043_REG_FIFOSTAT, (uint8_t)0x00, ret_value) & 0x01) != 1) {   
 80018ac:	ab01      	add	r3, sp, #4
 80018ae:	2200      	movs	r2, #0
 80018b0:	2128      	movs	r1, #40	; 0x28
 80018b2:	4638      	mov	r0, r7
 80018b4:	f7ff feac 	bl	8001610 <ax5043_read_reg>
 80018b8:	f010 0401 	ands.w	r4, r0, #1
 80018bc:	d13a      	bne.n	8001934 <receive_loop+0x1e4>
    fifo_cmd = ax5043_read_reg(spip, AX5043_REG_FIFODATA, (uint8_t)0x00, ret_value); 
 80018be:	ab01      	add	r3, sp, #4
 80018c0:	2200      	movs	r2, #0
 80018c2:	2129      	movs	r1, #41	; 0x29
 80018c4:	4638      	mov	r0, r7
 80018c6:	f7ff fea3 	bl	8001610 <ax5043_read_reg>
 80018ca:	4605      	mov	r5, r0
    chunk_len = (fifo_cmd & 0xE0) >> 5; 
 80018cc:	f3c0 1a47 	ubfx	sl, r0, #5, #8
    if (chunk_len == 7) 
 80018d0:	f1ba 0f07 	cmp.w	sl, #7
 80018d4:	f43f af55 	beq.w	8001782 <receive_loop+0x32>
    fifo_cmd &= 0x1F;
 80018d8:	f005 051f 	and.w	r5, r5, #31
    switch (fifo_cmd) {
 80018dc:	3d01      	subs	r5, #1
 80018de:	2d12      	cmp	r5, #18
 80018e0:	d8d2      	bhi.n	8001888 <receive_loop+0x138>
 80018e2:	a301      	add	r3, pc, #4	; (adr r3, 80018e8 <receive_loop+0x198>)
 80018e4:	f853 f025 	ldr.w	pc, [r3, r5, lsl #2]
 80018e8:	08001793 	.word	0x08001793
 80018ec:	08001889 	.word	0x08001889
 80018f0:	08001889 	.word	0x08001889
 80018f4:	08001889 	.word	0x08001889
 80018f8:	08001889 	.word	0x08001889
 80018fc:	08001889 	.word	0x08001889
 8001900:	08001889 	.word	0x08001889
 8001904:	08001889 	.word	0x08001889
 8001908:	08001889 	.word	0x08001889
 800190c:	08001889 	.word	0x08001889
 8001910:	08001889 	.word	0x08001889
 8001914:	08001889 	.word	0x08001889
 8001918:	08001889 	.word	0x08001889
 800191c:	08001889 	.word	0x08001889
 8001920:	08001889 	.word	0x08001889
 8001924:	08001889 	.word	0x08001889
 8001928:	08001853 	.word	0x08001853
 800192c:	0800180b 	.word	0x0800180b
 8001930:	080017b9 	.word	0x080017b9
}
 8001934:	4640      	mov	r0, r8
 8001936:	b002      	add	sp, #8
 8001938:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800193c:	08003254 	.word	0x08003254

08001940 <ax5043_write_reg>:
uint8_t ax5043_write_reg(SPIDriver * spip, uint16_t reg, uint8_t value, uint8_t ret_value[]){
 8001940:	b530      	push	{r4, r5, lr}
 8001942:	b083      	sub	sp, #12
 8001944:	4604      	mov	r4, r0
 8001946:	461d      	mov	r5, r3
  uint8_t command_buf[3] = {0,0,0};
 8001948:	4b1a      	ldr	r3, [pc, #104]	; (80019b4 <ax5043_write_reg+0x74>)
 800194a:	885b      	ldrh	r3, [r3, #2]
 800194c:	f88d 3006 	strb.w	r3, [sp, #6]
  if(reg <  0x0070){
 8001950:	296f      	cmp	r1, #111	; 0x6f
 8001952:	d816      	bhi.n	8001982 <ax5043_write_reg+0x42>
    command_buf[0]=0x80|reg;
 8001954:	f061 017f 	orn	r1, r1, #127	; 0x7f
 8001958:	f88d 1004 	strb.w	r1, [sp, #4]
    command_buf[1]=value;
 800195c:	f88d 2005 	strb.w	r2, [sp, #5]
    spiSelect(spip);
 8001960:	f7ff fe46 	bl	80015f0 <spiSelect>
    spiStartExchange(spip, 2, command_buf, ret_value);
 8001964:	462b      	mov	r3, r5
 8001966:	aa01      	add	r2, sp, #4
 8001968:	2102      	movs	r1, #2
 800196a:	4620      	mov	r0, r4
 800196c:	f7ff fe20 	bl	80015b0 <spiStartExchange>
    while((*spip).state != SPI_READY) { }
 8001970:	7822      	ldrb	r2, [r4, #0]
 8001972:	2a02      	cmp	r2, #2
 8001974:	d1fc      	bne.n	8001970 <ax5043_write_reg+0x30>
    spiUnselect(spip);
 8001976:	4620      	mov	r0, r4
 8001978:	f7ff fe2a 	bl	80015d0 <spiUnselect>
}
 800197c:	7828      	ldrb	r0, [r5, #0]
 800197e:	b003      	add	sp, #12
 8001980:	bd30      	pop	{r4, r5, pc}
    command_buf[0]=0xF0|(reg>>8);
 8001982:	0a0b      	lsrs	r3, r1, #8
 8001984:	f063 030f 	orn	r3, r3, #15
 8001988:	f88d 3004 	strb.w	r3, [sp, #4]
    command_buf[1]=reg;
 800198c:	f88d 1005 	strb.w	r1, [sp, #5]
    command_buf[2]=value;
 8001990:	f88d 2006 	strb.w	r2, [sp, #6]
    spiSelect(spip);
 8001994:	f7ff fe2c 	bl	80015f0 <spiSelect>
    spiStartExchange(spip, 3, command_buf, ret_value);
 8001998:	462b      	mov	r3, r5
 800199a:	aa01      	add	r2, sp, #4
 800199c:	2103      	movs	r1, #3
 800199e:	4620      	mov	r0, r4
 80019a0:	f7ff fe06 	bl	80015b0 <spiStartExchange>
    while((*spip).state != SPI_READY) { }
 80019a4:	7822      	ldrb	r2, [r4, #0]
 80019a6:	2a02      	cmp	r2, #2
 80019a8:	d1fc      	bne.n	80019a4 <ax5043_write_reg+0x64>
    spiUnselect(spip);
 80019aa:	4620      	mov	r0, r4
 80019ac:	f7ff fe10 	bl	80015d0 <spiUnselect>
 80019b0:	e7e4      	b.n	800197c <ax5043_write_reg+0x3c>
 80019b2:	bf00      	nop
 80019b4:	08003254 	.word	0x08003254
	...

080019c0 <ax5043_init_registers_common>:
void ax5043_init_registers_common(AX5043Driver *devp){
 80019c0:	b570      	push	{r4, r5, r6, lr}
 80019c2:	b082      	sub	sp, #8
 80019c4:	4604      	mov	r4, r0
  uint8_t ret_value[3]={0,0,0};
 80019c6:	4b1d      	ldr	r3, [pc, #116]	; (8001a3c <ax5043_init_registers_common+0x7c>)
 80019c8:	681b      	ldr	r3, [r3, #0]
 80019ca:	f8ad 3004 	strh.w	r3, [sp, #4]
 80019ce:	0c1b      	lsrs	r3, r3, #16
 80019d0:	f88d 3006 	strb.w	r3, [sp, #6]
  SPIDriver *spip = devp->config->spip;
 80019d4:	6883      	ldr	r3, [r0, #8]
 80019d6:	681d      	ldr	r5, [r3, #0]
  uint8_t rng = ax5043_get_conf_val(devp, AXRADIO_PHY_CHANPLLRNG);
 80019d8:	2105      	movs	r1, #5
 80019da:	f7fe fea9 	bl	8000730 <ax5043_get_conf_val>
 80019de:	b2c6      	uxtb	r6, r0
  if (rng & 0x20)
 80019e0:	f010 0f20 	tst.w	r0, #32
 80019e4:	d002      	beq.n	80019ec <ax5043_init_registers_common+0x2c>
    devp->status_code = AXRADIO_ERR_PLLRNG_VAL;
 80019e6:	2312      	movs	r3, #18
 80019e8:	f884 310b 	strb.w	r3, [r4, #267]	; 0x10b
  if ( ax5043_read_reg(spip, AX5043_REG_PLLLOOP, (uint8_t)0x00, ret_value) & 0x80) {
 80019ec:	ab01      	add	r3, sp, #4
 80019ee:	2200      	movs	r2, #0
 80019f0:	2130      	movs	r1, #48	; 0x30
 80019f2:	4628      	mov	r0, r5
 80019f4:	f7ff fe0c 	bl	8001610 <ax5043_read_reg>
 80019f8:	f010 0f80 	tst.w	r0, #128	; 0x80
 80019fc:	d10e      	bne.n	8001a1c <ax5043_init_registers_common+0x5c>
    ax5043_write_reg(spip, AX5043_REG_PLLRANGINGA, (uint8_t)(rng & 0x0F), ret_value);
 80019fe:	ab01      	add	r3, sp, #4
 8001a00:	f006 020f 	and.w	r2, r6, #15
 8001a04:	2133      	movs	r1, #51	; 0x33
 8001a06:	4628      	mov	r0, r5
 8001a08:	f7ff ff9a 	bl	8001940 <ax5043_write_reg>
  rng = axradio_get_pllvcoi(devp);
 8001a0c:	4620      	mov	r0, r4
 8001a0e:	f7ff fe3f 	bl	8001690 <axradio_get_pllvcoi>
  if (rng & 0x80)
 8001a12:	f010 0f80 	tst.w	r0, #128	; 0x80
 8001a16:	d109      	bne.n	8001a2c <ax5043_init_registers_common+0x6c>
}
 8001a18:	b002      	add	sp, #8
 8001a1a:	bd70      	pop	{r4, r5, r6, pc}
    ax5043_write_reg(spip, AX5043_REG_PLLRANGINGB, (uint8_t)(rng & 0x0F), ret_value);
 8001a1c:	ab01      	add	r3, sp, #4
 8001a1e:	f006 020f 	and.w	r2, r6, #15
 8001a22:	213b      	movs	r1, #59	; 0x3b
 8001a24:	4628      	mov	r0, r5
 8001a26:	f7ff ff8b 	bl	8001940 <ax5043_write_reg>
 8001a2a:	e7ef      	b.n	8001a0c <ax5043_init_registers_common+0x4c>
    ax5043_write_reg(spip, AX5043_REG_PLLVCOI, (uint8_t)(rng), ret_value);
 8001a2c:	ab01      	add	r3, sp, #4
 8001a2e:	4602      	mov	r2, r0
 8001a30:	f44f 71c0 	mov.w	r1, #384	; 0x180
 8001a34:	4628      	mov	r0, r5
 8001a36:	f7ff ff83 	bl	8001940 <ax5043_write_reg>
 8001a3a:	e7ed      	b.n	8001a18 <ax5043_init_registers_common+0x58>
 8001a3c:	08003254 	.word	0x08003254

08001a40 <ax5043_set_regs_group>:
uint8_t ax5043_set_regs_group(AX5043Driver *devp, ax5043_reg_group_t group) {
 8001a40:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001a44:	b082      	sub	sp, #8
 8001a46:	4680      	mov	r8, r0
 8001a48:	460f      	mov	r7, r1
  uint8_t rxbuf[3] = {0, 0, 0};
 8001a4a:	4b13      	ldr	r3, [pc, #76]	; (8001a98 <ax5043_set_regs_group+0x58>)
 8001a4c:	681b      	ldr	r3, [r3, #0]
 8001a4e:	f8ad 3004 	strh.w	r3, [sp, #4]
 8001a52:	0c1b      	lsrs	r3, r3, #16
 8001a54:	f88d 3006 	strb.w	r3, [sp, #6]
  ax5043_regval_t* entry = devp->config->reg_values;
 8001a58:	6883      	ldr	r3, [r0, #8]
 8001a5a:	689d      	ldr	r5, [r3, #8]
  int i = 0;
 8001a5c:	2400      	movs	r4, #0
 8001a5e:	e007      	b.n	8001a70 <ax5043_set_regs_group+0x30>
      ax5043_write_reg(devp->config->spip, entry[i].reg, entry[i].val, rxbuf);
 8001a60:	f8d8 6008 	ldr.w	r6, [r8, #8]
 8001a64:	ab01      	add	r3, sp, #4
 8001a66:	7892      	ldrb	r2, [r2, #2]
 8001a68:	6830      	ldr	r0, [r6, #0]
 8001a6a:	f7ff ff69 	bl	8001940 <ax5043_write_reg>
    i++;
 8001a6e:	3401      	adds	r4, #1
  while (entry[i].reg != AX5043_REG_END) {
 8001a70:	eb05 0284 	add.w	r2, r5, r4, lsl #2
 8001a74:	f835 1024 	ldrh.w	r1, [r5, r4, lsl #2]
 8001a78:	f640 73ff 	movw	r3, #4095	; 0xfff
 8001a7c:	4299      	cmp	r1, r3
 8001a7e:	d003      	beq.n	8001a88 <ax5043_set_regs_group+0x48>
    if (entry[i].group == group){
 8001a80:	78d3      	ldrb	r3, [r2, #3]
 8001a82:	42bb      	cmp	r3, r7
 8001a84:	d1f3      	bne.n	8001a6e <ax5043_set_regs_group+0x2e>
 8001a86:	e7eb      	b.n	8001a60 <ax5043_set_regs_group+0x20>
  devp->status_code = rxbuf[0];
 8001a88:	f89d 0004 	ldrb.w	r0, [sp, #4]
 8001a8c:	f888 010b 	strb.w	r0, [r8, #267]	; 0x10b
}
 8001a90:	b002      	add	sp, #8
 8001a92:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001a96:	bf00      	nop
 8001a98:	08003254 	.word	0x08003254
 8001a9c:	00000000 	.word	0x00000000

08001aa0 <ax5043_set_pwrmode>:
uint8_t ax5043_set_pwrmode(AX5043Driver *devp, uint8_t reg_value){
 8001aa0:	b570      	push	{r4, r5, r6, lr}
 8001aa2:	b082      	sub	sp, #8
 8001aa4:	4604      	mov	r4, r0
 8001aa6:	460d      	mov	r5, r1
  uint8_t ret_value[3]={0,0,0};
 8001aa8:	4b0e      	ldr	r3, [pc, #56]	; (8001ae4 <ax5043_set_pwrmode+0x44>)
 8001aaa:	681b      	ldr	r3, [r3, #0]
 8001aac:	f8ad 3004 	strh.w	r3, [sp, #4]
 8001ab0:	0c1b      	lsrs	r3, r3, #16
 8001ab2:	f88d 3006 	strb.w	r3, [sp, #6]
  SPIDriver *spip = devp->config->spip;
 8001ab6:	6883      	ldr	r3, [r0, #8]
 8001ab8:	681e      	ldr	r6, [r3, #0]
  value = ax5043_read_reg(spip, AX5043_REG_PWRMODE, (uint8_t)0x00, ret_value);
 8001aba:	ab01      	add	r3, sp, #4
 8001abc:	2200      	movs	r2, #0
 8001abe:	2102      	movs	r1, #2
 8001ac0:	4630      	mov	r0, r6
 8001ac2:	f7ff fda5 	bl	8001610 <ax5043_read_reg>
  value = value & 0xF0;
 8001ac6:	f000 02f0 	and.w	r2, r0, #240	; 0xf0
  ax5043_write_reg(spip, AX5043_REG_PWRMODE, value, ret_value);
 8001aca:	ab01      	add	r3, sp, #4
 8001acc:	432a      	orrs	r2, r5
 8001ace:	2102      	movs	r1, #2
 8001ad0:	4630      	mov	r0, r6
 8001ad2:	f7ff ff35 	bl	8001940 <ax5043_write_reg>
  devp->status_code = ret_value[0];
 8001ad6:	f89d 0004 	ldrb.w	r0, [sp, #4]
 8001ada:	f884 010b 	strb.w	r0, [r4, #267]	; 0x10b
}
 8001ade:	b002      	add	sp, #8
 8001ae0:	bd70      	pop	{r4, r5, r6, pc}
 8001ae2:	bf00      	nop
 8001ae4:	08003254 	.word	0x08003254
	...

08001af0 <ax5043_prepare_cw>:
uint8_t ax5043_prepare_cw(AX5043Driver *devp){
 8001af0:	b530      	push	{r4, r5, lr}
 8001af2:	b083      	sub	sp, #12
 8001af4:	4605      	mov	r5, r0
  uint8_t ret_value[3]={0,0,0};
 8001af6:	4b32      	ldr	r3, [pc, #200]	; (8001bc0 <ax5043_prepare_cw+0xd0>)
 8001af8:	681b      	ldr	r3, [r3, #0]
 8001afa:	f8ad 3004 	strh.w	r3, [sp, #4]
 8001afe:	0c1b      	lsrs	r3, r3, #16
 8001b00:	f88d 3006 	strb.w	r3, [sp, #6]
  SPIDriver *spip = devp->config->spip;
 8001b04:	6883      	ldr	r3, [r0, #8]
 8001b06:	681c      	ldr	r4, [r3, #0]
  ax5043_write_reg(spip, AX5043_REG_FSKDEV2, (uint8_t)0x00, ret_value);
 8001b08:	ab01      	add	r3, sp, #4
 8001b0a:	2200      	movs	r2, #0
 8001b0c:	f240 1161 	movw	r1, #353	; 0x161
 8001b10:	4620      	mov	r0, r4
 8001b12:	f7ff ff15 	bl	8001940 <ax5043_write_reg>
  ax5043_write_reg(spip, AX5043_REG_FSKDEV1, (uint8_t)0x00, ret_value);
 8001b16:	ab01      	add	r3, sp, #4
 8001b18:	2200      	movs	r2, #0
 8001b1a:	f44f 71b1 	mov.w	r1, #354	; 0x162
 8001b1e:	4620      	mov	r0, r4
 8001b20:	f7ff ff0e 	bl	8001940 <ax5043_write_reg>
  ax5043_write_reg(spip, AX5043_REG_FSKDEV0, (uint8_t)0x00, ret_value);
 8001b24:	ab01      	add	r3, sp, #4
 8001b26:	2200      	movs	r2, #0
 8001b28:	f240 1163 	movw	r1, #355	; 0x163
 8001b2c:	4620      	mov	r0, r4
 8001b2e:	f7ff ff07 	bl	8001940 <ax5043_write_reg>
  ax5043_write_reg(spip, AX5043_REG_TXRATE2, (uint8_t)0x00, ret_value);
 8001b32:	ab01      	add	r3, sp, #4
 8001b34:	2200      	movs	r2, #0
 8001b36:	f240 1165 	movw	r1, #357	; 0x165
 8001b3a:	4620      	mov	r0, r4
 8001b3c:	f7ff ff00 	bl	8001940 <ax5043_write_reg>
  ax5043_write_reg(spip, AX5043_REG_TXRATE1, (uint8_t)0x00, ret_value);
 8001b40:	ab01      	add	r3, sp, #4
 8001b42:	2200      	movs	r2, #0
 8001b44:	f44f 71b3 	mov.w	r1, #358	; 0x166
 8001b48:	4620      	mov	r0, r4
 8001b4a:	f7ff fef9 	bl	8001940 <ax5043_write_reg>
  ax5043_write_reg(spip, AX5043_REG_TXRATE0, (uint8_t)0x01, ret_value);
 8001b4e:	ab01      	add	r3, sp, #4
 8001b50:	2201      	movs	r2, #1
 8001b52:	f240 1167 	movw	r1, #359	; 0x167
 8001b56:	4620      	mov	r0, r4
 8001b58:	f7ff fef2 	bl	8001940 <ax5043_write_reg>
  ax5043_set_pwrmode(devp, AX5043_FULL_TX);
 8001b5c:	210d      	movs	r1, #13
 8001b5e:	4628      	mov	r0, r5
 8001b60:	f7ff ff9e 	bl	8001aa0 <ax5043_set_pwrmode>
  ax5043_write_reg(spip, AX5043_REG_FIFOSTAT, (uint8_t)0x03, ret_value);
 8001b64:	ab01      	add	r3, sp, #4
 8001b66:	2203      	movs	r2, #3
 8001b68:	2128      	movs	r1, #40	; 0x28
 8001b6a:	4620      	mov	r0, r4
 8001b6c:	f7ff fee8 	bl	8001940 <ax5043_write_reg>
  ax5043_write_reg(spip, AX5043_REG_FIFODATA, (uint8_t)(AX5043_FIFOCMD_REPEATDATA|0x60), ret_value);
 8001b70:	ab01      	add	r3, sp, #4
 8001b72:	2262      	movs	r2, #98	; 0x62
 8001b74:	2129      	movs	r1, #41	; 0x29
 8001b76:	4620      	mov	r0, r4
 8001b78:	f7ff fee2 	bl	8001940 <ax5043_write_reg>
  ax5043_write_reg(spip, AX5043_REG_FIFODATA, (uint8_t)0x38, ret_value);
 8001b7c:	ab01      	add	r3, sp, #4
 8001b7e:	2238      	movs	r2, #56	; 0x38
 8001b80:	2129      	movs	r1, #41	; 0x29
 8001b82:	4620      	mov	r0, r4
 8001b84:	f7ff fedc 	bl	8001940 <ax5043_write_reg>
  ax5043_write_reg(spip, AX5043_REG_FIFODATA, (uint8_t)0xff, ret_value);
 8001b88:	ab01      	add	r3, sp, #4
 8001b8a:	22ff      	movs	r2, #255	; 0xff
 8001b8c:	2129      	movs	r1, #41	; 0x29
 8001b8e:	4620      	mov	r0, r4
 8001b90:	f7ff fed6 	bl	8001940 <ax5043_write_reg>
  ax5043_write_reg(spip, AX5043_REG_FIFODATA, (uint8_t)0x55, ret_value);
 8001b94:	ab01      	add	r3, sp, #4
 8001b96:	2255      	movs	r2, #85	; 0x55
 8001b98:	2129      	movs	r1, #41	; 0x29
 8001b9a:	4620      	mov	r0, r4
 8001b9c:	f7ff fed0 	bl	8001940 <ax5043_write_reg>
  ax5043_write_reg(spip, AX5043_REG_FIFOSTAT, (uint8_t)0x04, ret_value); 
 8001ba0:	ab01      	add	r3, sp, #4
 8001ba2:	2204      	movs	r2, #4
 8001ba4:	2128      	movs	r1, #40	; 0x28
 8001ba6:	4620      	mov	r0, r4
 8001ba8:	f7ff feca 	bl	8001940 <ax5043_write_reg>
  ax5043_set_pwrmode(devp, AX5043_STANDBY);
 8001bac:	2105      	movs	r1, #5
 8001bae:	4628      	mov	r0, r5
 8001bb0:	f7ff ff76 	bl	8001aa0 <ax5043_set_pwrmode>
  devp->state = AX5043_CW;
 8001bb4:	230d      	movs	r3, #13
 8001bb6:	712b      	strb	r3, [r5, #4]
}
 8001bb8:	2000      	movs	r0, #0
 8001bba:	b003      	add	sp, #12
 8001bbc:	bd30      	pop	{r4, r5, pc}
 8001bbe:	bf00      	nop
 8001bc0:	08003254 	.word	0x08003254
	...

08001bd0 <ax5043_prepare_rx>:
void ax5043_prepare_rx(AX5043Driver *devp){
 8001bd0:	b530      	push	{r4, r5, lr}
 8001bd2:	b083      	sub	sp, #12
 8001bd4:	4604      	mov	r4, r0
  uint8_t ret_value[3]={0,0,0};
 8001bd6:	4b24      	ldr	r3, [pc, #144]	; (8001c68 <ax5043_prepare_rx+0x98>)
 8001bd8:	681b      	ldr	r3, [r3, #0]
 8001bda:	f8ad 3004 	strh.w	r3, [sp, #4]
 8001bde:	0c1b      	lsrs	r3, r3, #16
 8001be0:	f88d 3006 	strb.w	r3, [sp, #6]
  SPIDriver *spip = devp->config->spip;
 8001be4:	6883      	ldr	r3, [r0, #8]
 8001be6:	681d      	ldr	r5, [r3, #0]
  ax5043_set_regs_group(devp,rx);
 8001be8:	2102      	movs	r1, #2
 8001bea:	f7ff ff29 	bl	8001a40 <ax5043_set_regs_group>
  ax5043_init_registers_common(devp);
 8001bee:	4620      	mov	r0, r4
 8001bf0:	f7ff fee6 	bl	80019c0 <ax5043_init_registers_common>
  uint8_t rssireference = ax5043_get_conf_val(devp, AXRADIO_PHY_RSSIREFERENCE) ;
 8001bf4:	210a      	movs	r1, #10
 8001bf6:	4620      	mov	r0, r4
 8001bf8:	f7fe fd9a 	bl	8000730 <ax5043_get_conf_val>
  ax5043_write_reg(spip, AX5043_REG_RSSIREFERENCE, rssireference, ret_value);
 8001bfc:	ab01      	add	r3, sp, #4
 8001bfe:	b2c2      	uxtb	r2, r0
 8001c00:	f44f 710b 	mov.w	r1, #556	; 0x22c
 8001c04:	4628      	mov	r0, r5
 8001c06:	f7ff fe9b 	bl	8001940 <ax5043_write_reg>
  ax5043_set_regs_group(devp,rx_cont);
 8001c0a:	2103      	movs	r1, #3
 8001c0c:	4620      	mov	r0, r4
 8001c0e:	f7ff ff17 	bl	8001a40 <ax5043_set_regs_group>
  ax5043_write_reg(spip, AX5043_REG_FIFOSTAT, (uint8_t)0x03, ret_value);
 8001c12:	ab01      	add	r3, sp, #4
 8001c14:	2203      	movs	r2, #3
 8001c16:	2128      	movs	r1, #40	; 0x28
 8001c18:	4628      	mov	r0, r5
 8001c1a:	f7ff fe91 	bl	8001940 <ax5043_write_reg>
  ax5043_set_pwrmode(devp, AX5043_FULL_RX);  
 8001c1e:	2109      	movs	r1, #9
 8001c20:	4620      	mov	r0, r4
 8001c22:	f7ff ff3d 	bl	8001aa0 <ax5043_set_pwrmode>
  ax5043_write_reg(spip, AX5043_REG_FIFOTHRESH1, (uint8_t)0x00, ret_value);
 8001c26:	ab01      	add	r3, sp, #4
 8001c28:	2200      	movs	r2, #0
 8001c2a:	212e      	movs	r1, #46	; 0x2e
 8001c2c:	4628      	mov	r0, r5
 8001c2e:	f7ff fe87 	bl	8001940 <ax5043_write_reg>
  ax5043_write_reg(spip, AX5043_REG_FIFOTHRESH0, (uint8_t)0x80, ret_value);
 8001c32:	ab01      	add	r3, sp, #4
 8001c34:	2280      	movs	r2, #128	; 0x80
 8001c36:	212f      	movs	r1, #47	; 0x2f
 8001c38:	4628      	mov	r0, r5
 8001c3a:	f7ff fe81 	bl	8001940 <ax5043_write_reg>
  ax5043_write_reg(spip, AX5043_REG_IRQMASK0, (uint8_t)0x01, ret_value);
 8001c3e:	ab01      	add	r3, sp, #4
 8001c40:	2201      	movs	r2, #1
 8001c42:	2107      	movs	r1, #7
 8001c44:	4628      	mov	r0, r5
 8001c46:	f7ff fe7b 	bl	8001940 <ax5043_write_reg>
  ax5043_write_reg(spip, AX5043_REG_IRQMASK1, (uint8_t)0x00, ret_value);
 8001c4a:	ab01      	add	r3, sp, #4
 8001c4c:	2200      	movs	r2, #0
 8001c4e:	2106      	movs	r1, #6
 8001c50:	4628      	mov	r0, r5
 8001c52:	f7ff fe75 	bl	8001940 <ax5043_write_reg>
  devp->status_code = ret_value[0];
 8001c56:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8001c5a:	f884 310b 	strb.w	r3, [r4, #267]	; 0x10b
  devp->state = AX5043_RX;
 8001c5e:	2305      	movs	r3, #5
 8001c60:	7123      	strb	r3, [r4, #4]
}
 8001c62:	b003      	add	sp, #12
 8001c64:	bd30      	pop	{r4, r5, pc}
 8001c66:	bf00      	nop
 8001c68:	08003254 	.word	0x08003254
 8001c6c:	00000000 	.word	0x00000000

08001c70 <spiStart>:
void spiStart(SPIDriver *spip, const SPIConfig *config) {
 8001c70:	b510      	push	{r4, lr}
 8001c72:	4604      	mov	r4, r0
 8001c74:	2320      	movs	r3, #32
 8001c76:	f383 8811 	msr	BASEPRI, r3
  spip->config = config;
 8001c7a:	6041      	str	r1, [r0, #4]
  spi_lld_start(spip);
 8001c7c:	f7ff fba8 	bl	80013d0 <spi_lld_start>
  spip->state = SPI_READY;
 8001c80:	2302      	movs	r3, #2
 8001c82:	7023      	strb	r3, [r4, #0]
 8001c84:	2300      	movs	r3, #0
 8001c86:	f383 8811 	msr	BASEPRI, r3
}
 8001c8a:	bd10      	pop	{r4, pc}
 8001c8c:	0000      	movs	r0, r0
	...

08001c90 <spiObjectInit>:
void spiObjectInit(SPIDriver *spip) {
 8001c90:	b508      	push	{r3, lr}
  spip->state = SPI_STOP;
 8001c92:	2301      	movs	r3, #1
 8001c94:	7003      	strb	r3, [r0, #0]
  spip->config = NULL;
 8001c96:	2300      	movs	r3, #0
 8001c98:	6043      	str	r3, [r0, #4]
  spip->thread = NULL;
 8001c9a:	6083      	str	r3, [r0, #8]
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxObjectInit(mp);
 8001c9c:	300c      	adds	r0, #12
 8001c9e:	f7fe fde7 	bl	8000870 <chMtxObjectInit>
}
 8001ca2:	bd08      	pop	{r3, pc}
	...

08001cb0 <spi_lld_init>:
void spi_lld_init(void) {
 8001cb0:	b538      	push	{r3, r4, r5, lr}
  spiObjectInit(&SPID1);
 8001cb2:	4c0d      	ldr	r4, [pc, #52]	; (8001ce8 <spi_lld_init+0x38>)
 8001cb4:	4620      	mov	r0, r4
 8001cb6:	f7ff ffeb 	bl	8001c90 <spiObjectInit>
  SPID1.spi       = SPI1;
 8001cba:	4b0c      	ldr	r3, [pc, #48]	; (8001cec <spi_lld_init+0x3c>)
 8001cbc:	61e3      	str	r3, [r4, #28]
  SPID1.dmarx     = NULL;
 8001cbe:	2500      	movs	r5, #0
 8001cc0:	6225      	str	r5, [r4, #32]
  SPID1.dmatx     = NULL;
 8001cc2:	6265      	str	r5, [r4, #36]	; 0x24
  SPID1.rxdmamode = STM32_DMA_CR_CHSEL(SPI1_RX_DMA_CHANNEL) |
 8001cc4:	4b0a      	ldr	r3, [pc, #40]	; (8001cf0 <spi_lld_init+0x40>)
 8001cc6:	62a3      	str	r3, [r4, #40]	; 0x28
  SPID1.txdmamode = STM32_DMA_CR_CHSEL(SPI1_TX_DMA_CHANNEL) |
 8001cc8:	3330      	adds	r3, #48	; 0x30
 8001cca:	62e3      	str	r3, [r4, #44]	; 0x2c
  spiObjectInit(&SPID2);
 8001ccc:	4c09      	ldr	r4, [pc, #36]	; (8001cf4 <spi_lld_init+0x44>)
 8001cce:	4620      	mov	r0, r4
 8001cd0:	f7ff ffde 	bl	8001c90 <spiObjectInit>
  SPID2.spi       = SPI2;
 8001cd4:	4b08      	ldr	r3, [pc, #32]	; (8001cf8 <spi_lld_init+0x48>)
 8001cd6:	61e3      	str	r3, [r4, #28]
  SPID2.dmarx     = NULL;
 8001cd8:	6225      	str	r5, [r4, #32]
  SPID2.dmatx     = NULL;
 8001cda:	6265      	str	r5, [r4, #36]	; 0x24
  SPID2.rxdmamode = STM32_DMA_CR_CHSEL(SPI2_RX_DMA_CHANNEL) |
 8001cdc:	4b07      	ldr	r3, [pc, #28]	; (8001cfc <spi_lld_init+0x4c>)
 8001cde:	62a3      	str	r3, [r4, #40]	; 0x28
  SPID2.txdmamode = STM32_DMA_CR_CHSEL(SPI2_TX_DMA_CHANNEL) |
 8001ce0:	3330      	adds	r3, #48	; 0x30
 8001ce2:	62e3      	str	r3, [r4, #44]	; 0x2c
}
 8001ce4:	bd38      	pop	{r3, r4, r5, pc}
 8001ce6:	bf00      	nop
 8001ce8:	20000c7c 	.word	0x20000c7c
 8001cec:	40013000 	.word	0x40013000
 8001cf0:	06010016 	.word	0x06010016
 8001cf4:	20000cac 	.word	0x20000cac
 8001cf8:	40003800 	.word	0x40003800
 8001cfc:	00010016 	.word	0x00010016

08001d00 <spiInit>:
void spiInit(void) {
 8001d00:	b508      	push	{r3, lr}
  spi_lld_init();
 8001d02:	f7ff ffd5 	bl	8001cb0 <spi_lld_init>
}
 8001d06:	bd08      	pop	{r3, pc}
	...

08001d10 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
 8001d10:	b510      	push	{r4, lr}
 8001d12:	4604      	mov	r4, r0
 8001d14:	2320      	movs	r3, #32
 8001d16:	f383 8811 	msr	BASEPRI, r3
  osalDbgCheck(sdp != NULL);

  osalSysLock();
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
 8001d1a:	f7ff fa99 	bl	8001250 <sd_lld_start>
  sdp->state = SD_READY;
 8001d1e:	2302      	movs	r3, #2
 8001d20:	7223      	strb	r3, [r4, #8]
 8001d22:	2300      	movs	r3, #0
 8001d24:	f383 8811 	msr	BASEPRI, r3
  osalSysUnlock();
}
 8001d28:	bd10      	pop	{r4, pc}
 8001d2a:	bf00      	nop
 8001d2c:	0000      	movs	r0, r0
	...

08001d30 <_ctl>:
}
 8001d30:	2000      	movs	r0, #0
 8001d32:	4770      	bx	lr
	...

08001d40 <oqGetI>:
msg_t oqGetI(output_queue_t *oqp) {

  osalDbgCheckClassI();

  /* Queue data check.*/
  if (!oqIsEmptyI(oqp)) {
 8001d40:	6983      	ldr	r3, [r0, #24]
 8001d42:	6942      	ldr	r2, [r0, #20]
 8001d44:	429a      	cmp	r2, r3
 8001d46:	d012      	beq.n	8001d6e <oqGetI+0x2e>
 8001d48:	2200      	movs	r2, #0
 8001d4a:	b9aa      	cbnz	r2, 8001d78 <oqGetI+0x38>
msg_t oqGetI(output_queue_t *oqp) {
 8001d4c:	b510      	push	{r4, lr}
    uint8_t b;

    oqp->q_counter++;
 8001d4e:	6882      	ldr	r2, [r0, #8]
 8001d50:	3201      	adds	r2, #1
 8001d52:	6082      	str	r2, [r0, #8]
    b = *oqp->q_rdptr++;
 8001d54:	1c5a      	adds	r2, r3, #1
 8001d56:	6182      	str	r2, [r0, #24]
 8001d58:	781c      	ldrb	r4, [r3, #0]
    if (oqp->q_rdptr >= oqp->q_top) {
 8001d5a:	6903      	ldr	r3, [r0, #16]
 8001d5c:	429a      	cmp	r2, r3
 8001d5e:	d301      	bcc.n	8001d64 <oqGetI+0x24>
      oqp->q_rdptr = oqp->q_buffer;
 8001d60:	68c3      	ldr	r3, [r0, #12]
 8001d62:	6183      	str	r3, [r0, #24]
  chThdDequeueNextI(tqp, msg);
 8001d64:	2100      	movs	r1, #0
 8001d66:	f7fe ff0b 	bl	8000b80 <chThdDequeueNextI>
    }

    osalThreadDequeueNextI(&oqp->q_waiting, MSG_OK);

    return (msg_t)b;
 8001d6a:	4620      	mov	r0, r4
  }

  return MSG_TIMEOUT;
}
 8001d6c:	bd10      	pop	{r4, pc}
  if (!oqIsEmptyI(oqp)) {
 8001d6e:	6882      	ldr	r2, [r0, #8]
 8001d70:	2a00      	cmp	r2, #0
 8001d72:	d0ea      	beq.n	8001d4a <oqGetI+0xa>
 8001d74:	2201      	movs	r2, #1
 8001d76:	e7e8      	b.n	8001d4a <oqGetI+0xa>
  return MSG_TIMEOUT;
 8001d78:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 8001d7c:	4770      	bx	lr
 8001d7e:	bf00      	nop

08001d80 <oqObjectInit>:
  tqp->next = (thread_t *)tqp;
 8001d80:	6000      	str	r0, [r0, #0]
  tqp->prev = (thread_t *)tqp;
 8001d82:	6040      	str	r0, [r0, #4]
  oqp->q_counter = size;
 8001d84:	6082      	str	r2, [r0, #8]
  oqp->q_buffer  = bp;
 8001d86:	60c1      	str	r1, [r0, #12]
  oqp->q_rdptr   = bp;
 8001d88:	6181      	str	r1, [r0, #24]
  oqp->q_wrptr   = bp;
 8001d8a:	6141      	str	r1, [r0, #20]
  oqp->q_top     = bp + size;
 8001d8c:	4411      	add	r1, r2
 8001d8e:	6101      	str	r1, [r0, #16]
  oqp->q_notify  = onfy;
 8001d90:	61c3      	str	r3, [r0, #28]
  oqp->q_link    = link;
 8001d92:	9b00      	ldr	r3, [sp, #0]
 8001d94:	6203      	str	r3, [r0, #32]
}
 8001d96:	4770      	bx	lr
	...

08001da0 <iqPutI>:
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {
 8001da0:	b508      	push	{r3, lr}
  if (!iqIsFullI(iqp)) {
 8001da2:	6943      	ldr	r3, [r0, #20]
 8001da4:	6982      	ldr	r2, [r0, #24]
 8001da6:	4293      	cmp	r3, r2
 8001da8:	d012      	beq.n	8001dd0 <iqPutI+0x30>
 8001daa:	2200      	movs	r2, #0
 8001dac:	b9aa      	cbnz	r2, 8001dda <iqPutI+0x3a>
    iqp->q_counter++;
 8001dae:	6882      	ldr	r2, [r0, #8]
 8001db0:	3201      	adds	r2, #1
 8001db2:	6082      	str	r2, [r0, #8]
    *iqp->q_wrptr++ = b;
 8001db4:	1c5a      	adds	r2, r3, #1
 8001db6:	6142      	str	r2, [r0, #20]
 8001db8:	7019      	strb	r1, [r3, #0]
    if (iqp->q_wrptr >= iqp->q_top) {
 8001dba:	6942      	ldr	r2, [r0, #20]
 8001dbc:	6903      	ldr	r3, [r0, #16]
 8001dbe:	429a      	cmp	r2, r3
 8001dc0:	d301      	bcc.n	8001dc6 <iqPutI+0x26>
      iqp->q_wrptr = iqp->q_buffer;
 8001dc2:	68c3      	ldr	r3, [r0, #12]
 8001dc4:	6143      	str	r3, [r0, #20]
 8001dc6:	2100      	movs	r1, #0
 8001dc8:	f7fe feda 	bl	8000b80 <chThdDequeueNextI>
    return MSG_OK;
 8001dcc:	2000      	movs	r0, #0
}
 8001dce:	bd08      	pop	{r3, pc}
  if (!iqIsFullI(iqp)) {
 8001dd0:	6882      	ldr	r2, [r0, #8]
 8001dd2:	2a00      	cmp	r2, #0
 8001dd4:	d0ea      	beq.n	8001dac <iqPutI+0xc>
 8001dd6:	2201      	movs	r2, #1
 8001dd8:	e7e8      	b.n	8001dac <iqPutI+0xc>
  return MSG_TIMEOUT;
 8001dda:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8001dde:	e7f6      	b.n	8001dce <iqPutI+0x2e>

08001de0 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
 8001de0:	b538      	push	{r3, r4, r5, lr}
 8001de2:	4604      	mov	r4, r0
 8001de4:	460d      	mov	r5, r1

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 8001de6:	6943      	ldr	r3, [r0, #20]
 8001de8:	b13b      	cbz	r3, 8001dfa <sdIncomingDataI+0x1a>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
 8001dea:	4629      	mov	r1, r5
 8001dec:	f104 000c 	add.w	r0, r4, #12
 8001df0:	f7ff ffd6 	bl	8001da0 <iqPutI>
 8001df4:	2800      	cmp	r0, #0
 8001df6:	db05      	blt.n	8001e04 <sdIncomingDataI+0x24>
    chnAddFlagsI(sdp, SD_QUEUE_FULL_ERROR);
}
 8001df8:	bd38      	pop	{r3, r4, r5, pc}
  chEvtBroadcastFlagsI(esp, flags);
 8001dfa:	2104      	movs	r1, #4
 8001dfc:	4408      	add	r0, r1
 8001dfe:	f7fe fe97 	bl	8000b30 <chEvtBroadcastFlagsI>
 8001e02:	e7f2      	b.n	8001dea <sdIncomingDataI+0xa>
 8001e04:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8001e08:	1d20      	adds	r0, r4, #4
 8001e0a:	f7fe fe91 	bl	8000b30 <chEvtBroadcastFlagsI>
    chnAddFlagsI(sdp, SD_QUEUE_FULL_ERROR);
 8001e0e:	e7f3      	b.n	8001df8 <sdIncomingDataI+0x18>

08001e10 <serve_interrupt>:
static void serve_interrupt(SerialDriver *sdp) {
 8001e10:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001e12:	4606      	mov	r6, r0
  USART_TypeDef *u = sdp->usart;
 8001e14:	6f45      	ldr	r5, [r0, #116]	; 0x74
  uint16_t cr1 = u->CR1;
 8001e16:	68ef      	ldr	r7, [r5, #12]
  uint16_t sr = u->SR;
 8001e18:	682b      	ldr	r3, [r5, #0]
 8001e1a:	b29c      	uxth	r4, r3
  if (sr & USART_SR_LBD) {
 8001e1c:	f413 7f80 	tst.w	r3, #256	; 0x100
 8001e20:	d103      	bne.n	8001e2a <serve_interrupt+0x1a>
 8001e22:	2320      	movs	r3, #32
 8001e24:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8001e28:	e018      	b.n	8001e5c <serve_interrupt+0x4c>
 8001e2a:	2320      	movs	r3, #32
 8001e2c:	f383 8811 	msr	BASEPRI, r3
 8001e30:	f44f 7100 	mov.w	r1, #512	; 0x200
 8001e34:	3004      	adds	r0, #4
 8001e36:	f7fe fe7b 	bl	8000b30 <chEvtBroadcastFlagsI>
    u->SR = ~USART_SR_LBD;
 8001e3a:	f46f 7380 	mvn.w	r3, #256	; 0x100
 8001e3e:	602b      	str	r3, [r5, #0]
 8001e40:	2300      	movs	r3, #0
 8001e42:	f383 8811 	msr	BASEPRI, r3
 8001e46:	e7ec      	b.n	8001e22 <serve_interrupt+0x12>
      set_error(sdp, sr);
 8001e48:	4621      	mov	r1, r4
 8001e4a:	4630      	mov	r0, r6
 8001e4c:	f7fe ff80 	bl	8000d50 <set_error>
 8001e50:	e00a      	b.n	8001e68 <serve_interrupt+0x58>
      sdIncomingDataI(sdp, b);
 8001e52:	4630      	mov	r0, r6
 8001e54:	f7ff ffc4 	bl	8001de0 <sdIncomingDataI>
    sr = u->SR;
 8001e58:	682c      	ldr	r4, [r5, #0]
 8001e5a:	b2a4      	uxth	r4, r4
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 8001e5c:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 8001e60:	d00a      	beq.n	8001e78 <serve_interrupt+0x68>
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
 8001e62:	f014 0f0f 	tst.w	r4, #15
 8001e66:	d1ef      	bne.n	8001e48 <serve_interrupt+0x38>
    b = (uint8_t)u->DR & sdp->rxmask;
 8001e68:	6869      	ldr	r1, [r5, #4]
 8001e6a:	f896 3078 	ldrb.w	r3, [r6, #120]	; 0x78
 8001e6e:	4019      	ands	r1, r3
    if (sr & USART_SR_RXNE)
 8001e70:	f014 0f20 	tst.w	r4, #32
 8001e74:	d0f0      	beq.n	8001e58 <serve_interrupt+0x48>
 8001e76:	e7ec      	b.n	8001e52 <serve_interrupt+0x42>
 8001e78:	2300      	movs	r3, #0
 8001e7a:	f383 8811 	msr	BASEPRI, r3
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
 8001e7e:	f017 0f80 	tst.w	r7, #128	; 0x80
 8001e82:	d002      	beq.n	8001e8a <serve_interrupt+0x7a>
 8001e84:	f014 0f80 	tst.w	r4, #128	; 0x80
 8001e88:	d112      	bne.n	8001eb0 <serve_interrupt+0xa0>
  if ((cr1 & USART_CR1_TCIE) && (sr & USART_SR_TC)) {
 8001e8a:	f017 0f40 	tst.w	r7, #64	; 0x40
 8001e8e:	d00e      	beq.n	8001eae <serve_interrupt+0x9e>
 8001e90:	f014 0f40 	tst.w	r4, #64	; 0x40
 8001e94:	d00b      	beq.n	8001eae <serve_interrupt+0x9e>
 8001e96:	2320      	movs	r3, #32
 8001e98:	f383 8811 	msr	BASEPRI, r3
    if (oqIsEmptyI(&sdp->oqueue)) {
 8001e9c:	6c72      	ldr	r2, [r6, #68]	; 0x44
 8001e9e:	6cb3      	ldr	r3, [r6, #72]	; 0x48
 8001ea0:	429a      	cmp	r2, r3
 8001ea2:	d01c      	beq.n	8001ede <serve_interrupt+0xce>
 8001ea4:	2300      	movs	r3, #0
 8001ea6:	b9fb      	cbnz	r3, 8001ee8 <serve_interrupt+0xd8>
 8001ea8:	2300      	movs	r3, #0
 8001eaa:	f383 8811 	msr	BASEPRI, r3
}
 8001eae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001eb0:	2320      	movs	r3, #32
 8001eb2:	f383 8811 	msr	BASEPRI, r3
    b = oqGetI(&sdp->oqueue);
 8001eb6:	f106 0030 	add.w	r0, r6, #48	; 0x30
 8001eba:	f7ff ff41 	bl	8001d40 <oqGetI>
    if (b < MSG_OK) {
 8001ebe:	2800      	cmp	r0, #0
 8001ec0:	db04      	blt.n	8001ecc <serve_interrupt+0xbc>
      u->DR = b;
 8001ec2:	6068      	str	r0, [r5, #4]
 8001ec4:	2300      	movs	r3, #0
 8001ec6:	f383 8811 	msr	BASEPRI, r3
 8001eca:	e7de      	b.n	8001e8a <serve_interrupt+0x7a>
 8001ecc:	2108      	movs	r1, #8
 8001ece:	1d30      	adds	r0, r6, #4
 8001ed0:	f7fe fe2e 	bl	8000b30 <chEvtBroadcastFlagsI>
      u->CR1 = cr1 & ~USART_CR1_TXEIE;
 8001ed4:	f64f 737f 	movw	r3, #65407	; 0xff7f
 8001ed8:	403b      	ands	r3, r7
 8001eda:	60eb      	str	r3, [r5, #12]
 8001edc:	e7f2      	b.n	8001ec4 <serve_interrupt+0xb4>
    if (oqIsEmptyI(&sdp->oqueue)) {
 8001ede:	6bb3      	ldr	r3, [r6, #56]	; 0x38
 8001ee0:	2b00      	cmp	r3, #0
 8001ee2:	d0e0      	beq.n	8001ea6 <serve_interrupt+0x96>
 8001ee4:	2301      	movs	r3, #1
 8001ee6:	e7de      	b.n	8001ea6 <serve_interrupt+0x96>
 8001ee8:	2110      	movs	r1, #16
 8001eea:	1d30      	adds	r0, r6, #4
 8001eec:	f7fe fe20 	bl	8000b30 <chEvtBroadcastFlagsI>
      u->CR1 = cr1 & ~USART_CR1_TCIE;
 8001ef0:	f027 0740 	bic.w	r7, r7, #64	; 0x40
 8001ef4:	043f      	lsls	r7, r7, #16
 8001ef6:	0c3f      	lsrs	r7, r7, #16
 8001ef8:	60ef      	str	r7, [r5, #12]
 8001efa:	e7d5      	b.n	8001ea8 <serve_interrupt+0x98>
 8001efc:	0000      	movs	r0, r0
	...

08001f00 <iqObjectInit>:
                  qnotify_t infy, void *link) {
 8001f00:	b410      	push	{r4}
  tqp->next = (thread_t *)tqp;
 8001f02:	6000      	str	r0, [r0, #0]
  tqp->prev = (thread_t *)tqp;
 8001f04:	6040      	str	r0, [r0, #4]
  iqp->q_counter = 0;
 8001f06:	2400      	movs	r4, #0
 8001f08:	6084      	str	r4, [r0, #8]
  iqp->q_buffer  = bp;
 8001f0a:	60c1      	str	r1, [r0, #12]
  iqp->q_rdptr   = bp;
 8001f0c:	6181      	str	r1, [r0, #24]
  iqp->q_wrptr   = bp;
 8001f0e:	6141      	str	r1, [r0, #20]
  iqp->q_top     = bp + size;
 8001f10:	4411      	add	r1, r2
 8001f12:	6101      	str	r1, [r0, #16]
  iqp->q_notify  = infy;
 8001f14:	61c3      	str	r3, [r0, #28]
  iqp->q_link    = link;
 8001f16:	9b01      	ldr	r3, [sp, #4]
 8001f18:	6203      	str	r3, [r0, #32]
}
 8001f1a:	bc10      	pop	{r4}
 8001f1c:	4770      	bx	lr
 8001f1e:	bf00      	nop

08001f20 <sdObjectInit>:
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 8001f20:	b530      	push	{r4, r5, lr}
 8001f22:	b083      	sub	sp, #12
 8001f24:	4604      	mov	r4, r0
 8001f26:	460b      	mov	r3, r1
 8001f28:	4615      	mov	r5, r2
  sdp->vmt = &vmt;
 8001f2a:	4602      	mov	r2, r0
 8001f2c:	490b      	ldr	r1, [pc, #44]	; (8001f5c <sdObjectInit+0x3c>)
 8001f2e:	f842 1b04 	str.w	r1, [r2], #4
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->next = (event_listener_t *)esp;
 8001f32:	6042      	str	r2, [r0, #4]
  sdp->state = SD_STOP;
 8001f34:	2201      	movs	r2, #1
 8001f36:	7202      	strb	r2, [r0, #8]
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 8001f38:	9000      	str	r0, [sp, #0]
 8001f3a:	2210      	movs	r2, #16
 8001f3c:	f100 0154 	add.w	r1, r0, #84	; 0x54
 8001f40:	300c      	adds	r0, #12
 8001f42:	f7ff ffdd 	bl	8001f00 <iqObjectInit>
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
 8001f46:	9400      	str	r4, [sp, #0]
 8001f48:	462b      	mov	r3, r5
 8001f4a:	2210      	movs	r2, #16
 8001f4c:	f104 0164 	add.w	r1, r4, #100	; 0x64
 8001f50:	f104 0030 	add.w	r0, r4, #48	; 0x30
 8001f54:	f7ff ff14 	bl	8001d80 <oqObjectInit>
}
 8001f58:	b003      	add	sp, #12
 8001f5a:	bd30      	pop	{r4, r5, pc}
 8001f5c:	08003558 	.word	0x08003558

08001f60 <sd_lld_init>:
void sd_lld_init(void) {
 8001f60:	b510      	push	{r4, lr}
  sdObjectInit(&SD2, NULL, notify2);
 8001f62:	4c04      	ldr	r4, [pc, #16]	; (8001f74 <sd_lld_init+0x14>)
 8001f64:	4a04      	ldr	r2, [pc, #16]	; (8001f78 <sd_lld_init+0x18>)
 8001f66:	2100      	movs	r1, #0
 8001f68:	4620      	mov	r0, r4
 8001f6a:	f7ff ffd9 	bl	8001f20 <sdObjectInit>
  SD2.usart = USART2;
 8001f6e:	4b03      	ldr	r3, [pc, #12]	; (8001f7c <sd_lld_init+0x1c>)
 8001f70:	6763      	str	r3, [r4, #116]	; 0x74
}
 8001f72:	bd10      	pop	{r4, pc}
 8001f74:	20000c00 	.word	0x20000c00
 8001f78:	08000d41 	.word	0x08000d41
 8001f7c:	40004400 	.word	0x40004400

08001f80 <sdInit>:
void sdInit(void) {
 8001f80:	b508      	push	{r3, lr}
  sd_lld_init();
 8001f82:	f7ff ffed 	bl	8001f60 <sd_lld_init>
}
 8001f86:	bd08      	pop	{r3, pc}
	...

08001f90 <stGetCounter>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8001f90:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001f94:	6a58      	ldr	r0, [r3, #36]	; 0x24
 * @api
 */
systime_t stGetCounter(void) {

  return st_lld_get_counter();
}
 8001f96:	4770      	bx	lr
	...

08001fa0 <stSetAlarm>:
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t abstime) {

  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 8001fa0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001fa4:	6358      	str	r0, [r3, #52]	; 0x34
}
 8001fa6:	4770      	bx	lr
	...

08001fb0 <stStopAlarm>:
  STM32_ST_TIM->DIER = 0U;
 8001fb0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001fb4:	2200      	movs	r2, #0
 8001fb6:	60da      	str	r2, [r3, #12]
}
 8001fb8:	4770      	bx	lr
 8001fba:	bf00      	nop
 8001fbc:	0000      	movs	r0, r0
	...

08001fc0 <chVTDoResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 8001fc0:	b538      	push	{r3, r4, r5, lr}
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 8001fc2:	4b1e      	ldr	r3, [pc, #120]	; (800203c <chVTDoResetI+0x7c>)
 8001fc4:	69db      	ldr	r3, [r3, #28]
 8001fc6:	4283      	cmp	r3, r0
 8001fc8:	d010      	beq.n	8001fec <chVTDoResetI+0x2c>
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 8001fca:	6843      	ldr	r3, [r0, #4]
 8001fcc:	6802      	ldr	r2, [r0, #0]
 8001fce:	601a      	str	r2, [r3, #0]
    vtp->next->prev = vtp->prev;
 8001fd0:	6803      	ldr	r3, [r0, #0]
 8001fd2:	6842      	ldr	r2, [r0, #4]
 8001fd4:	605a      	str	r2, [r3, #4]
    vtp->func = NULL;
 8001fd6:	2300      	movs	r3, #0
 8001fd8:	60c3      	str	r3, [r0, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8001fda:	6803      	ldr	r3, [r0, #0]
 8001fdc:	4a18      	ldr	r2, [pc, #96]	; (8002040 <chVTDoResetI+0x80>)
 8001fde:	4293      	cmp	r3, r2
 8001fe0:	d003      	beq.n	8001fea <chVTDoResetI+0x2a>
      vtp->next->delta += vtp->delta;
 8001fe2:	6881      	ldr	r1, [r0, #8]
 8001fe4:	689a      	ldr	r2, [r3, #8]
 8001fe6:	440a      	add	r2, r1
 8001fe8:	609a      	str	r2, [r3, #8]
    }
#endif
  }
  port_timer_set_alarm(chTimeAddX(ch.vtlist.lasttime, delta));
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8001fea:	bd38      	pop	{r3, r4, r5, pc}
  ch.vtlist.next = vtp->next;
 8001fec:	6801      	ldr	r1, [r0, #0]
 8001fee:	4a13      	ldr	r2, [pc, #76]	; (800203c <chVTDoResetI+0x7c>)
 8001ff0:	4613      	mov	r3, r2
 8001ff2:	f843 1f1c 	str.w	r1, [r3, #28]!
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 8001ff6:	604b      	str	r3, [r1, #4]
  vtp->func = NULL;
 8001ff8:	2100      	movs	r1, #0
 8001ffa:	60c1      	str	r1, [r0, #12]
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8001ffc:	69d2      	ldr	r2, [r2, #28]
 8001ffe:	429a      	cmp	r2, r3
 8002000:	d016      	beq.n	8002030 <chVTDoResetI+0x70>
  ch.vtlist.next->delta += vtp->delta;
 8002002:	6881      	ldr	r1, [r0, #8]
 8002004:	6893      	ldr	r3, [r2, #8]
 8002006:	440b      	add	r3, r1
 8002008:	6093      	str	r3, [r2, #8]
  nowdelta = chTimeDiffX(ch.vtlist.lasttime, chVTGetSystemTimeX());
 800200a:	4d0c      	ldr	r5, [pc, #48]	; (800203c <chVTDoResetI+0x7c>)
 800200c:	6aac      	ldr	r4, [r5, #40]	; 0x28
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
  extern systime_t stGetCounter(void);

  return stGetCounter();
 800200e:	f7ff ffbf 	bl	8001f90 <stGetCounter>
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 8002012:	1b02      	subs	r2, r0, r4
  if (nowdelta >= ch.vtlist.next->delta) {
 8002014:	69eb      	ldr	r3, [r5, #28]
 8002016:	689b      	ldr	r3, [r3, #8]
 8002018:	4293      	cmp	r3, r2
 800201a:	d9e6      	bls.n	8001fea <chVTDoResetI+0x2a>
  delta = ch.vtlist.next->delta - nowdelta;
 800201c:	1a24      	subs	r4, r4, r0
 800201e:	441c      	add	r4, r3
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 8002020:	2c01      	cmp	r4, #1
 8002022:	d908      	bls.n	8002036 <chVTDoResetI+0x76>
  port_timer_set_alarm(chTimeAddX(ch.vtlist.lasttime, delta));
 8002024:	4a05      	ldr	r2, [pc, #20]	; (800203c <chVTDoResetI+0x7c>)
 8002026:	6a90      	ldr	r0, [r2, #40]	; 0x28
  stSetAlarm(time);
 8002028:	4418      	add	r0, r3
 800202a:	f7ff ffb9 	bl	8001fa0 <stSetAlarm>
 800202e:	e7dc      	b.n	8001fea <chVTDoResetI+0x2a>
  stStopAlarm();
 8002030:	f7ff ffbe 	bl	8001fb0 <stStopAlarm>
    return;
 8002034:	e7d9      	b.n	8001fea <chVTDoResetI+0x2a>
    delta = nowdelta + (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8002036:	1c93      	adds	r3, r2, #2
 8002038:	e7f4      	b.n	8002024 <chVTDoResetI+0x64>
 800203a:	bf00      	nop
 800203c:	20000f68 	.word	0x20000f68
 8002040:	20000f84 	.word	0x20000f84
	...

08002050 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 8002050:	b570      	push	{r4, r5, r6, lr}
  virtual_timer_t *vtp;
  systime_t now;
  sysinterval_t delta, nowdelta;

  /* Looping through timers.*/
  vtp = ch.vtlist.next;
 8002052:	4b22      	ldr	r3, [pc, #136]	; (80020dc <chSysTimerHandlerI+0x8c>)
 8002054:	69dc      	ldr	r4, [r3, #28]
  return stGetCounter();
 8002056:	f7ff ff9b 	bl	8001f90 <stGetCounter>
  while (true) {

    /* Getting the system time as reference.*/
    now = chVTGetSystemTimeX();
    nowdelta = chTimeDiffX(ch.vtlist.lasttime, now);
 800205a:	4b20      	ldr	r3, [pc, #128]	; (80020dc <chSysTimerHandlerI+0x8c>)
 800205c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800205e:	1ac5      	subs	r5, r0, r3

    /* The list scan is limited by the timers header having
       "ch.vtlist.vt_delta == (sysinterval_t)-1" which is
       greater than all deltas.*/
    if (nowdelta < vtp->delta) {
 8002060:	68a2      	ldr	r2, [r4, #8]
 8002062:	4295      	cmp	r5, r2
 8002064:	d223      	bcs.n	80020ae <chSysTimerHandlerI+0x5e>
    }
    while (vtp->delta <= nowdelta);
  }

  /* If the list is empty, nothing else to do.*/
  if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8002066:	4a1d      	ldr	r2, [pc, #116]	; (80020dc <chSysTimerHandlerI+0x8c>)
 8002068:	f852 1f1c 	ldr.w	r1, [r2, #28]!
 800206c:	4291      	cmp	r1, r2
 800206e:	d00e      	beq.n	800208e <chSysTimerHandlerI+0x3e>
    return;
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  ch.vtlist.lasttime += nowdelta;
 8002070:	4d1a      	ldr	r5, [pc, #104]	; (80020dc <chSysTimerHandlerI+0x8c>)
 8002072:	62a8      	str	r0, [r5, #40]	; 0x28
  ch.vtlist.next->delta -= nowdelta;
 8002074:	1a1b      	subs	r3, r3, r0
 8002076:	688a      	ldr	r2, [r1, #8]
 8002078:	4413      	add	r3, r2
 800207a:	608b      	str	r3, [r1, #8]

  /* Recalculating the next alarm time.*/
  delta = vtp->delta - chTimeDiffX(ch.vtlist.lasttime, now);
 800207c:	68a2      	ldr	r2, [r4, #8]
 800207e:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8002080:	1a1b      	subs	r3, r3, r0
 8002082:	4413      	add	r3, r2
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 8002084:	2b01      	cmp	r3, #1
 8002086:	d926      	bls.n	80020d6 <chSysTimerHandlerI+0x86>
  stSetAlarm(time);
 8002088:	4418      	add	r0, r3
 800208a:	f7ff ff89 	bl	8001fa0 <stSetAlarm>
#if CH_DBG_THREADS_PROFILING == TRUE
  currp->time++;
#endif
  chVTDoTickI();
  CH_CFG_SYSTEM_TICK_HOOK();
}
 800208e:	bd70      	pop	{r4, r5, r6, pc}
  stStopAlarm();
 8002090:	f7ff ff8e 	bl	8001fb0 <stStopAlarm>
 8002094:	2300      	movs	r3, #0
 8002096:	f383 8811 	msr	BASEPRI, r3
      fn(vtp->par);
 800209a:	6920      	ldr	r0, [r4, #16]
 800209c:	47b0      	blx	r6
 800209e:	2320      	movs	r3, #32
 80020a0:	f383 8811 	msr	BASEPRI, r3
      vtp = ch.vtlist.next;
 80020a4:	4b0d      	ldr	r3, [pc, #52]	; (80020dc <chSysTimerHandlerI+0x8c>)
 80020a6:	69dc      	ldr	r4, [r3, #28]
    while (vtp->delta <= nowdelta);
 80020a8:	68a3      	ldr	r3, [r4, #8]
 80020aa:	429d      	cmp	r5, r3
 80020ac:	d3d3      	bcc.n	8002056 <chSysTimerHandlerI+0x6>
      ch.vtlist.lasttime += vtp->delta;
 80020ae:	68a1      	ldr	r1, [r4, #8]
 80020b0:	4b0a      	ldr	r3, [pc, #40]	; (80020dc <chSysTimerHandlerI+0x8c>)
 80020b2:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80020b4:	440a      	add	r2, r1
 80020b6:	629a      	str	r2, [r3, #40]	; 0x28
      nowdelta -= vtp->delta;
 80020b8:	68a2      	ldr	r2, [r4, #8]
 80020ba:	1aad      	subs	r5, r5, r2
      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 80020bc:	6821      	ldr	r1, [r4, #0]
 80020be:	f103 021c 	add.w	r2, r3, #28
 80020c2:	604a      	str	r2, [r1, #4]
      ch.vtlist.next = vtp->next;
 80020c4:	6821      	ldr	r1, [r4, #0]
 80020c6:	61d9      	str	r1, [r3, #28]
      fn = vtp->func;
 80020c8:	68e6      	ldr	r6, [r4, #12]
      vtp->func = NULL;
 80020ca:	2100      	movs	r1, #0
 80020cc:	60e1      	str	r1, [r4, #12]
      if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 80020ce:	69db      	ldr	r3, [r3, #28]
 80020d0:	4293      	cmp	r3, r2
 80020d2:	d1df      	bne.n	8002094 <chSysTimerHandlerI+0x44>
 80020d4:	e7dc      	b.n	8002090 <chSysTimerHandlerI+0x40>
    delta = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 80020d6:	2302      	movs	r3, #2
 80020d8:	e7d6      	b.n	8002088 <chSysTimerHandlerI+0x38>
 80020da:	bf00      	nop
 80020dc:	20000f68 	.word	0x20000f68

080020e0 <st_lld_serve_interrupt>:

/**
 * @brief   IRQ handling code.
 */
void st_lld_serve_interrupt(void) {
 80020e0:	b508      	push	{r3, lr}
#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  uint32_t sr;
  stm32_tim_t *timp = STM32_ST_TIM;

  sr  = timp->SR;
 80020e2:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 80020e6:	6913      	ldr	r3, [r2, #16]
  sr &= timp->DIER & STM32_TIM_DIER_IRQ_MASK;
 80020e8:	68d1      	ldr	r1, [r2, #12]
 80020ea:	b2c9      	uxtb	r1, r1
 80020ec:	400b      	ands	r3, r1
  timp->SR = ~sr;
 80020ee:	43d9      	mvns	r1, r3
 80020f0:	6111      	str	r1, [r2, #16]

  if ((sr & TIM_SR_CC1IF) != 0U)
 80020f2:	f013 0f02 	tst.w	r3, #2
 80020f6:	d100      	bne.n	80020fa <st_lld_serve_interrupt+0x1a>
      st_callbacks[2](3U);
    }
  }
#endif
#endif
}
 80020f8:	bd08      	pop	{r3, pc}
 80020fa:	2320      	movs	r3, #32
 80020fc:	f383 8811 	msr	BASEPRI, r3
  chSysTimerHandlerI();
 8002100:	f7ff ffa6 	bl	8002050 <chSysTimerHandlerI>
 8002104:	2300      	movs	r3, #0
 8002106:	f383 8811 	msr	BASEPRI, r3
 800210a:	e7f5      	b.n	80020f8 <st_lld_serve_interrupt+0x18>
 800210c:	0000      	movs	r0, r0
	...

08002110 <stStartAlarm>:
  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 8002110:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002114:	6358      	str	r0, [r3, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8002116:	2200      	movs	r2, #0
 8002118:	611a      	str	r2, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 800211a:	2202      	movs	r2, #2
 800211c:	60da      	str	r2, [r3, #12]
}
 800211e:	4770      	bx	lr

08002120 <chVTDoSetI>:
                vtfunc_t vtfunc, void *par) {
 8002120:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002122:	4606      	mov	r6, r0
 8002124:	460f      	mov	r7, r1
  vtp->par = par;
 8002126:	6103      	str	r3, [r0, #16]
  vtp->func = vtfunc;
 8002128:	60c2      	str	r2, [r0, #12]
  return stGetCounter();
 800212a:	f7ff ff31 	bl	8001f90 <stGetCounter>
 800212e:	4604      	mov	r4, r0
    if (delay < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 8002130:	2f01      	cmp	r7, #1
 8002132:	d90d      	bls.n	8002150 <chVTDoSetI+0x30>
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8002134:	4b1b      	ldr	r3, [pc, #108]	; (80021a4 <chVTDoSetI+0x84>)
 8002136:	f853 5f1c 	ldr.w	r5, [r3, #28]!
 800213a:	429d      	cmp	r5, r3
 800213c:	d00a      	beq.n	8002154 <chVTDoSetI+0x34>
    delta = chTimeDiffX(ch.vtlist.lasttime, now) + delay;
 800213e:	4b19      	ldr	r3, [pc, #100]	; (80021a4 <chVTDoSetI+0x84>)
 8002140:	6a98      	ldr	r0, [r3, #40]	; 0x28
 8002142:	1a24      	subs	r4, r4, r0
    if (delta < chTimeDiffX(ch.vtlist.lasttime, now)) {
 8002144:	193c      	adds	r4, r7, r4
 8002146:	d313      	bcc.n	8002170 <chVTDoSetI+0x50>
      delta -= p->delta;
 8002148:	68ab      	ldr	r3, [r5, #8]
 800214a:	1ae4      	subs	r4, r4, r3
      p = p->next;
 800214c:	682d      	ldr	r5, [r5, #0]
 800214e:	e018      	b.n	8002182 <chVTDoSetI+0x62>
      delay = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8002150:	2702      	movs	r7, #2
 8002152:	e7ef      	b.n	8002134 <chVTDoSetI+0x14>
      ch.vtlist.lasttime = now;
 8002154:	4b13      	ldr	r3, [pc, #76]	; (80021a4 <chVTDoSetI+0x84>)
 8002156:	629c      	str	r4, [r3, #40]	; 0x28
      ch.vtlist.next = vtp;
 8002158:	61de      	str	r6, [r3, #28]
      ch.vtlist.prev = vtp;
 800215a:	621e      	str	r6, [r3, #32]
      vtp->next = (virtual_timer_t *)&ch.vtlist;
 800215c:	f103 021c 	add.w	r2, r3, #28
 8002160:	6032      	str	r2, [r6, #0]
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 8002162:	6072      	str	r2, [r6, #4]
      vtp->delta = delay;
 8002164:	60b7      	str	r7, [r6, #8]
      port_timer_start_alarm(chTimeAddX(ch.vtlist.lasttime, delay));
 8002166:	6a98      	ldr	r0, [r3, #40]	; 0x28
  stStartAlarm(time);
 8002168:	4438      	add	r0, r7
 800216a:	f7ff ffd1 	bl	8002110 <stStartAlarm>
      return;
 800216e:	e018      	b.n	80021a2 <chVTDoSetI+0x82>
    else if (delta < p->delta) {
 8002170:	68ab      	ldr	r3, [r5, #8]
 8002172:	42a3      	cmp	r3, r4
 8002174:	d905      	bls.n	8002182 <chVTDoSetI+0x62>
  stSetAlarm(time);
 8002176:	4420      	add	r0, r4
 8002178:	f7ff ff12 	bl	8001fa0 <stSetAlarm>
 800217c:	e001      	b.n	8002182 <chVTDoSetI+0x62>
    delta -= p->delta;
 800217e:	1ae4      	subs	r4, r4, r3
    p = p->next;
 8002180:	682d      	ldr	r5, [r5, #0]
  while (p->delta < delta) {
 8002182:	68ab      	ldr	r3, [r5, #8]
 8002184:	42a3      	cmp	r3, r4
 8002186:	d3fa      	bcc.n	800217e <chVTDoSetI+0x5e>
  vtp->next = p;
 8002188:	6035      	str	r5, [r6, #0]
  vtp->prev = vtp->next->prev;
 800218a:	686b      	ldr	r3, [r5, #4]
 800218c:	6073      	str	r3, [r6, #4]
  vtp->prev->next = vtp;
 800218e:	601e      	str	r6, [r3, #0]
  p->prev = vtp;
 8002190:	606e      	str	r6, [r5, #4]
  vtp->delta = delta;
 8002192:	60b4      	str	r4, [r6, #8]
  p->delta -= delta;
 8002194:	68ab      	ldr	r3, [r5, #8]
 8002196:	1b1c      	subs	r4, r3, r4
 8002198:	60ac      	str	r4, [r5, #8]
  ch.vtlist.delta = (sysinterval_t)-1;
 800219a:	4b02      	ldr	r3, [pc, #8]	; (80021a4 <chVTDoSetI+0x84>)
 800219c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80021a0:	625a      	str	r2, [r3, #36]	; 0x24
}
 80021a2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80021a4:	20000f68 	.word	0x20000f68
	...

080021b0 <stInit>:
void stInit(void) {
 80021b0:	b508      	push	{r3, lr}
  st_lld_init();
 80021b2:	f7ff f875 	bl	80012a0 <st_lld_init>
}
 80021b6:	bd08      	pop	{r3, pc}
	...

080021c0 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 80021c0:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();

  /* Platform low level initializations.*/
  hal_lld_init();
 80021c2:	f7ff f9bd 	bl	8001540 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
#if defined(PAL_NEW_INIT)
  palInit();
 80021c6:	f7fe ff0b 	bl	8000fe0 <_pal_lld_init>
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
 80021ca:	f7ff fed9 	bl	8001f80 <sdInit>
#endif
#if (HAL_USE_SDC == TRUE) || defined(__DOXYGEN__)
  sdcInit();
#endif
#if (HAL_USE_SPI == TRUE) || defined(__DOXYGEN__)
  spiInit();
 80021ce:	f7ff fd97 	bl	8001d00 <spiInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 80021d2:	f7ff ffed 	bl	80021b0 <stInit>
#endif
}
 80021d6:	bd08      	pop	{r3, pc}
	...

080021e0 <chprintf>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 80021e0:	b40e      	push	{r1, r2, r3}
 80021e2:	b500      	push	{lr}
 80021e4:	b082      	sub	sp, #8
 80021e6:	aa03      	add	r2, sp, #12
 80021e8:	f852 1b04 	ldr.w	r1, [r2], #4
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 80021ec:	9201      	str	r2, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 80021ee:	f7fe f947 	bl	8000480 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 80021f2:	b002      	add	sp, #8
 80021f4:	f85d eb04 	ldr.w	lr, [sp], #4
 80021f8:	b003      	add	sp, #12
 80021fa:	4770      	bx	lr
 80021fc:	0000      	movs	r0, r0
	...

08002200 <chSchWakeupS>:
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8002200:	b510      	push	{r4, lr}
 8002202:	4604      	mov	r4, r0
  thread_t *otp = currp;
 8002204:	4b0b      	ldr	r3, [pc, #44]	; (8002234 <chSchWakeupS+0x34>)
 8002206:	6998      	ldr	r0, [r3, #24]
  ntp->u.rdymsg = msg;
 8002208:	6261      	str	r1, [r4, #36]	; 0x24
  if (ntp->prio <= otp->prio) {
 800220a:	68a2      	ldr	r2, [r4, #8]
 800220c:	6883      	ldr	r3, [r0, #8]
 800220e:	429a      	cmp	r2, r3
 8002210:	d803      	bhi.n	800221a <chSchWakeupS+0x1a>
    (void) chSchReadyI(ntp);
 8002212:	4620      	mov	r0, r4
 8002214:	f7fe fc5c 	bl	8000ad0 <chSchReadyI>
}
 8002218:	bd10      	pop	{r4, pc}
    otp = chSchReadyAheadI(otp);
 800221a:	f7fe fc41 	bl	8000aa0 <chSchReadyAheadI>
 800221e:	4601      	mov	r1, r0
    currp = ntp;
 8002220:	4b04      	ldr	r3, [pc, #16]	; (8002234 <chSchWakeupS+0x34>)
 8002222:	619c      	str	r4, [r3, #24]
    ntp->state = CH_STATE_CURRENT;
 8002224:	2301      	movs	r3, #1
 8002226:	f884 3020 	strb.w	r3, [r4, #32]
    chSysSwitch(ntp, otp);
 800222a:	4620      	mov	r0, r4
 800222c:	f7fe f848 	bl	80002c0 <_port_switch>
 8002230:	e7f2      	b.n	8002218 <chSchWakeupS+0x18>
 8002232:	bf00      	nop
 8002234:	20000f68 	.word	0x20000f68
	...

08002240 <chThdCreate>:
thread_t *chThdCreate(const thread_descriptor_t *tdp) {
 8002240:	b510      	push	{r4, lr}
 8002242:	2320      	movs	r3, #32
 8002244:	f383 8811 	msr	BASEPRI, r3
  tp = chThdCreateSuspendedI(tdp);
 8002248:	f7fe fbd2 	bl	80009f0 <chThdCreateSuspendedI>
 800224c:	4604      	mov	r4, r0
  chSchWakeupS(tp, MSG_OK);
 800224e:	2100      	movs	r1, #0
 8002250:	f7ff ffd6 	bl	8002200 <chSchWakeupS>
 8002254:	2300      	movs	r3, #0
 8002256:	f383 8811 	msr	BASEPRI, r3
}
 800225a:	4620      	mov	r0, r4
 800225c:	bd10      	pop	{r4, pc}
 800225e:	bf00      	nop

08002260 <chSysInit>:
void chSysInit(void) {
 8002260:	b510      	push	{r4, lr}
  _scheduler_init();
 8002262:	f7fe fcd5 	bl	8000c10 <_scheduler_init>
  _vt_init();
 8002266:	f7fe fce3 	bl	8000c30 <_vt_init>
 * @notapi
 */
static inline void _oslib_init(void) {

#if CH_CFG_USE_MEMCORE == TRUE
  _core_init();
 800226a:	f7fe fad9 	bl	8000820 <_core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
 800226e:	f7fe fb37 	bl	80008e0 <_heap_init>
#endif
#if CH_CFG_USE_FACTORY == TRUE
  _factory_init();
 8002272:	f7fe fb05 	bl	8000880 <_factory_init>
  _tm_init();
 8002276:	f7fe fb83 	bl	8000980 <_tm_init>
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
 800227a:	4c0b      	ldr	r4, [pc, #44]	; (80022a8 <chSysInit+0x48>)
 800227c:	2280      	movs	r2, #128	; 0x80
 800227e:	490b      	ldr	r1, [pc, #44]	; (80022ac <chSysInit+0x4c>)
 8002280:	f104 0030 	add.w	r0, r4, #48	; 0x30
 8002284:	f7fe fb94 	bl	80009b0 <_thread_init>
 8002288:	61a0      	str	r0, [r4, #24]
  currp->wabase = NULL;
 800228a:	2400      	movs	r4, #0
 800228c:	61c4      	str	r4, [r0, #28]
  currp->state = CH_STATE_CURRENT;
 800228e:	2301      	movs	r3, #1
 8002290:	f880 3020 	strb.w	r3, [r0, #32]
  port_init();
 8002294:	f7fe fa64 	bl	8000760 <port_init>
 8002298:	f384 8811 	msr	BASEPRI, r4
  __ASM volatile ("cpsie i" : : : "memory");
 800229c:	b662      	cpsie	i
    (void) chThdCreate(&idle_descriptor);
 800229e:	4804      	ldr	r0, [pc, #16]	; (80022b0 <chSysInit+0x50>)
 80022a0:	f7ff ffce 	bl	8002240 <chThdCreate>
}
 80022a4:	bd10      	pop	{r4, pc}
 80022a6:	bf00      	nop
 80022a8:	20000f68 	.word	0x20000f68
 80022ac:	08003394 	.word	0x08003394
 80022b0:	08003498 	.word	0x08003498
	...

080022c0 <chSchGoSleepS>:
void chSchGoSleepS(tstate_t newstate) {
 80022c0:	b508      	push	{r3, lr}
  thread_t *otp = currp;
 80022c2:	4b07      	ldr	r3, [pc, #28]	; (80022e0 <chSchGoSleepS+0x20>)
 80022c4:	6999      	ldr	r1, [r3, #24]
  otp->state = newstate;
 80022c6:	f881 0020 	strb.w	r0, [r1, #32]
  thread_t *tp = tqp->next;
 80022ca:	6818      	ldr	r0, [r3, #0]
  tqp->next             = tp->queue.next;
 80022cc:	6802      	ldr	r2, [r0, #0]
 80022ce:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 80022d0:	6053      	str	r3, [r2, #4]
  currp = queue_fifo_remove(&ch.rlist.queue);
 80022d2:	6198      	str	r0, [r3, #24]
  currp->state = CH_STATE_CURRENT;
 80022d4:	2301      	movs	r3, #1
 80022d6:	f880 3020 	strb.w	r3, [r0, #32]
  chSysSwitch(currp, otp);
 80022da:	f7fd fff1 	bl	80002c0 <_port_switch>
}
 80022de:	bd08      	pop	{r3, pc}
 80022e0:	20000f68 	.word	0x20000f68
	...

080022f0 <chThdExitS>:
void chThdExitS(msg_t msg) {
 80022f0:	b510      	push	{r4, lr}
  thread_t *tp = currp;
 80022f2:	4b0f      	ldr	r3, [pc, #60]	; (8002330 <chThdExitS+0x40>)
 80022f4:	699c      	ldr	r4, [r3, #24]
  tp->u.exitcode = msg;
 80022f6:	6260      	str	r0, [r4, #36]	; 0x24
  while (list_notempty(&tp->waiting)) {
 80022f8:	f104 0328 	add.w	r3, r4, #40	; 0x28
  return (bool)(tlp->next != (thread_t *)tlp);
 80022fc:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80022fe:	4283      	cmp	r3, r0
 8002300:	d004      	beq.n	800230c <chThdExitS+0x1c>
  tlp->next = tp->queue.next;
 8002302:	6803      	ldr	r3, [r0, #0]
 8002304:	62a3      	str	r3, [r4, #40]	; 0x28
    (void) chSchReadyI(list_remove(&tp->waiting));
 8002306:	f7fe fbe3 	bl	8000ad0 <chSchReadyI>
 800230a:	e7f5      	b.n	80022f8 <chThdExitS+0x8>
  if ((tp->refs == (trefs_t)0) &&
 800230c:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
 8002310:	b94b      	cbnz	r3, 8002326 <chThdExitS+0x36>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
 8002312:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
  if ((tp->refs == (trefs_t)0) &&
 8002316:	f013 0f03 	tst.w	r3, #3
 800231a:	d104      	bne.n	8002326 <chThdExitS+0x36>
    REG_REMOVE(tp);
 800231c:	6962      	ldr	r2, [r4, #20]
 800231e:	6923      	ldr	r3, [r4, #16]
 8002320:	6113      	str	r3, [r2, #16]
 8002322:	6962      	ldr	r2, [r4, #20]
 8002324:	615a      	str	r2, [r3, #20]
  chSchGoSleepS(CH_STATE_FINAL);
 8002326:	200f      	movs	r0, #15
 8002328:	f7ff ffca 	bl	80022c0 <chSchGoSleepS>
}
 800232c:	bd10      	pop	{r4, pc}
 800232e:	bf00      	nop
 8002330:	20000f68 	.word	0x20000f68
	...

08002340 <chSchGoSleepTimeoutS>:
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 8002340:	b510      	push	{r4, lr}
 8002342:	b086      	sub	sp, #24
 8002344:	4604      	mov	r4, r0
  if (TIME_INFINITE != timeout) {
 8002346:	f1b1 3fff 	cmp.w	r1, #4294967295	; 0xffffffff
 800234a:	d012      	beq.n	8002372 <chSchGoSleepTimeoutS+0x32>
    chVTDoSetI(&vt, timeout, wakeup, currp);
 800234c:	4b0a      	ldr	r3, [pc, #40]	; (8002378 <chSchGoSleepTimeoutS+0x38>)
 800234e:	699b      	ldr	r3, [r3, #24]
 8002350:	4a0a      	ldr	r2, [pc, #40]	; (800237c <chSchGoSleepTimeoutS+0x3c>)
 8002352:	a801      	add	r0, sp, #4
 8002354:	f7ff fee4 	bl	8002120 <chVTDoSetI>
    chSchGoSleepS(newstate);
 8002358:	4620      	mov	r0, r4
 800235a:	f7ff ffb1 	bl	80022c0 <chSchGoSleepS>
  return (bool)(vtp->func != NULL);
 800235e:	9b04      	ldr	r3, [sp, #16]
    if (chVTIsArmedI(&vt)) {
 8002360:	b113      	cbz	r3, 8002368 <chSchGoSleepTimeoutS+0x28>
      chVTDoResetI(&vt);
 8002362:	a801      	add	r0, sp, #4
 8002364:	f7ff fe2c 	bl	8001fc0 <chVTDoResetI>
  return currp->u.rdymsg;
 8002368:	4b03      	ldr	r3, [pc, #12]	; (8002378 <chSchGoSleepTimeoutS+0x38>)
 800236a:	699b      	ldr	r3, [r3, #24]
}
 800236c:	6a58      	ldr	r0, [r3, #36]	; 0x24
 800236e:	b006      	add	sp, #24
 8002370:	bd10      	pop	{r4, pc}
    chSchGoSleepS(newstate);
 8002372:	f7ff ffa5 	bl	80022c0 <chSchGoSleepS>
 8002376:	e7f7      	b.n	8002368 <chSchGoSleepTimeoutS+0x28>
 8002378:	20000f68 	.word	0x20000f68
 800237c:	08000bc1 	.word	0x08000bc1

08002380 <chThdEnqueueTimeoutS>:
  if (TIME_IMMEDIATE == timeout) {
 8002380:	b159      	cbz	r1, 800239a <chThdEnqueueTimeoutS+0x1a>
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, sysinterval_t timeout) {
 8002382:	b510      	push	{r4, lr}
  queue_insert(currp, tqp);
 8002384:	4b06      	ldr	r3, [pc, #24]	; (80023a0 <chThdEnqueueTimeoutS+0x20>)
 8002386:	699b      	ldr	r3, [r3, #24]
  tp->queue.next             = (thread_t *)tqp;
 8002388:	6018      	str	r0, [r3, #0]
  tp->queue.prev             = tqp->prev;
 800238a:	6842      	ldr	r2, [r0, #4]
 800238c:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 800238e:	6013      	str	r3, [r2, #0]
  tqp->prev                  = tp;
 8002390:	6043      	str	r3, [r0, #4]
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8002392:	2004      	movs	r0, #4
 8002394:	f7ff ffd4 	bl	8002340 <chSchGoSleepTimeoutS>
}
 8002398:	bd10      	pop	{r4, pc}
    return MSG_TIMEOUT;
 800239a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 800239e:	4770      	bx	lr
 80023a0:	20000f68 	.word	0x20000f68
	...

080023b0 <palWaitLineTimeoutS>:
 *                      waiting for an edge.
 *
 * @sclass
 */
msg_t palWaitLineTimeoutS(ioline_t line,
                          sysinterval_t timeout) {
 80023b0:	b508      	push	{r3, lr}

  palevent_t *pep = pal_lld_get_line_event(line);
 80023b2:	f000 000f 	and.w	r0, r0, #15
  return chThdEnqueueTimeoutS(tqp, timeout);
 80023b6:	4b03      	ldr	r3, [pc, #12]	; (80023c4 <palWaitLineTimeoutS+0x14>)
 80023b8:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
 80023bc:	f7ff ffe0 	bl	8002380 <chThdEnqueueTimeoutS>
  return osalThreadEnqueueTimeoutS(&pep->threads, timeout);
}
 80023c0:	bd08      	pop	{r3, pc}
 80023c2:	bf00      	nop
 80023c4:	20000cdc 	.word	0x20000cdc
	...

080023d0 <palWaitLineTimeout>:
 * @retval MSG_RESET    if the event has been disabled while the thread was
 *                      waiting for an edge.
 *
 * @api
 */
msg_t palWaitLineTimeout(ioline_t line, sysinterval_t timeout) {
 80023d0:	b508      	push	{r3, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80023d2:	2320      	movs	r3, #32
 80023d4:	f383 8811 	msr	BASEPRI, r3
  msg_t msg;

  osalSysLock();
  msg = palWaitLineTimeoutS(line, timeout);
 80023d8:	f7ff ffea 	bl	80023b0 <palWaitLineTimeoutS>
 80023dc:	2300      	movs	r3, #0
 80023de:	f383 8811 	msr	BASEPRI, r3
  osalSysUnlock();
  return msg;
}
 80023e2:	bd08      	pop	{r3, pc}
	...

080023f0 <oqPutTimeout>:
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, sysinterval_t timeout) {
 80023f0:	b570      	push	{r4, r5, r6, lr}
 80023f2:	4604      	mov	r4, r0
 80023f4:	460e      	mov	r6, r1
 80023f6:	4615      	mov	r5, r2
 80023f8:	2320      	movs	r3, #32
 80023fa:	f383 8811 	msr	BASEPRI, r3
  while (oqIsFullI(oqp)) {
 80023fe:	68a3      	ldr	r3, [r4, #8]
 8002400:	b94b      	cbnz	r3, 8002416 <oqPutTimeout+0x26>
 8002402:	4629      	mov	r1, r5
 8002404:	4620      	mov	r0, r4
 8002406:	f7ff ffbb 	bl	8002380 <chThdEnqueueTimeoutS>
    if (msg < MSG_OK) {
 800240a:	2800      	cmp	r0, #0
 800240c:	daf7      	bge.n	80023fe <oqPutTimeout+0xe>
 800240e:	2300      	movs	r3, #0
 8002410:	f383 8811 	msr	BASEPRI, r3
      return msg;
 8002414:	e013      	b.n	800243e <oqPutTimeout+0x4e>
  oqp->q_counter--;
 8002416:	68a3      	ldr	r3, [r4, #8]
 8002418:	3b01      	subs	r3, #1
 800241a:	60a3      	str	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 800241c:	6963      	ldr	r3, [r4, #20]
 800241e:	1c5a      	adds	r2, r3, #1
 8002420:	6162      	str	r2, [r4, #20]
 8002422:	701e      	strb	r6, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 8002424:	6962      	ldr	r2, [r4, #20]
 8002426:	6923      	ldr	r3, [r4, #16]
 8002428:	429a      	cmp	r2, r3
 800242a:	d301      	bcc.n	8002430 <oqPutTimeout+0x40>
    oqp->q_wrptr = oqp->q_buffer;
 800242c:	68e3      	ldr	r3, [r4, #12]
 800242e:	6163      	str	r3, [r4, #20]
  if (oqp->q_notify != NULL) {
 8002430:	69e3      	ldr	r3, [r4, #28]
 8002432:	b10b      	cbz	r3, 8002438 <oqPutTimeout+0x48>
    oqp->q_notify(oqp);
 8002434:	4620      	mov	r0, r4
 8002436:	4798      	blx	r3
 8002438:	2000      	movs	r0, #0
 800243a:	f380 8811 	msr	BASEPRI, r0
}
 800243e:	bd70      	pop	{r4, r5, r6, pc}

08002440 <_putt>:
static msg_t _putt(void *ip, uint8_t b, sysinterval_t timeout) {
 8002440:	b508      	push	{r3, lr}
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 8002442:	3030      	adds	r0, #48	; 0x30
 8002444:	f7ff ffd4 	bl	80023f0 <oqPutTimeout>
}
 8002448:	bd08      	pop	{r3, pc}
 800244a:	bf00      	nop
 800244c:	0000      	movs	r0, r0
	...

08002450 <_put>:
static msg_t _put(void *ip, uint8_t b) {
 8002450:	b508      	push	{r3, lr}
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8002452:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8002456:	3030      	adds	r0, #48	; 0x30
 8002458:	f7ff ffca 	bl	80023f0 <oqPutTimeout>
}
 800245c:	bd08      	pop	{r3, pc}
 800245e:	bf00      	nop

08002460 <iqGetTimeout>:
msg_t iqGetTimeout(input_queue_t *iqp, sysinterval_t timeout) {
 8002460:	b538      	push	{r3, r4, r5, lr}
 8002462:	4605      	mov	r5, r0
 8002464:	460c      	mov	r4, r1
 8002466:	2320      	movs	r3, #32
 8002468:	f383 8811 	msr	BASEPRI, r3
  while (iqIsEmptyI(iqp)) {
 800246c:	68ab      	ldr	r3, [r5, #8]
 800246e:	b94b      	cbnz	r3, 8002484 <iqGetTimeout+0x24>
 8002470:	4621      	mov	r1, r4
 8002472:	4628      	mov	r0, r5
 8002474:	f7ff ff84 	bl	8002380 <chThdEnqueueTimeoutS>
    if (msg < MSG_OK) {
 8002478:	2800      	cmp	r0, #0
 800247a:	daf7      	bge.n	800246c <iqGetTimeout+0xc>
 800247c:	2300      	movs	r3, #0
 800247e:	f383 8811 	msr	BASEPRI, r3
      return msg;
 8002482:	e013      	b.n	80024ac <iqGetTimeout+0x4c>
  iqp->q_counter--;
 8002484:	68ab      	ldr	r3, [r5, #8]
 8002486:	3b01      	subs	r3, #1
 8002488:	60ab      	str	r3, [r5, #8]
  b = *iqp->q_rdptr++;
 800248a:	69aa      	ldr	r2, [r5, #24]
 800248c:	1c53      	adds	r3, r2, #1
 800248e:	61ab      	str	r3, [r5, #24]
 8002490:	7814      	ldrb	r4, [r2, #0]
  if (iqp->q_rdptr >= iqp->q_top) {
 8002492:	692a      	ldr	r2, [r5, #16]
 8002494:	4293      	cmp	r3, r2
 8002496:	d301      	bcc.n	800249c <iqGetTimeout+0x3c>
    iqp->q_rdptr = iqp->q_buffer;
 8002498:	68eb      	ldr	r3, [r5, #12]
 800249a:	61ab      	str	r3, [r5, #24]
  if (iqp->q_notify != NULL) {
 800249c:	69eb      	ldr	r3, [r5, #28]
 800249e:	b10b      	cbz	r3, 80024a4 <iqGetTimeout+0x44>
    iqp->q_notify(iqp);
 80024a0:	4628      	mov	r0, r5
 80024a2:	4798      	blx	r3
 80024a4:	2300      	movs	r3, #0
 80024a6:	f383 8811 	msr	BASEPRI, r3
  return (msg_t)b;
 80024aa:	4620      	mov	r0, r4
}
 80024ac:	bd38      	pop	{r3, r4, r5, pc}
 80024ae:	bf00      	nop

080024b0 <_gett>:
static msg_t _gett(void *ip, sysinterval_t timeout) {
 80024b0:	b508      	push	{r3, lr}
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 80024b2:	300c      	adds	r0, #12
 80024b4:	f7ff ffd4 	bl	8002460 <iqGetTimeout>
}
 80024b8:	bd08      	pop	{r3, pc}
 80024ba:	bf00      	nop
 80024bc:	0000      	movs	r0, r0
	...

080024c0 <_get>:
static msg_t _get(void *ip) {
 80024c0:	b508      	push	{r3, lr}
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 80024c2:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 80024c6:	300c      	adds	r0, #12
 80024c8:	f7ff ffca 	bl	8002460 <iqGetTimeout>
}
 80024cc:	bd08      	pop	{r3, pc}
 80024ce:	bf00      	nop

080024d0 <chThdSleep>:
void chThdSleep(sysinterval_t time) {
 80024d0:	b508      	push	{r3, lr}
 80024d2:	4601      	mov	r1, r0
 80024d4:	2320      	movs	r3, #32
 80024d6:	f383 8811 	msr	BASEPRI, r3
  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 80024da:	2008      	movs	r0, #8
 80024dc:	f7ff ff30 	bl	8002340 <chSchGoSleepTimeoutS>
 80024e0:	2300      	movs	r3, #0
 80024e2:	f383 8811 	msr	BASEPRI, r3
}
 80024e6:	bd08      	pop	{r3, pc}
	...

080024f0 <main_loop>:

/*
 * main loop blinks the led
 */
static void main_loop(void)
{
 80024f0:	b508      	push	{r3, lr}
  chThdSleepMilliseconds(500);
 80024f2:	f241 3088 	movw	r0, #5000	; 0x1388
 80024f6:	f7ff ffeb 	bl	80024d0 <chThdSleep>
 80024fa:	2320      	movs	r3, #32
 80024fc:	f383 8811 	msr	BASEPRI, r3
  uint8_t packet_len=0;
  //uint8_t ret_value[3]={0,0,0};

  /* Enabling events on both edges of the button line.*/
  //palEnableLineEvent(LINE_BUTTON, PAL_EVENT_MODE_RISING_EDGE);
  palEnableLineEvent(LINE_SX_INT0, PAL_EVENT_MODE_RISING_EDGE);
 8002500:	2201      	movs	r2, #1
 8002502:	2100      	movs	r1, #0
 8002504:	4812      	ldr	r0, [pc, #72]	; (8002550 <main_loop+0x60>)
 8002506:	f7fe fd2b 	bl	8000f60 <_pal_lld_enablepadevent>
 800250a:	2300      	movs	r3, #0
 800250c:	f383 8811 	msr	BASEPRI, r3
 8002510:	e008      	b.n	8002524 <main_loop+0x34>
    //palWaitLineTimeout(LINE_ARD_A5, TIME_MS2I(5000));

    palWaitLineTimeout(LINE_SX_INT0, TIME_MS2I(5000));

    if (palReadLine(LINE_SX_INT0))
      chprintf(DEBUG_CHP, "\r\r INFO: interrupt happened ** \r\n");
 8002512:	4910      	ldr	r1, [pc, #64]	; (8002554 <main_loop+0x64>)
 8002514:	4810      	ldr	r0, [pc, #64]	; (8002558 <main_loop+0x68>)
 8002516:	f7ff fe63 	bl	80021e0 <chprintf>
    else
      chprintf(DEBUG_CHP, "\r\r INFO: interrupt timeout** \r\n");
    
    packet_len=receive_loop(&axd1, axradio_rxbuffer);
 800251a:	4910      	ldr	r1, [pc, #64]	; (800255c <main_loop+0x6c>)
 800251c:	4810      	ldr	r0, [pc, #64]	; (8002560 <main_loop+0x70>)
 800251e:	f7ff f917 	bl	8001750 <receive_loop>
    //chprintf(DEBUG_CHP,"INFO: RF Frequency Offset: 0x%02x%02x%02x\r\n", axd1.rf_freq_off3, axd1.rf_freq_off2, axd1.rf_freq_off1);
    //chprintf(DEBUG_CHP,"INFO: RSSI %d\r\n", (int)axd1.rssi);
    if(packet_len > 0)
 8002522:	b970      	cbnz	r0, 8002542 <main_loop+0x52>
    palWaitLineTimeout(LINE_SX_INT0, TIME_MS2I(5000));
 8002524:	4c0a      	ldr	r4, [pc, #40]	; (8002550 <main_loop+0x60>)
 8002526:	f24c 3150 	movw	r1, #50000	; 0xc350
 800252a:	4620      	mov	r0, r4
 800252c:	f7ff ff50 	bl	80023d0 <palWaitLineTimeout>
    if (palReadLine(LINE_SX_INT0))
 8002530:	6923      	ldr	r3, [r4, #16]
 8002532:	f013 0f01 	tst.w	r3, #1
 8002536:	d1ec      	bne.n	8002512 <main_loop+0x22>
      chprintf(DEBUG_CHP, "\r\r INFO: interrupt timeout** \r\n");
 8002538:	490a      	ldr	r1, [pc, #40]	; (8002564 <main_loop+0x74>)
 800253a:	4807      	ldr	r0, [pc, #28]	; (8002558 <main_loop+0x68>)
 800253c:	f7ff fe50 	bl	80021e0 <chprintf>
 8002540:	e7eb      	b.n	800251a <main_loop+0x2a>
      chprintf(DEBUG_CHP,"INFO: Received packet %d\r\n",axradio_rxbuffer[3]);
 8002542:	4b06      	ldr	r3, [pc, #24]	; (800255c <main_loop+0x6c>)
 8002544:	78da      	ldrb	r2, [r3, #3]
 8002546:	4908      	ldr	r1, [pc, #32]	; (8002568 <main_loop+0x78>)
 8002548:	4803      	ldr	r0, [pc, #12]	; (8002558 <main_loop+0x68>)
 800254a:	f7ff fe49 	bl	80021e0 <chprintf>
 800254e:	e7e9      	b.n	8002524 <main_loop+0x34>
 8002550:	40020800 	.word	0x40020800
 8002554:	0800326c 	.word	0x0800326c
 8002558:	20000c00 	.word	0x20000c00
 800255c:	20000e68 	.word	0x20000e68
 8002560:	20000d5c 	.word	0x20000d5c
 8002564:	08003290 	.word	0x08003290
 8002568:	080032b0 	.word	0x080032b0
 800256c:	00000000 	.word	0x00000000

08002570 <ax5043_prepare_tx>:
void ax5043_prepare_tx(AX5043Driver *devp){
 8002570:	b530      	push	{r4, r5, lr}
 8002572:	b083      	sub	sp, #12
 8002574:	4605      	mov	r5, r0
  uint8_t ret_value[3]={0,0,0};
 8002576:	4b22      	ldr	r3, [pc, #136]	; (8002600 <ax5043_prepare_tx+0x90>)
 8002578:	681b      	ldr	r3, [r3, #0]
 800257a:	f8ad 3004 	strh.w	r3, [sp, #4]
 800257e:	0c1b      	lsrs	r3, r3, #16
 8002580:	f88d 3006 	strb.w	r3, [sp, #6]
  SPIDriver *spip = devp->config->spip;
 8002584:	6883      	ldr	r3, [r0, #8]
 8002586:	681c      	ldr	r4, [r3, #0]
  ax5043_set_pwrmode(devp, AX5043_STANDBY);
 8002588:	2105      	movs	r1, #5
 800258a:	f7ff fa89 	bl	8001aa0 <ax5043_set_pwrmode>
  ax5043_set_pwrmode(devp, AX5043_FIFO_ENABLED);
 800258e:	2107      	movs	r1, #7
 8002590:	4628      	mov	r0, r5
 8002592:	f7ff fa85 	bl	8001aa0 <ax5043_set_pwrmode>
  ax5043_set_regs_group(devp,tx);
 8002596:	2101      	movs	r1, #1
 8002598:	4628      	mov	r0, r5
 800259a:	f7ff fa51 	bl	8001a40 <ax5043_set_regs_group>
  ax5043_init_registers_common(devp);
 800259e:	4628      	mov	r0, r5
 80025a0:	f7ff fa0e 	bl	80019c0 <ax5043_init_registers_common>
  ax5043_write_reg(spip, AX5043_REG_FIFOTHRESH1, (uint8_t)0x00, ret_value);
 80025a4:	ab01      	add	r3, sp, #4
 80025a6:	2200      	movs	r2, #0
 80025a8:	212e      	movs	r1, #46	; 0x2e
 80025aa:	4620      	mov	r0, r4
 80025ac:	f7ff f9c8 	bl	8001940 <ax5043_write_reg>
  ax5043_write_reg(spip, AX5043_REG_FIFOTHRESH0, (uint8_t)0x80, ret_value);
 80025b0:	ab01      	add	r3, sp, #4
 80025b2:	2280      	movs	r2, #128	; 0x80
 80025b4:	212f      	movs	r1, #47	; 0x2f
 80025b6:	4620      	mov	r0, r4
 80025b8:	f7ff f9c2 	bl	8001940 <ax5043_write_reg>
  ax5043_write_reg(spip, AX5043_REG_IRQMASK0, (uint8_t)0x00, ret_value);
 80025bc:	ab01      	add	r3, sp, #4
 80025be:	2200      	movs	r2, #0
 80025c0:	2107      	movs	r1, #7
 80025c2:	4620      	mov	r0, r4
 80025c4:	f7ff f9bc 	bl	8001940 <ax5043_write_reg>
  ax5043_write_reg(spip, AX5043_REG_IRQMASK1, (uint8_t)0x01, ret_value);
 80025c8:	ab01      	add	r3, sp, #4
 80025ca:	2201      	movs	r2, #1
 80025cc:	2106      	movs	r1, #6
 80025ce:	4620      	mov	r0, r4
 80025d0:	f7ff f9b6 	bl	8001940 <ax5043_write_reg>
  while ((ax5043_read_reg(spip, AX5043_REG_XTALSTATUS, (uint8_t)0x00, ret_value) & 0x01) == 0) {
 80025d4:	ab01      	add	r3, sp, #4
 80025d6:	2200      	movs	r2, #0
 80025d8:	211d      	movs	r1, #29
 80025da:	4620      	mov	r0, r4
 80025dc:	f7ff f818 	bl	8001610 <ax5043_read_reg>
 80025e0:	f010 0f01 	tst.w	r0, #1
 80025e4:	d103      	bne.n	80025ee <ax5043_prepare_tx+0x7e>
    chThdSleepMilliseconds(1);
 80025e6:	200a      	movs	r0, #10
 80025e8:	f7ff ff72 	bl	80024d0 <chThdSleep>
 80025ec:	e7f2      	b.n	80025d4 <ax5043_prepare_tx+0x64>
  devp->status_code = ret_value[0];
 80025ee:	f89d 3004 	ldrb.w	r3, [sp, #4]
 80025f2:	f885 310b 	strb.w	r3, [r5, #267]	; 0x10b
  devp->state = AX5043_TX;
 80025f6:	2307      	movs	r3, #7
 80025f8:	712b      	strb	r3, [r5, #4]
}
 80025fa:	b003      	add	sp, #12
 80025fc:	bd30      	pop	{r4, r5, pc}
 80025fe:	bf00      	nop
 8002600:	08003254 	.word	0x08003254
	...

08002610 <ax5043_reset>:
uint8_t ax5043_reset(AX5043Driver *devp){
 8002610:	b570      	push	{r4, r5, r6, lr}
 8002612:	b082      	sub	sp, #8
 8002614:	4605      	mov	r5, r0
  uint8_t ret_value[3]={0,0,0};
 8002616:	4b2b      	ldr	r3, [pc, #172]	; (80026c4 <ax5043_reset+0xb4>)
 8002618:	681b      	ldr	r3, [r3, #0]
 800261a:	f8ad 3004 	strh.w	r3, [sp, #4]
 800261e:	0c1b      	lsrs	r3, r3, #16
 8002620:	f88d 3006 	strb.w	r3, [sp, #6]
  SPIDriver *spip = devp->config->spip;
 8002624:	6883      	ldr	r3, [r0, #8]
 8002626:	681c      	ldr	r4, [r3, #0]
  spiSelect(spip);
 8002628:	4620      	mov	r0, r4
 800262a:	f7fe ffe1 	bl	80015f0 <spiSelect>
  chThdSleepMicroseconds(5);
 800262e:	2001      	movs	r0, #1
 8002630:	f7ff ff4e 	bl	80024d0 <chThdSleep>
  spiUnselect(spip);
 8002634:	4620      	mov	r0, r4
 8002636:	f7fe ffcb 	bl	80015d0 <spiUnselect>
  chThdSleepMicroseconds(5);
 800263a:	2001      	movs	r0, #1
 800263c:	f7ff ff48 	bl	80024d0 <chThdSleep>
  spiSelect(spip);
 8002640:	4620      	mov	r0, r4
 8002642:	f7fe ffd5 	bl	80015f0 <spiSelect>
  chThdSleepMicroseconds(5);
 8002646:	2001      	movs	r0, #1
 8002648:	f7ff ff42 	bl	80024d0 <chThdSleep>
  ax5043_write_reg(spip, AX5043_REG_PWRMODE, AX5043_RESET_BIT, ret_value);
 800264c:	ab01      	add	r3, sp, #4
 800264e:	2280      	movs	r2, #128	; 0x80
 8002650:	2102      	movs	r1, #2
 8002652:	4620      	mov	r0, r4
 8002654:	f7ff f974 	bl	8001940 <ax5043_write_reg>
  chThdSleepMilliseconds(1);
 8002658:	200a      	movs	r0, #10
 800265a:	f7ff ff39 	bl	80024d0 <chThdSleep>
  value=ax5043_read_reg(&SPID2, AX5043_REG_PWRMODE, value, ret_value);
 800265e:	4e1a      	ldr	r6, [pc, #104]	; (80026c8 <ax5043_reset+0xb8>)
 8002660:	ab01      	add	r3, sp, #4
 8002662:	2200      	movs	r2, #0
 8002664:	2102      	movs	r1, #2
 8002666:	4630      	mov	r0, r6
 8002668:	f7fe ffd2 	bl	8001610 <ax5043_read_reg>
  ax5043_write_reg(spip, AX5043_REG_PWRMODE, value, ret_value);
 800266c:	ab01      	add	r3, sp, #4
 800266e:	2260      	movs	r2, #96	; 0x60
 8002670:	2102      	movs	r1, #2
 8002672:	4620      	mov	r0, r4
 8002674:	f7ff f964 	bl	8001940 <ax5043_write_reg>
  ax5043_write_reg(spip, AX5043_REG_SCRATCH, (uint8_t)0xAA, ret_value);
 8002678:	ab01      	add	r3, sp, #4
 800267a:	22aa      	movs	r2, #170	; 0xaa
 800267c:	2101      	movs	r1, #1
 800267e:	4620      	mov	r0, r4
 8002680:	f7ff f95e 	bl	8001940 <ax5043_write_reg>
  value = ax5043_read_reg(&SPID2, AX5043_REG_SCRATCH, (uint8_t)0x00, ret_value);
 8002684:	ab01      	add	r3, sp, #4
 8002686:	2200      	movs	r2, #0
 8002688:	2101      	movs	r1, #1
 800268a:	4630      	mov	r0, r6
 800268c:	f7fe ffc0 	bl	8001610 <ax5043_read_reg>
  if (value != 0xAA){
 8002690:	28aa      	cmp	r0, #170	; 0xaa
 8002692:	d002      	beq.n	800269a <ax5043_reset+0x8a>
    devp->error_code = AXRADIO_ERR_NOT_CONNECTED;
 8002694:	230f      	movs	r3, #15
 8002696:	f885 310a 	strb.w	r3, [r5, #266]	; 0x10a
  ax5043_write_reg(spip, AX5043_REG_SCRATCH, (uint8_t)0x55, ret_value);
 800269a:	ab01      	add	r3, sp, #4
 800269c:	2255      	movs	r2, #85	; 0x55
 800269e:	2101      	movs	r1, #1
 80026a0:	4620      	mov	r0, r4
 80026a2:	f7ff f94d 	bl	8001940 <ax5043_write_reg>
  value = ax5043_read_reg(spip, AX5043_REG_SCRATCH, (uint8_t)0x00, ret_value);
 80026a6:	ab01      	add	r3, sp, #4
 80026a8:	2200      	movs	r2, #0
 80026aa:	2101      	movs	r1, #1
 80026ac:	4620      	mov	r0, r4
 80026ae:	f7fe ffaf 	bl	8001610 <ax5043_read_reg>
  if (value != 0x55){
 80026b2:	2855      	cmp	r0, #85	; 0x55
 80026b4:	d002      	beq.n	80026bc <ax5043_reset+0xac>
    devp->error_code = AXRADIO_ERR_NOT_CONNECTED;
 80026b6:	230f      	movs	r3, #15
 80026b8:	f885 310a 	strb.w	r3, [r5, #266]	; 0x10a
}
 80026bc:	f89d 0004 	ldrb.w	r0, [sp, #4]
 80026c0:	b002      	add	sp, #8
 80026c2:	bd70      	pop	{r4, r5, r6, pc}
 80026c4:	08003254 	.word	0x08003254
 80026c8:	20000cac 	.word	0x20000cac
 80026cc:	00000000 	.word	0x00000000

080026d0 <ax5043_init>:
void ax5043_init(AX5043Driver *devp){
 80026d0:	b570      	push	{r4, r5, r6, lr}
 80026d2:	b082      	sub	sp, #8
 80026d4:	4605      	mov	r5, r0
  SPIDriver *spip = devp->config->spip;
 80026d6:	6883      	ldr	r3, [r0, #8]
 80026d8:	681c      	ldr	r4, [r3, #0]
  uint8_t ret_value[3]={0,0,0};
 80026da:	4b69      	ldr	r3, [pc, #420]	; (8002880 <ax5043_init+0x1b0>)
 80026dc:	681b      	ldr	r3, [r3, #0]
 80026de:	f8ad 3004 	strh.w	r3, [sp, #4]
 80026e2:	0c1b      	lsrs	r3, r3, #16
 80026e4:	f88d 3006 	strb.w	r3, [sp, #6]
  ax5043_reset(devp);         
 80026e8:	f7ff ff92 	bl	8002610 <ax5043_reset>
  ax5043_set_regs_group(devp,common);
 80026ec:	2100      	movs	r1, #0
 80026ee:	4628      	mov	r0, r5
 80026f0:	f7ff f9a6 	bl	8001a40 <ax5043_set_regs_group>
  ax5043_set_regs_group(devp,tx);
 80026f4:	2101      	movs	r1, #1
 80026f6:	4628      	mov	r0, r5
 80026f8:	f7ff f9a2 	bl	8001a40 <ax5043_set_regs_group>
  ax5043_write_reg(spip, AX5043_REG_PLLLOOP, (uint8_t)0x09, ret_value);
 80026fc:	ab01      	add	r3, sp, #4
 80026fe:	2209      	movs	r2, #9
 8002700:	2130      	movs	r1, #48	; 0x30
 8002702:	4620      	mov	r0, r4
 8002704:	f7ff f91c 	bl	8001940 <ax5043_write_reg>
  ax5043_write_reg(spip, AX5043_REG_PLLCPI, (uint8_t)0x08, ret_value);
 8002708:	ab01      	add	r3, sp, #4
 800270a:	2208      	movs	r2, #8
 800270c:	2131      	movs	r1, #49	; 0x31
 800270e:	4620      	mov	r0, r4
 8002710:	f7ff f916 	bl	8001940 <ax5043_write_reg>
  ax5043_set_pwrmode(devp, AX5043_STANDBY);
 8002714:	2105      	movs	r1, #5
 8002716:	4628      	mov	r0, r5
 8002718:	f7ff f9c2 	bl	8001aa0 <ax5043_set_pwrmode>
  ax5043_write_reg(spip, AX5043_REG_MODULATION, (uint8_t)0x08, ret_value);
 800271c:	ab01      	add	r3, sp, #4
 800271e:	2208      	movs	r2, #8
 8002720:	2110      	movs	r1, #16
 8002722:	4620      	mov	r0, r4
 8002724:	f7ff f90c 	bl	8001940 <ax5043_write_reg>
  ax5043_write_reg(spip, AX5043_REG_FSKDEV2, (uint8_t)0x00, ret_value);
 8002728:	ab01      	add	r3, sp, #4
 800272a:	2200      	movs	r2, #0
 800272c:	f240 1161 	movw	r1, #353	; 0x161
 8002730:	4620      	mov	r0, r4
 8002732:	f7ff f905 	bl	8001940 <ax5043_write_reg>
  ax5043_write_reg(spip, AX5043_REG_FSKDEV1, (uint8_t)0x00, ret_value);
 8002736:	ab01      	add	r3, sp, #4
 8002738:	2200      	movs	r2, #0
 800273a:	f44f 71b1 	mov.w	r1, #354	; 0x162
 800273e:	4620      	mov	r0, r4
 8002740:	f7ff f8fe 	bl	8001940 <ax5043_write_reg>
  ax5043_write_reg(spip, AX5043_REG_FSKDEV0, (uint8_t)0x00, ret_value);
 8002744:	ab01      	add	r3, sp, #4
 8002746:	2200      	movs	r2, #0
 8002748:	f240 1163 	movw	r1, #355	; 0x163
 800274c:	4620      	mov	r0, r4
 800274e:	f7ff f8f7 	bl	8001940 <ax5043_write_reg>
  while ((ax5043_read_reg(spip, AX5043_REG_XTALSTATUS, (uint8_t)0x00, ret_value) & 0x01) == 0){
 8002752:	ab01      	add	r3, sp, #4
 8002754:	2200      	movs	r2, #0
 8002756:	211d      	movs	r1, #29
 8002758:	4620      	mov	r0, r4
 800275a:	f7fe ff59 	bl	8001610 <ax5043_read_reg>
 800275e:	f010 0f01 	tst.w	r0, #1
 8002762:	d103      	bne.n	800276c <ax5043_init+0x9c>
    chThdSleepMilliseconds(1);
 8002764:	200a      	movs	r0, #10
 8002766:	f7ff feb3 	bl	80024d0 <chThdSleep>
 800276a:	e7f2      	b.n	8002752 <ax5043_init+0x82>
  uint32_t f = ax5043_get_conf_val(devp, AXRADIO_PHY_CHANFREQ);
 800276c:	2102      	movs	r1, #2
 800276e:	4628      	mov	r0, r5
 8002770:	f7fd ffde 	bl	8000730 <ax5043_get_conf_val>
 8002774:	4606      	mov	r6, r0
  ax5043_write_reg(spip, AX5043_REG_FREQA0, (uint8_t)f, ret_value);  
 8002776:	ab01      	add	r3, sp, #4
 8002778:	b2c2      	uxtb	r2, r0
 800277a:	2137      	movs	r1, #55	; 0x37
 800277c:	4620      	mov	r0, r4
 800277e:	f7ff f8df 	bl	8001940 <ax5043_write_reg>
  ax5043_write_reg(spip, AX5043_REG_FREQA1, (uint8_t)(f >> 8), ret_value); 
 8002782:	ab01      	add	r3, sp, #4
 8002784:	f3c6 2207 	ubfx	r2, r6, #8, #8
 8002788:	2136      	movs	r1, #54	; 0x36
 800278a:	4620      	mov	r0, r4
 800278c:	f7ff f8d8 	bl	8001940 <ax5043_write_reg>
  ax5043_write_reg(spip, AX5043_REG_FREQA2, (uint8_t)(f >> 16), ret_value); 
 8002790:	ab01      	add	r3, sp, #4
 8002792:	f3c6 4207 	ubfx	r2, r6, #16, #8
 8002796:	2135      	movs	r1, #53	; 0x35
 8002798:	4620      	mov	r0, r4
 800279a:	f7ff f8d1 	bl	8001940 <ax5043_write_reg>
  ax5043_write_reg(spip, AX5043_REG_FREQA3, (uint8_t)(f >> 24), ret_value); 
 800279e:	ab01      	add	r3, sp, #4
 80027a0:	0e32      	lsrs	r2, r6, #24
 80027a2:	2134      	movs	r1, #52	; 0x34
 80027a4:	4620      	mov	r0, r4
 80027a6:	f7ff f8cb 	bl	8001940 <ax5043_write_reg>
  uint8_t pll_init_val = ax5043_get_conf_val(devp, AXRADIO_PHY_CHANPLLRNGINIT);
 80027aa:	2103      	movs	r1, #3
 80027ac:	4628      	mov	r0, r5
 80027ae:	f7fd ffbf 	bl	8000730 <ax5043_get_conf_val>
 80027b2:	b2c2      	uxtb	r2, r0
  if( !(pll_init_val & 0xF0) ) { // start values for ranging available
 80027b4:	f010 0ff0 	tst.w	r0, #240	; 0xf0
 80027b8:	d10a      	bne.n	80027d0 <ax5043_init+0x100>
    r = pll_init_val | 0x10;
 80027ba:	f042 0210 	orr.w	r2, r2, #16
  ax5043_write_reg(spip, AX5043_REG_PLLRANGINGA, (uint8_t)r, ret_value); 
 80027be:	ab01      	add	r3, sp, #4
 80027c0:	2133      	movs	r1, #51	; 0x33
 80027c2:	4620      	mov	r0, r4
 80027c4:	f7ff f8bc 	bl	8001940 <ax5043_write_reg>
  chThdSleepMilliseconds(1);
 80027c8:	200a      	movs	r0, #10
 80027ca:	f7ff fe81 	bl	80024d0 <chThdSleep>
  while ((ax5043_read_reg(spip, AX5043_REG_PLLRANGINGA, (uint8_t)0x00, ret_value) & 0x10) != 0)
 80027ce:	e004      	b.n	80027da <ax5043_init+0x10a>
    r = 0x18;
 80027d0:	2218      	movs	r2, #24
 80027d2:	e7f4      	b.n	80027be <ax5043_init+0xee>
    chThdSleepMilliseconds(1);
 80027d4:	200a      	movs	r0, #10
 80027d6:	f7ff fe7b 	bl	80024d0 <chThdSleep>
  while ((ax5043_read_reg(spip, AX5043_REG_PLLRANGINGA, (uint8_t)0x00, ret_value) & 0x10) != 0)
 80027da:	ab01      	add	r3, sp, #4
 80027dc:	2200      	movs	r2, #0
 80027de:	2133      	movs	r1, #51	; 0x33
 80027e0:	4620      	mov	r0, r4
 80027e2:	f7fe ff15 	bl	8001610 <ax5043_read_reg>
 80027e6:	f010 0f10 	tst.w	r0, #16
 80027ea:	d1f3      	bne.n	80027d4 <ax5043_init+0x104>
  int8_t value = ax5043_read_reg(spip, AX5043_REG_PLLRANGINGA, (uint8_t)0x00, ret_value);
 80027ec:	ab01      	add	r3, sp, #4
 80027ee:	2200      	movs	r2, #0
 80027f0:	2133      	movs	r1, #51	; 0x33
 80027f2:	4620      	mov	r0, r4
 80027f4:	f7fe ff0c 	bl	8001610 <ax5043_read_reg>
  ax5043_set_conf_val(devp, AXRADIO_PHY_CHANPLLRNG, value);
 80027f8:	b242      	sxtb	r2, r0
 80027fa:	2105      	movs	r1, #5
 80027fc:	4628      	mov	r0, r5
 80027fe:	f7fd ff7f 	bl	8000700 <ax5043_set_conf_val>
  devp->state = AX5043_PLL_RANGE_DONE;
 8002802:	2308      	movs	r3, #8
 8002804:	712b      	strb	r3, [r5, #4]
  ax5043_set_pwrmode(devp, AX5043_POWERDOWN);
 8002806:	2100      	movs	r1, #0
 8002808:	4628      	mov	r0, r5
 800280a:	f7ff f949 	bl	8001aa0 <ax5043_set_pwrmode>
  ax5043_set_regs_group(devp,common);
 800280e:	2100      	movs	r1, #0
 8002810:	4628      	mov	r0, r5
 8002812:	f7ff f915 	bl	8001a40 <ax5043_set_regs_group>
  ax5043_set_regs_group(devp,rx);
 8002816:	2102      	movs	r1, #2
 8002818:	4628      	mov	r0, r5
 800281a:	f7ff f911 	bl	8001a40 <ax5043_set_regs_group>
  uint8_t pll_val = ax5043_get_conf_val(devp, AXRADIO_PHY_CHANPLLRNG);
 800281e:	2105      	movs	r1, #5
 8002820:	4628      	mov	r0, r5
 8002822:	f7fd ff85 	bl	8000730 <ax5043_get_conf_val>
  ax5043_read_reg(spip, AX5043_REG_PLLRANGINGA, (pll_val & 0x0F), ret_value);
 8002826:	ab01      	add	r3, sp, #4
 8002828:	f000 020f 	and.w	r2, r0, #15
 800282c:	2133      	movs	r1, #51	; 0x33
 800282e:	4620      	mov	r0, r4
 8002830:	f7fe feee 	bl	8001610 <ax5043_read_reg>
  f = ax5043_get_conf_val(devp, AXRADIO_PHY_CHANFREQ);
 8002834:	2102      	movs	r1, #2
 8002836:	4628      	mov	r0, r5
 8002838:	f7fd ff7a 	bl	8000730 <ax5043_get_conf_val>
 800283c:	4606      	mov	r6, r0
  ax5043_write_reg(spip, AX5043_REG_FREQA0, (uint8_t)f, ret_value);  
 800283e:	ab01      	add	r3, sp, #4
 8002840:	b2c2      	uxtb	r2, r0
 8002842:	2137      	movs	r1, #55	; 0x37
 8002844:	4620      	mov	r0, r4
 8002846:	f7ff f87b 	bl	8001940 <ax5043_write_reg>
  ax5043_write_reg(spip, AX5043_REG_FREQA1, (uint8_t)(f >> 8), ret_value); 
 800284a:	ab01      	add	r3, sp, #4
 800284c:	f3c6 2207 	ubfx	r2, r6, #8, #8
 8002850:	2136      	movs	r1, #54	; 0x36
 8002852:	4620      	mov	r0, r4
 8002854:	f7ff f874 	bl	8001940 <ax5043_write_reg>
  ax5043_write_reg(spip, AX5043_REG_FREQA2, (uint8_t)(f >> 16), ret_value); 
 8002858:	ab01      	add	r3, sp, #4
 800285a:	f3c6 4207 	ubfx	r2, r6, #16, #8
 800285e:	2135      	movs	r1, #53	; 0x35
 8002860:	4620      	mov	r0, r4
 8002862:	f7ff f86d 	bl	8001940 <ax5043_write_reg>
  ax5043_write_reg(spip, AX5043_REG_FREQA3, (uint8_t)(f >> 24), ret_value); 
 8002866:	ab01      	add	r3, sp, #4
 8002868:	0e32      	lsrs	r2, r6, #24
 800286a:	2134      	movs	r1, #52	; 0x34
 800286c:	4620      	mov	r0, r4
 800286e:	f7ff f867 	bl	8001940 <ax5043_write_reg>
  ax5043_set_regs_group(devp,local_address);
 8002872:	2104      	movs	r1, #4
 8002874:	4628      	mov	r0, r5
 8002876:	f7ff f8e3 	bl	8001a40 <ax5043_set_regs_group>
}
 800287a:	b002      	add	sp, #8
 800287c:	bd70      	pop	{r4, r5, r6, pc}
 800287e:	bf00      	nop
 8002880:	08003254 	.word	0x08003254
	...

08002890 <ax5043Start>:
 * @brief   Configures and activates the AX5043 Radio Driver.
 *
 * @param[in] devp      pointer to the @p AX5043Driver object
 * @param[in] config    pointer to the @p AX5043Config object
 */
void ax5043Start(AX5043Driver *devp, const AX5043Config *config) {
 8002890:	b538      	push	{r3, r4, r5, lr}
 8002892:	4604      	mov	r4, r0
 8002894:	460d      	mov	r5, r1
  osalDbgCheck((devp != NULL) && (config != NULL));
  osalDbgAssert((devp->state == AX5043_UNINIT) ||
          (devp->state == AX5043_READY),
          "ax5043Start(), invalid state");
    
  devp->config = config;
 8002896:	6081      	str	r1, [r0, #8]
  devp->rf_freq_off3 = 0;
 8002898:	2300      	movs	r3, #0
 800289a:	7383      	strb	r3, [r0, #14]
  devp->rf_freq_off2 = 0;
 800289c:	7343      	strb	r3, [r0, #13]
  devp->rf_freq_off1 = 0;
 800289e:	7303      	strb	r3, [r0, #12]
  devp->rssi = 0;
 80028a0:	73c3      	strb	r3, [r0, #15]
  devp->error_code = 0;
 80028a2:	f880 310a 	strb.w	r3, [r0, #266]	; 0x10a
  devp->status_code = 0;
 80028a6:	f880 310b 	strb.w	r3, [r0, #267]	; 0x10b
    
  ax5043_init(devp);
 80028aa:	f7ff ff11 	bl	80026d0 <ax5043_init>
  switch(config->ax5043_mode) {
 80028ae:	7c2b      	ldrb	r3, [r5, #16]
 80028b0:	2b03      	cmp	r3, #3
 80028b2:	d814      	bhi.n	80028de <ax5043Start+0x4e>
 80028b4:	e8df f003 	tbb	[pc, r3]
 80028b8:	0e0a0602 	.word	0x0e0a0602
  case AX5043_MODE_RX:
    ax5043_prepare_rx(devp);
 80028bc:	4620      	mov	r0, r4
 80028be:	f7ff f987 	bl	8001bd0 <ax5043_prepare_rx>
    ax5043_set_pwrmode(devp, AX5043_POWERDOWN);
    break;
  default:  
    ax5043_prepare_rx(devp);
  } 
}
 80028c2:	bd38      	pop	{r3, r4, r5, pc}
    ax5043_prepare_tx(devp);
 80028c4:	4620      	mov	r0, r4
 80028c6:	f7ff fe53 	bl	8002570 <ax5043_prepare_tx>
    break;
 80028ca:	e7fa      	b.n	80028c2 <ax5043Start+0x32>
    ax5043_prepare_cw(devp);
 80028cc:	4620      	mov	r0, r4
 80028ce:	f7ff f90f 	bl	8001af0 <ax5043_prepare_cw>
    break;
 80028d2:	e7f6      	b.n	80028c2 <ax5043Start+0x32>
    ax5043_set_pwrmode(devp, AX5043_POWERDOWN);
 80028d4:	2100      	movs	r1, #0
 80028d6:	4620      	mov	r0, r4
 80028d8:	f7ff f8e2 	bl	8001aa0 <ax5043_set_pwrmode>
    break;
 80028dc:	e7f1      	b.n	80028c2 <ax5043Start+0x32>
    ax5043_prepare_rx(devp);
 80028de:	4620      	mov	r0, r4
 80028e0:	f7ff f976 	bl	8001bd0 <ax5043_prepare_rx>
 80028e4:	e7ed      	b.n	80028c2 <ax5043Start+0x32>
 80028e6:	bf00      	nop
	...

080028f0 <app_init>:
{
 80028f0:	b510      	push	{r4, lr}
    sdStart(&DEBUG_SERIAL, &ser_cfg);
 80028f2:	490d      	ldr	r1, [pc, #52]	; (8002928 <app_init+0x38>)
 80028f4:	480d      	ldr	r0, [pc, #52]	; (800292c <app_init+0x3c>)
 80028f6:	f7ff fa0b 	bl	8001d10 <sdStart>
    spiStart(&SPID1, &spicfg_rx);
 80028fa:	490d      	ldr	r1, [pc, #52]	; (8002930 <app_init+0x40>)
 80028fc:	480d      	ldr	r0, [pc, #52]	; (8002934 <app_init+0x44>)
 80028fe:	f7ff f9b7 	bl	8001c70 <spiStart>
    spiStart(&SPID2, &spicfg_tx);
 8002902:	490d      	ldr	r1, [pc, #52]	; (8002938 <app_init+0x48>)
 8002904:	480d      	ldr	r0, [pc, #52]	; (800293c <app_init+0x4c>)
 8002906:	f7ff f9b3 	bl	8001c70 <spiStart>
    chMBObjectInit(&radio1_rx_mb, radio1_rx_queue, NUM_BUFFERS);
 800290a:	2210      	movs	r2, #16
 800290c:	490c      	ldr	r1, [pc, #48]	; (8002940 <app_init+0x50>)
 800290e:	480d      	ldr	r0, [pc, #52]	; (8002944 <app_init+0x54>)
 8002910:	f7fd ff96 	bl	8000840 <chMBObjectInit>
    ax5043ObjectInit(&axd1);
 8002914:	4c0c      	ldr	r4, [pc, #48]	; (8002948 <app_init+0x58>)
 8002916:	4620      	mov	r0, r4
 8002918:	f7fd feea 	bl	80006f0 <ax5043ObjectInit>
    ax5043Start(&axd1, &axcfg1);
 800291c:	490b      	ldr	r1, [pc, #44]	; (800294c <app_init+0x5c>)
 800291e:	4620      	mov	r0, r4
 8002920:	f7ff ffb6 	bl	8002890 <ax5043Start>
}
 8002924:	bd10      	pop	{r4, pc}
 8002926:	bf00      	nop
 8002928:	20000bf0 	.word	0x20000bf0
 800292c:	20000c00 	.word	0x20000c00
 8002930:	08003530 	.word	0x08003530
 8002934:	20000c7c 	.word	0x20000c7c
 8002938:	08003544 	.word	0x08003544
 800293c:	20000cac 	.word	0x20000cac
 8002940:	200011d0 	.word	0x200011d0
 8002944:	200011a8 	.word	0x200011a8
 8002948:	20000d5c 	.word	0x20000d5c
 800294c:	20000800 	.word	0x20000800

08002950 <oq_write>:
static size_t oq_write(output_queue_t *oqp, const uint8_t *bp, size_t n) {
 8002950:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002954:	4604      	mov	r4, r0
 8002956:	460f      	mov	r7, r1
 8002958:	4615      	mov	r5, r2
  if (n > oqGetEmptyI(oqp)) {
 800295a:	6883      	ldr	r3, [r0, #8]
 800295c:	4293      	cmp	r3, r2
 800295e:	d200      	bcs.n	8002962 <oq_write+0x12>
    n = oqGetEmptyI(oqp);
 8002960:	6885      	ldr	r5, [r0, #8]
  s1 = (size_t)(oqp->q_top - oqp->q_wrptr);
 8002962:	6926      	ldr	r6, [r4, #16]
 8002964:	6960      	ldr	r0, [r4, #20]
 8002966:	1a36      	subs	r6, r6, r0
  if (n < s1) {
 8002968:	42b5      	cmp	r5, r6
 800296a:	d315      	bcc.n	8002998 <oq_write+0x48>
  else if (n > s1) {
 800296c:	42b5      	cmp	r5, r6
 800296e:	d91b      	bls.n	80029a8 <oq_write+0x58>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, s1);
 8002970:	4632      	mov	r2, r6
 8002972:	4639      	mov	r1, r7
 8002974:	f7fd fcba 	bl	80002ec <memcpy>
    s2 = n - s1;
 8002978:	eba5 0806 	sub.w	r8, r5, r6
    memcpy((void *)oqp->q_buffer, (const void *)bp, s2);
 800297c:	4642      	mov	r2, r8
 800297e:	19b9      	adds	r1, r7, r6
 8002980:	68e0      	ldr	r0, [r4, #12]
 8002982:	f7fd fcb3 	bl	80002ec <memcpy>
    oqp->q_wrptr = oqp->q_buffer + s2;
 8002986:	68e2      	ldr	r2, [r4, #12]
 8002988:	4442      	add	r2, r8
 800298a:	6162      	str	r2, [r4, #20]
  oqp->q_counter -= n;
 800298c:	68a3      	ldr	r3, [r4, #8]
 800298e:	1b5b      	subs	r3, r3, r5
 8002990:	60a3      	str	r3, [r4, #8]
}
 8002992:	4628      	mov	r0, r5
 8002994:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 8002998:	462a      	mov	r2, r5
 800299a:	4639      	mov	r1, r7
 800299c:	f7fd fca6 	bl	80002ec <memcpy>
    oqp->q_wrptr += n;
 80029a0:	6963      	ldr	r3, [r4, #20]
 80029a2:	442b      	add	r3, r5
 80029a4:	6163      	str	r3, [r4, #20]
 80029a6:	e7f1      	b.n	800298c <oq_write+0x3c>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 80029a8:	462a      	mov	r2, r5
 80029aa:	4639      	mov	r1, r7
 80029ac:	f7fd fc9e 	bl	80002ec <memcpy>
    oqp->q_wrptr = oqp->q_buffer;
 80029b0:	68e3      	ldr	r3, [r4, #12]
 80029b2:	6163      	str	r3, [r4, #20]
 80029b4:	e7ea      	b.n	800298c <oq_write+0x3c>
 80029b6:	bf00      	nop
	...

080029c0 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, sysinterval_t timeout) {
 80029c0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80029c4:	4607      	mov	r7, r0
 80029c6:	460d      	mov	r5, r1
 80029c8:	4692      	mov	sl, r2
 80029ca:	4699      	mov	r9, r3
  qnotify_t nfy = oqp->q_notify;
 80029cc:	f8d0 801c 	ldr.w	r8, [r0, #28]
 80029d0:	2320      	movs	r3, #32
 80029d2:	f383 8811 	msr	BASEPRI, r3
 80029d6:	4614      	mov	r4, r2
 80029d8:	e013      	b.n	8002a02 <oqWriteTimeout+0x42>
 80029da:	4649      	mov	r1, r9
 80029dc:	4638      	mov	r0, r7
 80029de:	f7ff fccf 	bl	8002380 <chThdEnqueueTimeoutS>
    done = oq_write(oqp, bp, n);
    if (done == (size_t)0) {
      msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 80029e2:	b170      	cbz	r0, 8002a02 <oqWriteTimeout+0x42>
 80029e4:	2300      	movs	r3, #0
 80029e6:	f383 8811 	msr	BASEPRI, r3
    }
  }

  osalSysUnlock();
  return max - n;
}
 80029ea:	ebaa 0004 	sub.w	r0, sl, r4
 80029ee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80029f2:	2300      	movs	r3, #0
 80029f4:	f383 8811 	msr	BASEPRI, r3
      n  -= done;
 80029f8:	1ba4      	subs	r4, r4, r6
      bp += done;
 80029fa:	4435      	add	r5, r6
 80029fc:	2320      	movs	r3, #32
 80029fe:	f383 8811 	msr	BASEPRI, r3
  while (n > 0U) {
 8002a02:	2c00      	cmp	r4, #0
 8002a04:	d0ee      	beq.n	80029e4 <oqWriteTimeout+0x24>
    done = oq_write(oqp, bp, n);
 8002a06:	4622      	mov	r2, r4
 8002a08:	4629      	mov	r1, r5
 8002a0a:	4638      	mov	r0, r7
 8002a0c:	f7ff ffa0 	bl	8002950 <oq_write>
    if (done == (size_t)0) {
 8002a10:	4606      	mov	r6, r0
 8002a12:	2800      	cmp	r0, #0
 8002a14:	d0e1      	beq.n	80029da <oqWriteTimeout+0x1a>
      if (nfy != NULL) {
 8002a16:	f1b8 0f00 	cmp.w	r8, #0
 8002a1a:	d0ea      	beq.n	80029f2 <oqWriteTimeout+0x32>
        nfy(oqp);
 8002a1c:	4638      	mov	r0, r7
 8002a1e:	47c0      	blx	r8
 8002a20:	e7e7      	b.n	80029f2 <oqWriteTimeout+0x32>
 8002a22:	bf00      	nop
	...

08002a30 <_writet>:
                      sysinterval_t timeout) {
 8002a30:	b508      	push	{r3, lr}
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 8002a32:	3030      	adds	r0, #48	; 0x30
 8002a34:	f7ff ffc4 	bl	80029c0 <oqWriteTimeout>
}
 8002a38:	bd08      	pop	{r3, pc}
 8002a3a:	bf00      	nop
 8002a3c:	0000      	movs	r0, r0
	...

08002a40 <_write>:
static size_t _write(void *ip, const uint8_t *bp, size_t n) {
 8002a40:	b508      	push	{r3, lr}
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 8002a42:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8002a46:	3030      	adds	r0, #48	; 0x30
 8002a48:	f7ff ffba 	bl	80029c0 <oqWriteTimeout>
}
 8002a4c:	bd08      	pop	{r3, pc}
 8002a4e:	bf00      	nop

08002a50 <iq_read>:
static size_t iq_read(input_queue_t *iqp, uint8_t *bp, size_t n) {
 8002a50:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002a54:	4604      	mov	r4, r0
 8002a56:	460f      	mov	r7, r1
 8002a58:	4615      	mov	r5, r2
  if (n > iqGetFullI(iqp)) {
 8002a5a:	6883      	ldr	r3, [r0, #8]
 8002a5c:	4293      	cmp	r3, r2
 8002a5e:	d200      	bcs.n	8002a62 <iq_read+0x12>
    n = iqGetFullI(iqp);
 8002a60:	6885      	ldr	r5, [r0, #8]
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
 8002a62:	6926      	ldr	r6, [r4, #16]
 8002a64:	69a1      	ldr	r1, [r4, #24]
 8002a66:	1a76      	subs	r6, r6, r1
  if (n < s1) {
 8002a68:	42b5      	cmp	r5, r6
 8002a6a:	d315      	bcc.n	8002a98 <iq_read+0x48>
  else if (n > s1) {
 8002a6c:	42b5      	cmp	r5, r6
 8002a6e:	d91b      	bls.n	8002aa8 <iq_read+0x58>
    memcpy((void *)bp, (void *)iqp->q_rdptr, s1);
 8002a70:	4632      	mov	r2, r6
 8002a72:	4638      	mov	r0, r7
 8002a74:	f7fd fc3a 	bl	80002ec <memcpy>
    s2 = n - s1;
 8002a78:	eba5 0806 	sub.w	r8, r5, r6
    memcpy((void *)bp, (void *)iqp->q_buffer, s2);
 8002a7c:	4642      	mov	r2, r8
 8002a7e:	68e1      	ldr	r1, [r4, #12]
 8002a80:	19b8      	adds	r0, r7, r6
 8002a82:	f7fd fc33 	bl	80002ec <memcpy>
    iqp->q_rdptr = iqp->q_buffer + s2;
 8002a86:	68e2      	ldr	r2, [r4, #12]
 8002a88:	4442      	add	r2, r8
 8002a8a:	61a2      	str	r2, [r4, #24]
  iqp->q_counter -= n;
 8002a8c:	68a3      	ldr	r3, [r4, #8]
 8002a8e:	1b5b      	subs	r3, r3, r5
 8002a90:	60a3      	str	r3, [r4, #8]
}
 8002a92:	4628      	mov	r0, r5
 8002a94:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
 8002a98:	462a      	mov	r2, r5
 8002a9a:	4638      	mov	r0, r7
 8002a9c:	f7fd fc26 	bl	80002ec <memcpy>
    iqp->q_rdptr += n;
 8002aa0:	69a3      	ldr	r3, [r4, #24]
 8002aa2:	442b      	add	r3, r5
 8002aa4:	61a3      	str	r3, [r4, #24]
 8002aa6:	e7f1      	b.n	8002a8c <iq_read+0x3c>
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
 8002aa8:	462a      	mov	r2, r5
 8002aaa:	4638      	mov	r0, r7
 8002aac:	f7fd fc1e 	bl	80002ec <memcpy>
    iqp->q_rdptr = iqp->q_buffer;
 8002ab0:	68e3      	ldr	r3, [r4, #12]
 8002ab2:	61a3      	str	r3, [r4, #24]
 8002ab4:	e7ea      	b.n	8002a8c <iq_read+0x3c>
 8002ab6:	bf00      	nop
	...

08002ac0 <iqReadTimeout>:
                     size_t n, sysinterval_t timeout) {
 8002ac0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8002ac4:	4607      	mov	r7, r0
 8002ac6:	460d      	mov	r5, r1
 8002ac8:	4692      	mov	sl, r2
 8002aca:	4699      	mov	r9, r3
  qnotify_t nfy = iqp->q_notify;
 8002acc:	f8d0 801c 	ldr.w	r8, [r0, #28]
 8002ad0:	2320      	movs	r3, #32
 8002ad2:	f383 8811 	msr	BASEPRI, r3
 8002ad6:	4614      	mov	r4, r2
 8002ad8:	e013      	b.n	8002b02 <iqReadTimeout+0x42>
 8002ada:	4649      	mov	r1, r9
 8002adc:	4638      	mov	r0, r7
 8002ade:	f7ff fc4f 	bl	8002380 <chThdEnqueueTimeoutS>
      if (msg != MSG_OK) {
 8002ae2:	b170      	cbz	r0, 8002b02 <iqReadTimeout+0x42>
 8002ae4:	2300      	movs	r3, #0
 8002ae6:	f383 8811 	msr	BASEPRI, r3
}
 8002aea:	ebaa 0004 	sub.w	r0, sl, r4
 8002aee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8002af2:	2300      	movs	r3, #0
 8002af4:	f383 8811 	msr	BASEPRI, r3
      n  -= done;
 8002af8:	1ba4      	subs	r4, r4, r6
      bp += done;
 8002afa:	4435      	add	r5, r6
 8002afc:	2320      	movs	r3, #32
 8002afe:	f383 8811 	msr	BASEPRI, r3
  while (n > 0U) {
 8002b02:	2c00      	cmp	r4, #0
 8002b04:	d0ee      	beq.n	8002ae4 <iqReadTimeout+0x24>
    done = iq_read(iqp, bp, n);
 8002b06:	4622      	mov	r2, r4
 8002b08:	4629      	mov	r1, r5
 8002b0a:	4638      	mov	r0, r7
 8002b0c:	f7ff ffa0 	bl	8002a50 <iq_read>
    if (done == (size_t)0) {
 8002b10:	4606      	mov	r6, r0
 8002b12:	2800      	cmp	r0, #0
 8002b14:	d0e1      	beq.n	8002ada <iqReadTimeout+0x1a>
      if (nfy != NULL) {
 8002b16:	f1b8 0f00 	cmp.w	r8, #0
 8002b1a:	d0ea      	beq.n	8002af2 <iqReadTimeout+0x32>
        nfy(iqp);
 8002b1c:	4638      	mov	r0, r7
 8002b1e:	47c0      	blx	r8
 8002b20:	e7e7      	b.n	8002af2 <iqReadTimeout+0x32>
 8002b22:	bf00      	nop
	...

08002b30 <_readt>:
                     sysinterval_t timeout) {
 8002b30:	b508      	push	{r3, lr}
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 8002b32:	300c      	adds	r0, #12
 8002b34:	f7ff ffc4 	bl	8002ac0 <iqReadTimeout>
}
 8002b38:	bd08      	pop	{r3, pc}
 8002b3a:	bf00      	nop
 8002b3c:	0000      	movs	r0, r0
	...

08002b40 <_read>:
static size_t _read(void *ip, uint8_t *bp, size_t n) {
 8002b40:	b508      	push	{r3, lr}
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 8002b42:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8002b46:	300c      	adds	r0, #12
 8002b48:	f7ff ffba 	bl	8002ac0 <iqReadTimeout>
}
 8002b4c:	bd08      	pop	{r3, pc}
 8002b4e:	bf00      	nop

08002b50 <main>:

/*
 * Entry to our code
 */
int main(void)
{
 8002b50:	b508      	push	{r3, lr}
    halInit();
 8002b52:	f7ff fb35 	bl	80021c0 <halInit>
    chSysInit();
 8002b56:	f7ff fb83 	bl	8002260 <chSysInit>
    app_init();
 8002b5a:	f7ff fec9 	bl	80028f0 <app_init>
    //palEnableLineEvent(GPIOC_SX_DIO3, PAL_EVENT_MODE_RISING_EDGES);

	//chThdCreateStatic(waThread_sx1236_rx,      sizeof(waThread_sx1236_rx),   NORMALPRIO, Thread_sx1236_rx, NULL);
    //chThdSleepMilliseconds(500);
    //chThdCreateStatic(waThread_sx1236_tx,      sizeof(waThread_sx1236_tx),   NORMALPRIO, Thread_sx1236_tx, NULL);
    chThdSleepMilliseconds(500);
 8002b5e:	f241 3088 	movw	r0, #5000	; 0x1388
 8002b62:	f7ff fcb5 	bl	80024d0 <chThdSleep>

    main_loop();
 8002b66:	f7ff fcc3 	bl	80024f0 <main_loop>
 8002b6a:	bf00      	nop
 8002b6c:	0000      	movs	r0, r0
	...

08002b70 <SVC_Handler>:
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8002b70:	f3ef 8309 	mrs	r3, PSP
    psp += sizeof (struct port_extctx);
 8002b74:	3320      	adds	r3, #32
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8002b76:	f383 8809 	msr	PSP, r3
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002b7a:	2300      	movs	r3, #0
 8002b7c:	f383 8811 	msr	BASEPRI, r3
}
 8002b80:	4770      	bx	lr
 8002b82:	bf00      	nop
	...

08002b90 <chThdExit>:
void chThdExit(msg_t msg) {
 8002b90:	b508      	push	{r3, lr}
 8002b92:	2320      	movs	r3, #32
 8002b94:	f383 8811 	msr	BASEPRI, r3
  chThdExitS(msg);
 8002b98:	f7ff fbaa 	bl	80022f0 <chThdExitS>
}
 8002b9c:	bd08      	pop	{r3, pc}
 8002b9e:	bf00      	nop

08002ba0 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 8002ba0:	b510      	push	{r4, lr}
  thread_t *otp = currp;
 8002ba2:	4c08      	ldr	r4, [pc, #32]	; (8002bc4 <chSchDoReschedule+0x24>)
 8002ba4:	69a0      	ldr	r0, [r4, #24]
  thread_t *tp = tqp->next;
 8002ba6:	6823      	ldr	r3, [r4, #0]
  tqp->next             = tp->queue.next;
 8002ba8:	681a      	ldr	r2, [r3, #0]
 8002baa:	6022      	str	r2, [r4, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8002bac:	6054      	str	r4, [r2, #4]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 8002bae:	61a3      	str	r3, [r4, #24]
  currp->state = CH_STATE_CURRENT;
 8002bb0:	2201      	movs	r2, #1
 8002bb2:	f883 2020 	strb.w	r2, [r3, #32]
    otp = chSchReadyAheadI(otp);
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  otp = chSchReadyAheadI(otp);
 8002bb6:	f7fd ff73 	bl	8000aa0 <chSchReadyAheadI>
 8002bba:	4601      	mov	r1, r0
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8002bbc:	69a0      	ldr	r0, [r4, #24]
 8002bbe:	f7fd fb7f 	bl	80002c0 <_port_switch>
}
 8002bc2:	bd10      	pop	{r4, pc}
 8002bc4:	20000f68 	.word	0x20000f68
	...

08002bd0 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details GPIO ports and system clocks are initialized before everything
 *          else.
 */
void __early_init(void) {
 8002bd0:	b508      	push	{r3, lr}

  stm32_gpio_init();
 8002bd2:	f7fe f85d 	bl	8000c90 <stm32_gpio_init>
  stm32_clock_init();
 8002bd6:	f7fe fa3b 	bl	8001050 <stm32_clock_init>
}
 8002bda:	bd08      	pop	{r3, pc}
 8002bdc:	0000      	movs	r0, r0
	...

08002be0 <VectorD8>:
OSAL_IRQ_HANDLER(STM32_USART2_HANDLER) {
 8002be0:	b508      	push	{r3, lr}
  serve_interrupt(&SD2);
 8002be2:	4803      	ldr	r0, [pc, #12]	; (8002bf0 <VectorD8+0x10>)
 8002be4:	f7ff f914 	bl	8001e10 <serve_interrupt>
  OSAL_IRQ_EPILOGUE();
 8002be8:	f7fd ff32 	bl	8000a50 <_port_irq_epilogue>
}
 8002bec:	bd08      	pop	{r3, pc}
 8002bee:	bf00      	nop
 8002bf0:	20000c00 	.word	0x20000c00
	...

08002c00 <VectorB0>:
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8002c00:	b508      	push	{r3, lr}
  st_lld_serve_interrupt();
 8002c02:	f7ff fa6d 	bl	80020e0 <st_lld_serve_interrupt>
  OSAL_IRQ_EPILOGUE();
 8002c06:	f7fd ff23 	bl	8000a50 <_port_irq_epilogue>
}
 8002c0a:	bd08      	pop	{r3, pc}
 8002c0c:	0000      	movs	r0, r0
	...

08002c10 <Vector158>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
 8002c10:	b508      	push	{r3, lr}
  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8002c12:	4b08      	ldr	r3, [pc, #32]	; (8002c34 <Vector158+0x24>)
 8002c14:	6859      	ldr	r1, [r3, #4]
 8002c16:	0d89      	lsrs	r1, r1, #22
 8002c18:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 22U;
 8002c1c:	058a      	lsls	r2, r1, #22
 8002c1e:	60da      	str	r2, [r3, #12]
  if (dma.streams[15].func)
 8002c20:	4b05      	ldr	r3, [pc, #20]	; (8002c38 <Vector158+0x28>)
 8002c22:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8002c24:	b11b      	cbz	r3, 8002c2e <Vector158+0x1e>
    dma.streams[15].func(dma.streams[15].param, flags);
 8002c26:	4a04      	ldr	r2, [pc, #16]	; (8002c38 <Vector158+0x28>)
 8002c28:	f8d2 0080 	ldr.w	r0, [r2, #128]	; 0x80
 8002c2c:	4798      	blx	r3
  OSAL_IRQ_EPILOGUE();
 8002c2e:	f7fd ff0f 	bl	8000a50 <_port_irq_epilogue>
}
 8002c32:	bd08      	pop	{r3, pc}
 8002c34:	40026400 	.word	0x40026400
 8002c38:	20001124 	.word	0x20001124
 8002c3c:	00000000 	.word	0x00000000

08002c40 <Vector154>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
 8002c40:	b508      	push	{r3, lr}
  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8002c42:	4b08      	ldr	r3, [pc, #32]	; (8002c64 <Vector154+0x24>)
 8002c44:	6859      	ldr	r1, [r3, #4]
 8002c46:	0c09      	lsrs	r1, r1, #16
 8002c48:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 16U;
 8002c4c:	040a      	lsls	r2, r1, #16
 8002c4e:	60da      	str	r2, [r3, #12]
  if (dma.streams[14].func)
 8002c50:	4b05      	ldr	r3, [pc, #20]	; (8002c68 <Vector154+0x28>)
 8002c52:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8002c54:	b113      	cbz	r3, 8002c5c <Vector154+0x1c>
    dma.streams[14].func(dma.streams[14].param, flags);
 8002c56:	4a04      	ldr	r2, [pc, #16]	; (8002c68 <Vector154+0x28>)
 8002c58:	6f90      	ldr	r0, [r2, #120]	; 0x78
 8002c5a:	4798      	blx	r3
  OSAL_IRQ_EPILOGUE();
 8002c5c:	f7fd fef8 	bl	8000a50 <_port_irq_epilogue>
}
 8002c60:	bd08      	pop	{r3, pc}
 8002c62:	bf00      	nop
 8002c64:	40026400 	.word	0x40026400
 8002c68:	20001124 	.word	0x20001124
 8002c6c:	00000000 	.word	0x00000000

08002c70 <Vector150>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
 8002c70:	b508      	push	{r3, lr}
  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8002c72:	4b08      	ldr	r3, [pc, #32]	; (8002c94 <Vector150+0x24>)
 8002c74:	6859      	ldr	r1, [r3, #4]
 8002c76:	0989      	lsrs	r1, r1, #6
 8002c78:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 6U;
 8002c7c:	018a      	lsls	r2, r1, #6
 8002c7e:	60da      	str	r2, [r3, #12]
  if (dma.streams[13].func)
 8002c80:	4b05      	ldr	r3, [pc, #20]	; (8002c98 <Vector150+0x28>)
 8002c82:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8002c84:	b113      	cbz	r3, 8002c8c <Vector150+0x1c>
    dma.streams[13].func(dma.streams[13].param, flags);
 8002c86:	4a04      	ldr	r2, [pc, #16]	; (8002c98 <Vector150+0x28>)
 8002c88:	6f10      	ldr	r0, [r2, #112]	; 0x70
 8002c8a:	4798      	blx	r3
  OSAL_IRQ_EPILOGUE();
 8002c8c:	f7fd fee0 	bl	8000a50 <_port_irq_epilogue>
}
 8002c90:	bd08      	pop	{r3, pc}
 8002c92:	bf00      	nop
 8002c94:	40026400 	.word	0x40026400
 8002c98:	20001124 	.word	0x20001124
 8002c9c:	00000000 	.word	0x00000000

08002ca0 <Vector130>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
 8002ca0:	b508      	push	{r3, lr}
  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8002ca2:	4b07      	ldr	r3, [pc, #28]	; (8002cc0 <Vector130+0x20>)
 8002ca4:	6859      	ldr	r1, [r3, #4]
 8002ca6:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 0U;
 8002caa:	60d9      	str	r1, [r3, #12]
  if (dma.streams[12].func)
 8002cac:	4b05      	ldr	r3, [pc, #20]	; (8002cc4 <Vector130+0x24>)
 8002cae:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8002cb0:	b113      	cbz	r3, 8002cb8 <Vector130+0x18>
    dma.streams[12].func(dma.streams[12].param, flags);
 8002cb2:	4a04      	ldr	r2, [pc, #16]	; (8002cc4 <Vector130+0x24>)
 8002cb4:	6e90      	ldr	r0, [r2, #104]	; 0x68
 8002cb6:	4798      	blx	r3
  OSAL_IRQ_EPILOGUE();
 8002cb8:	f7fd feca 	bl	8000a50 <_port_irq_epilogue>
}
 8002cbc:	bd08      	pop	{r3, pc}
 8002cbe:	bf00      	nop
 8002cc0:	40026400 	.word	0x40026400
 8002cc4:	20001124 	.word	0x20001124
	...

08002cd0 <Vector12C>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
 8002cd0:	b508      	push	{r3, lr}
  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8002cd2:	4b08      	ldr	r3, [pc, #32]	; (8002cf4 <Vector12C+0x24>)
 8002cd4:	6819      	ldr	r1, [r3, #0]
 8002cd6:	0d89      	lsrs	r1, r1, #22
 8002cd8:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 22U;
 8002cdc:	058a      	lsls	r2, r1, #22
 8002cde:	609a      	str	r2, [r3, #8]
  if (dma.streams[11].func)
 8002ce0:	4b05      	ldr	r3, [pc, #20]	; (8002cf8 <Vector12C+0x28>)
 8002ce2:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8002ce4:	b113      	cbz	r3, 8002cec <Vector12C+0x1c>
    dma.streams[11].func(dma.streams[11].param, flags);
 8002ce6:	4a04      	ldr	r2, [pc, #16]	; (8002cf8 <Vector12C+0x28>)
 8002ce8:	6e10      	ldr	r0, [r2, #96]	; 0x60
 8002cea:	4798      	blx	r3
  OSAL_IRQ_EPILOGUE();
 8002cec:	f7fd feb0 	bl	8000a50 <_port_irq_epilogue>
}
 8002cf0:	bd08      	pop	{r3, pc}
 8002cf2:	bf00      	nop
 8002cf4:	40026400 	.word	0x40026400
 8002cf8:	20001124 	.word	0x20001124
 8002cfc:	00000000 	.word	0x00000000

08002d00 <Vector128>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
 8002d00:	b508      	push	{r3, lr}
  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8002d02:	4b08      	ldr	r3, [pc, #32]	; (8002d24 <Vector128+0x24>)
 8002d04:	6819      	ldr	r1, [r3, #0]
 8002d06:	0c09      	lsrs	r1, r1, #16
 8002d08:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 16U;
 8002d0c:	040a      	lsls	r2, r1, #16
 8002d0e:	609a      	str	r2, [r3, #8]
  if (dma.streams[10].func)
 8002d10:	4b05      	ldr	r3, [pc, #20]	; (8002d28 <Vector128+0x28>)
 8002d12:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8002d14:	b113      	cbz	r3, 8002d1c <Vector128+0x1c>
    dma.streams[10].func(dma.streams[10].param, flags);
 8002d16:	4a04      	ldr	r2, [pc, #16]	; (8002d28 <Vector128+0x28>)
 8002d18:	6d90      	ldr	r0, [r2, #88]	; 0x58
 8002d1a:	4798      	blx	r3
  OSAL_IRQ_EPILOGUE();
 8002d1c:	f7fd fe98 	bl	8000a50 <_port_irq_epilogue>
}
 8002d20:	bd08      	pop	{r3, pc}
 8002d22:	bf00      	nop
 8002d24:	40026400 	.word	0x40026400
 8002d28:	20001124 	.word	0x20001124
 8002d2c:	00000000 	.word	0x00000000

08002d30 <Vector124>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
 8002d30:	b508      	push	{r3, lr}
  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8002d32:	4b08      	ldr	r3, [pc, #32]	; (8002d54 <Vector124+0x24>)
 8002d34:	6819      	ldr	r1, [r3, #0]
 8002d36:	0989      	lsrs	r1, r1, #6
 8002d38:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 6U;
 8002d3c:	018a      	lsls	r2, r1, #6
 8002d3e:	609a      	str	r2, [r3, #8]
  if (dma.streams[9].func)
 8002d40:	4b05      	ldr	r3, [pc, #20]	; (8002d58 <Vector124+0x28>)
 8002d42:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8002d44:	b113      	cbz	r3, 8002d4c <Vector124+0x1c>
    dma.streams[9].func(dma.streams[9].param, flags);
 8002d46:	4a04      	ldr	r2, [pc, #16]	; (8002d58 <Vector124+0x28>)
 8002d48:	6d10      	ldr	r0, [r2, #80]	; 0x50
 8002d4a:	4798      	blx	r3
  OSAL_IRQ_EPILOGUE();
 8002d4c:	f7fd fe80 	bl	8000a50 <_port_irq_epilogue>
}
 8002d50:	bd08      	pop	{r3, pc}
 8002d52:	bf00      	nop
 8002d54:	40026400 	.word	0x40026400
 8002d58:	20001124 	.word	0x20001124
 8002d5c:	00000000 	.word	0x00000000

08002d60 <Vector120>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
 8002d60:	b508      	push	{r3, lr}
  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8002d62:	4b07      	ldr	r3, [pc, #28]	; (8002d80 <Vector120+0x20>)
 8002d64:	6819      	ldr	r1, [r3, #0]
 8002d66:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 0U;
 8002d6a:	6099      	str	r1, [r3, #8]
  if (dma.streams[8].func)
 8002d6c:	4b05      	ldr	r3, [pc, #20]	; (8002d84 <Vector120+0x24>)
 8002d6e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8002d70:	b113      	cbz	r3, 8002d78 <Vector120+0x18>
    dma.streams[8].func(dma.streams[8].param, flags);
 8002d72:	4a04      	ldr	r2, [pc, #16]	; (8002d84 <Vector120+0x24>)
 8002d74:	6c90      	ldr	r0, [r2, #72]	; 0x48
 8002d76:	4798      	blx	r3
  OSAL_IRQ_EPILOGUE();
 8002d78:	f7fd fe6a 	bl	8000a50 <_port_irq_epilogue>
}
 8002d7c:	bd08      	pop	{r3, pc}
 8002d7e:	bf00      	nop
 8002d80:	40026400 	.word	0x40026400
 8002d84:	20001124 	.word	0x20001124
	...

08002d90 <VectorFC>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
 8002d90:	b508      	push	{r3, lr}
  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8002d92:	4b08      	ldr	r3, [pc, #32]	; (8002db4 <VectorFC+0x24>)
 8002d94:	6859      	ldr	r1, [r3, #4]
 8002d96:	0d89      	lsrs	r1, r1, #22
 8002d98:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 22U;
 8002d9c:	058a      	lsls	r2, r1, #22
 8002d9e:	60da      	str	r2, [r3, #12]
  if (dma.streams[7].func)
 8002da0:	4b05      	ldr	r3, [pc, #20]	; (8002db8 <VectorFC+0x28>)
 8002da2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002da4:	b113      	cbz	r3, 8002dac <VectorFC+0x1c>
    dma.streams[7].func(dma.streams[7].param, flags);
 8002da6:	4a04      	ldr	r2, [pc, #16]	; (8002db8 <VectorFC+0x28>)
 8002da8:	6c10      	ldr	r0, [r2, #64]	; 0x40
 8002daa:	4798      	blx	r3
  OSAL_IRQ_EPILOGUE();
 8002dac:	f7fd fe50 	bl	8000a50 <_port_irq_epilogue>
}
 8002db0:	bd08      	pop	{r3, pc}
 8002db2:	bf00      	nop
 8002db4:	40026000 	.word	0x40026000
 8002db8:	20001124 	.word	0x20001124
 8002dbc:	00000000 	.word	0x00000000

08002dc0 <Vector84>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
 8002dc0:	b508      	push	{r3, lr}
  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8002dc2:	4b08      	ldr	r3, [pc, #32]	; (8002de4 <Vector84+0x24>)
 8002dc4:	6859      	ldr	r1, [r3, #4]
 8002dc6:	0c09      	lsrs	r1, r1, #16
 8002dc8:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 16U;
 8002dcc:	040a      	lsls	r2, r1, #16
 8002dce:	60da      	str	r2, [r3, #12]
  if (dma.streams[6].func)
 8002dd0:	4b05      	ldr	r3, [pc, #20]	; (8002de8 <Vector84+0x28>)
 8002dd2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002dd4:	b113      	cbz	r3, 8002ddc <Vector84+0x1c>
    dma.streams[6].func(dma.streams[6].param, flags);
 8002dd6:	4a04      	ldr	r2, [pc, #16]	; (8002de8 <Vector84+0x28>)
 8002dd8:	6b90      	ldr	r0, [r2, #56]	; 0x38
 8002dda:	4798      	blx	r3
  OSAL_IRQ_EPILOGUE();
 8002ddc:	f7fd fe38 	bl	8000a50 <_port_irq_epilogue>
}
 8002de0:	bd08      	pop	{r3, pc}
 8002de2:	bf00      	nop
 8002de4:	40026000 	.word	0x40026000
 8002de8:	20001124 	.word	0x20001124
 8002dec:	00000000 	.word	0x00000000

08002df0 <Vector80>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
 8002df0:	b508      	push	{r3, lr}
  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8002df2:	4b08      	ldr	r3, [pc, #32]	; (8002e14 <Vector80+0x24>)
 8002df4:	6859      	ldr	r1, [r3, #4]
 8002df6:	0989      	lsrs	r1, r1, #6
 8002df8:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 6U;
 8002dfc:	018a      	lsls	r2, r1, #6
 8002dfe:	60da      	str	r2, [r3, #12]
  if (dma.streams[5].func)
 8002e00:	4b05      	ldr	r3, [pc, #20]	; (8002e18 <Vector80+0x28>)
 8002e02:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8002e04:	b113      	cbz	r3, 8002e0c <Vector80+0x1c>
    dma.streams[5].func(dma.streams[5].param, flags);
 8002e06:	4a04      	ldr	r2, [pc, #16]	; (8002e18 <Vector80+0x28>)
 8002e08:	6b10      	ldr	r0, [r2, #48]	; 0x30
 8002e0a:	4798      	blx	r3
  OSAL_IRQ_EPILOGUE();
 8002e0c:	f7fd fe20 	bl	8000a50 <_port_irq_epilogue>
}
 8002e10:	bd08      	pop	{r3, pc}
 8002e12:	bf00      	nop
 8002e14:	40026000 	.word	0x40026000
 8002e18:	20001124 	.word	0x20001124
 8002e1c:	00000000 	.word	0x00000000

08002e20 <Vector7C>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
 8002e20:	b508      	push	{r3, lr}
  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8002e22:	4b07      	ldr	r3, [pc, #28]	; (8002e40 <Vector7C+0x20>)
 8002e24:	6859      	ldr	r1, [r3, #4]
 8002e26:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 0U;
 8002e2a:	60d9      	str	r1, [r3, #12]
  if (dma.streams[4].func)
 8002e2c:	4b05      	ldr	r3, [pc, #20]	; (8002e44 <Vector7C+0x24>)
 8002e2e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002e30:	b113      	cbz	r3, 8002e38 <Vector7C+0x18>
    dma.streams[4].func(dma.streams[4].param, flags);
 8002e32:	4a04      	ldr	r2, [pc, #16]	; (8002e44 <Vector7C+0x24>)
 8002e34:	6a90      	ldr	r0, [r2, #40]	; 0x28
 8002e36:	4798      	blx	r3
  OSAL_IRQ_EPILOGUE();
 8002e38:	f7fd fe0a 	bl	8000a50 <_port_irq_epilogue>
}
 8002e3c:	bd08      	pop	{r3, pc}
 8002e3e:	bf00      	nop
 8002e40:	40026000 	.word	0x40026000
 8002e44:	20001124 	.word	0x20001124
	...

08002e50 <Vector78>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
 8002e50:	b508      	push	{r3, lr}
  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8002e52:	4b08      	ldr	r3, [pc, #32]	; (8002e74 <Vector78+0x24>)
 8002e54:	6819      	ldr	r1, [r3, #0]
 8002e56:	0d89      	lsrs	r1, r1, #22
 8002e58:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 22U;
 8002e5c:	058a      	lsls	r2, r1, #22
 8002e5e:	609a      	str	r2, [r3, #8]
  if (dma.streams[3].func)
 8002e60:	4b05      	ldr	r3, [pc, #20]	; (8002e78 <Vector78+0x28>)
 8002e62:	69db      	ldr	r3, [r3, #28]
 8002e64:	b113      	cbz	r3, 8002e6c <Vector78+0x1c>
    dma.streams[3].func(dma.streams[3].param, flags);
 8002e66:	4a04      	ldr	r2, [pc, #16]	; (8002e78 <Vector78+0x28>)
 8002e68:	6a10      	ldr	r0, [r2, #32]
 8002e6a:	4798      	blx	r3
  OSAL_IRQ_EPILOGUE();
 8002e6c:	f7fd fdf0 	bl	8000a50 <_port_irq_epilogue>
}
 8002e70:	bd08      	pop	{r3, pc}
 8002e72:	bf00      	nop
 8002e74:	40026000 	.word	0x40026000
 8002e78:	20001124 	.word	0x20001124
 8002e7c:	00000000 	.word	0x00000000

08002e80 <Vector74>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
 8002e80:	b508      	push	{r3, lr}
  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8002e82:	4b08      	ldr	r3, [pc, #32]	; (8002ea4 <Vector74+0x24>)
 8002e84:	6819      	ldr	r1, [r3, #0]
 8002e86:	0c09      	lsrs	r1, r1, #16
 8002e88:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 16U;
 8002e8c:	040a      	lsls	r2, r1, #16
 8002e8e:	609a      	str	r2, [r3, #8]
  if (dma.streams[2].func)
 8002e90:	4b05      	ldr	r3, [pc, #20]	; (8002ea8 <Vector74+0x28>)
 8002e92:	695b      	ldr	r3, [r3, #20]
 8002e94:	b113      	cbz	r3, 8002e9c <Vector74+0x1c>
    dma.streams[2].func(dma.streams[2].param, flags);
 8002e96:	4a04      	ldr	r2, [pc, #16]	; (8002ea8 <Vector74+0x28>)
 8002e98:	6990      	ldr	r0, [r2, #24]
 8002e9a:	4798      	blx	r3
  OSAL_IRQ_EPILOGUE();
 8002e9c:	f7fd fdd8 	bl	8000a50 <_port_irq_epilogue>
}
 8002ea0:	bd08      	pop	{r3, pc}
 8002ea2:	bf00      	nop
 8002ea4:	40026000 	.word	0x40026000
 8002ea8:	20001124 	.word	0x20001124
 8002eac:	00000000 	.word	0x00000000

08002eb0 <Vector70>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 8002eb0:	b508      	push	{r3, lr}
  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8002eb2:	4b08      	ldr	r3, [pc, #32]	; (8002ed4 <Vector70+0x24>)
 8002eb4:	6819      	ldr	r1, [r3, #0]
 8002eb6:	0989      	lsrs	r1, r1, #6
 8002eb8:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 6U;
 8002ebc:	018a      	lsls	r2, r1, #6
 8002ebe:	609a      	str	r2, [r3, #8]
  if (dma.streams[1].func)
 8002ec0:	4b05      	ldr	r3, [pc, #20]	; (8002ed8 <Vector70+0x28>)
 8002ec2:	68db      	ldr	r3, [r3, #12]
 8002ec4:	b113      	cbz	r3, 8002ecc <Vector70+0x1c>
    dma.streams[1].func(dma.streams[1].param, flags);
 8002ec6:	4a04      	ldr	r2, [pc, #16]	; (8002ed8 <Vector70+0x28>)
 8002ec8:	6910      	ldr	r0, [r2, #16]
 8002eca:	4798      	blx	r3
  OSAL_IRQ_EPILOGUE();
 8002ecc:	f7fd fdc0 	bl	8000a50 <_port_irq_epilogue>
}
 8002ed0:	bd08      	pop	{r3, pc}
 8002ed2:	bf00      	nop
 8002ed4:	40026000 	.word	0x40026000
 8002ed8:	20001124 	.word	0x20001124
 8002edc:	00000000 	.word	0x00000000

08002ee0 <Vector6C>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH0_HANDLER) {
 8002ee0:	b508      	push	{r3, lr}
  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8002ee2:	4b07      	ldr	r3, [pc, #28]	; (8002f00 <Vector6C+0x20>)
 8002ee4:	6819      	ldr	r1, [r3, #0]
 8002ee6:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 0U;
 8002eea:	6099      	str	r1, [r3, #8]
  if (dma.streams[0].func)
 8002eec:	4b05      	ldr	r3, [pc, #20]	; (8002f04 <Vector6C+0x24>)
 8002eee:	685b      	ldr	r3, [r3, #4]
 8002ef0:	b113      	cbz	r3, 8002ef8 <Vector6C+0x18>
    dma.streams[0].func(dma.streams[0].param, flags);
 8002ef2:	4a04      	ldr	r2, [pc, #16]	; (8002f04 <Vector6C+0x24>)
 8002ef4:	6890      	ldr	r0, [r2, #8]
 8002ef6:	4798      	blx	r3
  OSAL_IRQ_EPILOGUE();
 8002ef8:	f7fd fdaa 	bl	8000a50 <_port_irq_epilogue>
}
 8002efc:	bd08      	pop	{r3, pc}
 8002efe:	bf00      	nop
 8002f00:	40026000 	.word	0x40026000
 8002f04:	20001124 	.word	0x20001124
	...

08002f10 <VectorE0>:
OSAL_IRQ_HANDLER(VectorE0) {
 8002f10:	b510      	push	{r4, lr}
  pr = EXTI->PR;
 8002f12:	4b2f      	ldr	r3, [pc, #188]	; (8002fd0 <VectorE0+0xc0>)
 8002f14:	695c      	ldr	r4, [r3, #20]
  pr &= EXTI->IMR & ((1U << 10) | (1U << 11) | (1U << 12) | (1U << 13) |
 8002f16:	681a      	ldr	r2, [r3, #0]
 8002f18:	f402 427c 	and.w	r2, r2, #64512	; 0xfc00
 8002f1c:	4014      	ands	r4, r2
  EXTI->PR = pr;
 8002f1e:	615c      	str	r4, [r3, #20]
  exti_serve_irq(pr, 10);
 8002f20:	f414 6f80 	tst.w	r4, #1024	; 0x400
 8002f24:	d111      	bne.n	8002f4a <VectorE0+0x3a>
  exti_serve_irq(pr, 11);
 8002f26:	f414 6f00 	tst.w	r4, #2048	; 0x800
 8002f2a:	d119      	bne.n	8002f60 <VectorE0+0x50>
  exti_serve_irq(pr, 12);
 8002f2c:	f414 5f80 	tst.w	r4, #4096	; 0x1000
 8002f30:	d121      	bne.n	8002f76 <VectorE0+0x66>
  exti_serve_irq(pr, 13);
 8002f32:	f414 5f00 	tst.w	r4, #8192	; 0x2000
 8002f36:	d129      	bne.n	8002f8c <VectorE0+0x7c>
  exti_serve_irq(pr, 14);
 8002f38:	f414 4f80 	tst.w	r4, #16384	; 0x4000
 8002f3c:	d131      	bne.n	8002fa2 <VectorE0+0x92>
  exti_serve_irq(pr, 15);
 8002f3e:	f414 4f00 	tst.w	r4, #32768	; 0x8000
 8002f42:	d139      	bne.n	8002fb8 <VectorE0+0xa8>
  OSAL_IRQ_EPILOGUE();
 8002f44:	f7fd fd84 	bl	8000a50 <_port_irq_epilogue>
}
 8002f48:	bd10      	pop	{r4, pc}
 8002f4a:	2320      	movs	r3, #32
 8002f4c:	f383 8811 	msr	BASEPRI, r3
  chThdDequeueAllI(tqp, msg);
 8002f50:	2100      	movs	r1, #0
 8002f52:	4820      	ldr	r0, [pc, #128]	; (8002fd4 <VectorE0+0xc4>)
 8002f54:	f7fd fe04 	bl	8000b60 <chThdDequeueAllI>
 8002f58:	2300      	movs	r3, #0
 8002f5a:	f383 8811 	msr	BASEPRI, r3
 8002f5e:	e7e2      	b.n	8002f26 <VectorE0+0x16>
 8002f60:	2320      	movs	r3, #32
 8002f62:	f383 8811 	msr	BASEPRI, r3
 8002f66:	2100      	movs	r1, #0
 8002f68:	481b      	ldr	r0, [pc, #108]	; (8002fd8 <VectorE0+0xc8>)
 8002f6a:	f7fd fdf9 	bl	8000b60 <chThdDequeueAllI>
 8002f6e:	2300      	movs	r3, #0
 8002f70:	f383 8811 	msr	BASEPRI, r3
 8002f74:	e7da      	b.n	8002f2c <VectorE0+0x1c>
 8002f76:	2320      	movs	r3, #32
 8002f78:	f383 8811 	msr	BASEPRI, r3
 8002f7c:	2100      	movs	r1, #0
 8002f7e:	4817      	ldr	r0, [pc, #92]	; (8002fdc <VectorE0+0xcc>)
 8002f80:	f7fd fdee 	bl	8000b60 <chThdDequeueAllI>
 8002f84:	2300      	movs	r3, #0
 8002f86:	f383 8811 	msr	BASEPRI, r3
 8002f8a:	e7d2      	b.n	8002f32 <VectorE0+0x22>
 8002f8c:	2320      	movs	r3, #32
 8002f8e:	f383 8811 	msr	BASEPRI, r3
 8002f92:	2100      	movs	r1, #0
 8002f94:	4812      	ldr	r0, [pc, #72]	; (8002fe0 <VectorE0+0xd0>)
 8002f96:	f7fd fde3 	bl	8000b60 <chThdDequeueAllI>
 8002f9a:	2300      	movs	r3, #0
 8002f9c:	f383 8811 	msr	BASEPRI, r3
 8002fa0:	e7ca      	b.n	8002f38 <VectorE0+0x28>
 8002fa2:	2320      	movs	r3, #32
 8002fa4:	f383 8811 	msr	BASEPRI, r3
 8002fa8:	2100      	movs	r1, #0
 8002faa:	480e      	ldr	r0, [pc, #56]	; (8002fe4 <VectorE0+0xd4>)
 8002fac:	f7fd fdd8 	bl	8000b60 <chThdDequeueAllI>
 8002fb0:	2300      	movs	r3, #0
 8002fb2:	f383 8811 	msr	BASEPRI, r3
 8002fb6:	e7c2      	b.n	8002f3e <VectorE0+0x2e>
 8002fb8:	2320      	movs	r3, #32
 8002fba:	f383 8811 	msr	BASEPRI, r3
 8002fbe:	2100      	movs	r1, #0
 8002fc0:	4809      	ldr	r0, [pc, #36]	; (8002fe8 <VectorE0+0xd8>)
 8002fc2:	f7fd fdcd 	bl	8000b60 <chThdDequeueAllI>
 8002fc6:	2300      	movs	r3, #0
 8002fc8:	f383 8811 	msr	BASEPRI, r3
 8002fcc:	e7ba      	b.n	8002f44 <VectorE0+0x34>
 8002fce:	bf00      	nop
 8002fd0:	40013c00 	.word	0x40013c00
 8002fd4:	20000d2c 	.word	0x20000d2c
 8002fd8:	20000d34 	.word	0x20000d34
 8002fdc:	20000d3c 	.word	0x20000d3c
 8002fe0:	20000d44 	.word	0x20000d44
 8002fe4:	20000d4c 	.word	0x20000d4c
 8002fe8:	20000d54 	.word	0x20000d54
 8002fec:	00000000 	.word	0x00000000

08002ff0 <Vector9C>:
OSAL_IRQ_HANDLER(Vector9C) {
 8002ff0:	b510      	push	{r4, lr}
  pr = EXTI->PR;
 8002ff2:	4b28      	ldr	r3, [pc, #160]	; (8003094 <Vector9C+0xa4>)
 8002ff4:	695c      	ldr	r4, [r3, #20]
  pr &= EXTI->IMR & ((1U << 5) | (1U << 6) | (1U << 7) | (1U << 8) |
 8002ff6:	681a      	ldr	r2, [r3, #0]
 8002ff8:	f402 7278 	and.w	r2, r2, #992	; 0x3e0
 8002ffc:	4014      	ands	r4, r2
  EXTI->PR = pr;
 8002ffe:	615c      	str	r4, [r3, #20]
  exti_serve_irq(pr, 5);
 8003000:	f014 0f20 	tst.w	r4, #32
 8003004:	d10e      	bne.n	8003024 <Vector9C+0x34>
  exti_serve_irq(pr, 6);
 8003006:	f014 0f40 	tst.w	r4, #64	; 0x40
 800300a:	d116      	bne.n	800303a <Vector9C+0x4a>
  exti_serve_irq(pr, 7);
 800300c:	f014 0f80 	tst.w	r4, #128	; 0x80
 8003010:	d11e      	bne.n	8003050 <Vector9C+0x60>
  exti_serve_irq(pr, 8);
 8003012:	f414 7f80 	tst.w	r4, #256	; 0x100
 8003016:	d126      	bne.n	8003066 <Vector9C+0x76>
  exti_serve_irq(pr, 9);
 8003018:	f414 7f00 	tst.w	r4, #512	; 0x200
 800301c:	d12e      	bne.n	800307c <Vector9C+0x8c>
  OSAL_IRQ_EPILOGUE();
 800301e:	f7fd fd17 	bl	8000a50 <_port_irq_epilogue>
}
 8003022:	bd10      	pop	{r4, pc}
 8003024:	2320      	movs	r3, #32
 8003026:	f383 8811 	msr	BASEPRI, r3
 800302a:	2100      	movs	r1, #0
 800302c:	481a      	ldr	r0, [pc, #104]	; (8003098 <Vector9C+0xa8>)
 800302e:	f7fd fd97 	bl	8000b60 <chThdDequeueAllI>
 8003032:	2300      	movs	r3, #0
 8003034:	f383 8811 	msr	BASEPRI, r3
 8003038:	e7e5      	b.n	8003006 <Vector9C+0x16>
 800303a:	2320      	movs	r3, #32
 800303c:	f383 8811 	msr	BASEPRI, r3
 8003040:	2100      	movs	r1, #0
 8003042:	4816      	ldr	r0, [pc, #88]	; (800309c <Vector9C+0xac>)
 8003044:	f7fd fd8c 	bl	8000b60 <chThdDequeueAllI>
 8003048:	2300      	movs	r3, #0
 800304a:	f383 8811 	msr	BASEPRI, r3
 800304e:	e7dd      	b.n	800300c <Vector9C+0x1c>
 8003050:	2320      	movs	r3, #32
 8003052:	f383 8811 	msr	BASEPRI, r3
 8003056:	2100      	movs	r1, #0
 8003058:	4811      	ldr	r0, [pc, #68]	; (80030a0 <Vector9C+0xb0>)
 800305a:	f7fd fd81 	bl	8000b60 <chThdDequeueAllI>
 800305e:	2300      	movs	r3, #0
 8003060:	f383 8811 	msr	BASEPRI, r3
 8003064:	e7d5      	b.n	8003012 <Vector9C+0x22>
 8003066:	2320      	movs	r3, #32
 8003068:	f383 8811 	msr	BASEPRI, r3
 800306c:	2100      	movs	r1, #0
 800306e:	480d      	ldr	r0, [pc, #52]	; (80030a4 <Vector9C+0xb4>)
 8003070:	f7fd fd76 	bl	8000b60 <chThdDequeueAllI>
 8003074:	2300      	movs	r3, #0
 8003076:	f383 8811 	msr	BASEPRI, r3
 800307a:	e7cd      	b.n	8003018 <Vector9C+0x28>
 800307c:	2320      	movs	r3, #32
 800307e:	f383 8811 	msr	BASEPRI, r3
 8003082:	2100      	movs	r1, #0
 8003084:	4808      	ldr	r0, [pc, #32]	; (80030a8 <Vector9C+0xb8>)
 8003086:	f7fd fd6b 	bl	8000b60 <chThdDequeueAllI>
 800308a:	2300      	movs	r3, #0
 800308c:	f383 8811 	msr	BASEPRI, r3
 8003090:	e7c5      	b.n	800301e <Vector9C+0x2e>
 8003092:	bf00      	nop
 8003094:	40013c00 	.word	0x40013c00
 8003098:	20000d04 	.word	0x20000d04
 800309c:	20000d0c 	.word	0x20000d0c
 80030a0:	20000d14 	.word	0x20000d14
 80030a4:	20000d1c 	.word	0x20000d1c
 80030a8:	20000d24 	.word	0x20000d24
 80030ac:	00000000 	.word	0x00000000

080030b0 <Vector68>:
OSAL_IRQ_HANDLER(Vector68) {
 80030b0:	b508      	push	{r3, lr}
  pr = EXTI->PR;
 80030b2:	4a0b      	ldr	r2, [pc, #44]	; (80030e0 <Vector68+0x30>)
 80030b4:	6953      	ldr	r3, [r2, #20]
  pr &= EXTI->IMR & (1U << 4);
 80030b6:	6811      	ldr	r1, [r2, #0]
 80030b8:	f001 0110 	and.w	r1, r1, #16
 80030bc:	400b      	ands	r3, r1
  EXTI->PR = pr;
 80030be:	6153      	str	r3, [r2, #20]
  exti_serve_irq(pr, 4);
 80030c0:	b913      	cbnz	r3, 80030c8 <Vector68+0x18>
  OSAL_IRQ_EPILOGUE();
 80030c2:	f7fd fcc5 	bl	8000a50 <_port_irq_epilogue>
}
 80030c6:	bd08      	pop	{r3, pc}
 80030c8:	2320      	movs	r3, #32
 80030ca:	f383 8811 	msr	BASEPRI, r3
 80030ce:	2100      	movs	r1, #0
 80030d0:	4804      	ldr	r0, [pc, #16]	; (80030e4 <Vector68+0x34>)
 80030d2:	f7fd fd45 	bl	8000b60 <chThdDequeueAllI>
 80030d6:	2300      	movs	r3, #0
 80030d8:	f383 8811 	msr	BASEPRI, r3
 80030dc:	e7f1      	b.n	80030c2 <Vector68+0x12>
 80030de:	bf00      	nop
 80030e0:	40013c00 	.word	0x40013c00
 80030e4:	20000cfc 	.word	0x20000cfc
	...

080030f0 <Vector64>:
OSAL_IRQ_HANDLER(Vector64) {
 80030f0:	b508      	push	{r3, lr}
  pr = EXTI->PR;
 80030f2:	4a0b      	ldr	r2, [pc, #44]	; (8003120 <Vector64+0x30>)
 80030f4:	6953      	ldr	r3, [r2, #20]
  pr &= EXTI->IMR & (1U << 3);
 80030f6:	6811      	ldr	r1, [r2, #0]
 80030f8:	f001 0108 	and.w	r1, r1, #8
 80030fc:	400b      	ands	r3, r1
  EXTI->PR = pr;
 80030fe:	6153      	str	r3, [r2, #20]
  exti_serve_irq(pr, 3);
 8003100:	b913      	cbnz	r3, 8003108 <Vector64+0x18>
  OSAL_IRQ_EPILOGUE();
 8003102:	f7fd fca5 	bl	8000a50 <_port_irq_epilogue>
}
 8003106:	bd08      	pop	{r3, pc}
 8003108:	2320      	movs	r3, #32
 800310a:	f383 8811 	msr	BASEPRI, r3
 800310e:	2100      	movs	r1, #0
 8003110:	4804      	ldr	r0, [pc, #16]	; (8003124 <Vector64+0x34>)
 8003112:	f7fd fd25 	bl	8000b60 <chThdDequeueAllI>
 8003116:	2300      	movs	r3, #0
 8003118:	f383 8811 	msr	BASEPRI, r3
 800311c:	e7f1      	b.n	8003102 <Vector64+0x12>
 800311e:	bf00      	nop
 8003120:	40013c00 	.word	0x40013c00
 8003124:	20000cf4 	.word	0x20000cf4
	...

08003130 <Vector60>:
OSAL_IRQ_HANDLER(Vector60) {
 8003130:	b508      	push	{r3, lr}
  pr = EXTI->PR;
 8003132:	4a0b      	ldr	r2, [pc, #44]	; (8003160 <Vector60+0x30>)
 8003134:	6953      	ldr	r3, [r2, #20]
  pr &= EXTI->IMR & (1U << 2);
 8003136:	6811      	ldr	r1, [r2, #0]
 8003138:	f001 0104 	and.w	r1, r1, #4
 800313c:	400b      	ands	r3, r1
  EXTI->PR = pr;
 800313e:	6153      	str	r3, [r2, #20]
  exti_serve_irq(pr, 2);
 8003140:	b913      	cbnz	r3, 8003148 <Vector60+0x18>
  OSAL_IRQ_EPILOGUE();
 8003142:	f7fd fc85 	bl	8000a50 <_port_irq_epilogue>
}
 8003146:	bd08      	pop	{r3, pc}
 8003148:	2320      	movs	r3, #32
 800314a:	f383 8811 	msr	BASEPRI, r3
 800314e:	2100      	movs	r1, #0
 8003150:	4804      	ldr	r0, [pc, #16]	; (8003164 <Vector60+0x34>)
 8003152:	f7fd fd05 	bl	8000b60 <chThdDequeueAllI>
 8003156:	2300      	movs	r3, #0
 8003158:	f383 8811 	msr	BASEPRI, r3
 800315c:	e7f1      	b.n	8003142 <Vector60+0x12>
 800315e:	bf00      	nop
 8003160:	40013c00 	.word	0x40013c00
 8003164:	20000cec 	.word	0x20000cec
	...

08003170 <Vector5C>:
OSAL_IRQ_HANDLER(Vector5C) {
 8003170:	b508      	push	{r3, lr}
  pr = EXTI->PR;
 8003172:	4a0b      	ldr	r2, [pc, #44]	; (80031a0 <Vector5C+0x30>)
 8003174:	6953      	ldr	r3, [r2, #20]
  pr &= EXTI->IMR & (1U << 1);
 8003176:	6811      	ldr	r1, [r2, #0]
 8003178:	f001 0102 	and.w	r1, r1, #2
 800317c:	400b      	ands	r3, r1
  EXTI->PR = pr;
 800317e:	6153      	str	r3, [r2, #20]
  exti_serve_irq(pr, 1);
 8003180:	b913      	cbnz	r3, 8003188 <Vector5C+0x18>
  OSAL_IRQ_EPILOGUE();
 8003182:	f7fd fc65 	bl	8000a50 <_port_irq_epilogue>
}
 8003186:	bd08      	pop	{r3, pc}
 8003188:	2320      	movs	r3, #32
 800318a:	f383 8811 	msr	BASEPRI, r3
 800318e:	2100      	movs	r1, #0
 8003190:	4804      	ldr	r0, [pc, #16]	; (80031a4 <Vector5C+0x34>)
 8003192:	f7fd fce5 	bl	8000b60 <chThdDequeueAllI>
 8003196:	2300      	movs	r3, #0
 8003198:	f383 8811 	msr	BASEPRI, r3
 800319c:	e7f1      	b.n	8003182 <Vector5C+0x12>
 800319e:	bf00      	nop
 80031a0:	40013c00 	.word	0x40013c00
 80031a4:	20000ce4 	.word	0x20000ce4
	...

080031b0 <Vector58>:
OSAL_IRQ_HANDLER(Vector58) {
 80031b0:	b508      	push	{r3, lr}
  pr = EXTI->PR;
 80031b2:	4a0b      	ldr	r2, [pc, #44]	; (80031e0 <Vector58+0x30>)
 80031b4:	6953      	ldr	r3, [r2, #20]
  pr &= EXTI->IMR & (1U << 0);
 80031b6:	6811      	ldr	r1, [r2, #0]
 80031b8:	f001 0101 	and.w	r1, r1, #1
 80031bc:	400b      	ands	r3, r1
  EXTI->PR = pr;
 80031be:	6153      	str	r3, [r2, #20]
  exti_serve_irq(pr, 0);
 80031c0:	b913      	cbnz	r3, 80031c8 <Vector58+0x18>
  OSAL_IRQ_EPILOGUE();
 80031c2:	f7fd fc45 	bl	8000a50 <_port_irq_epilogue>
}
 80031c6:	bd08      	pop	{r3, pc}
 80031c8:	2320      	movs	r3, #32
 80031ca:	f383 8811 	msr	BASEPRI, r3
 80031ce:	2100      	movs	r1, #0
 80031d0:	4804      	ldr	r0, [pc, #16]	; (80031e4 <Vector58+0x34>)
 80031d2:	f7fd fcc5 	bl	8000b60 <chThdDequeueAllI>
 80031d6:	2300      	movs	r3, #0
 80031d8:	f383 8811 	msr	BASEPRI, r3
 80031dc:	e7f1      	b.n	80031c2 <Vector58+0x12>
 80031de:	bf00      	nop
 80031e0:	40013c00 	.word	0x40013c00
 80031e4:	20000cdc 	.word	0x20000cdc
	...

080031f0 <__init_ram_areas>:
/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 80031f0:	4a0b      	ldr	r2, [pc, #44]	; (8003220 <__init_ram_areas+0x30>)
 80031f2:	e009      	b.n	8003208 <__init_ram_areas+0x18>
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 80031f4:	2100      	movs	r1, #0
 80031f6:	f843 1b04 	str.w	r1, [r3], #4
    while (p < rap->no_init_area) {
 80031fa:	68d1      	ldr	r1, [r2, #12]
 80031fc:	4299      	cmp	r1, r3
 80031fe:	d8f9      	bhi.n	80031f4 <__init_ram_areas+0x4>
      p++;
    }
    rap++;
 8003200:	3210      	adds	r2, #16
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 8003202:	4b08      	ldr	r3, [pc, #32]	; (8003224 <__init_ram_areas+0x34>)
 8003204:	429a      	cmp	r2, r3
 8003206:	d209      	bcs.n	800321c <__init_ram_areas+0x2c>
    uint32_t *tp = rap->init_text_area;
 8003208:	6810      	ldr	r0, [r2, #0]
    uint32_t *p = rap->init_area;
 800320a:	6853      	ldr	r3, [r2, #4]
    while (p < rap->clear_area) {
 800320c:	6891      	ldr	r1, [r2, #8]
 800320e:	4299      	cmp	r1, r3
 8003210:	d9f3      	bls.n	80031fa <__init_ram_areas+0xa>
      *p = *tp;
 8003212:	f850 1b04 	ldr.w	r1, [r0], #4
 8003216:	f843 1b04 	str.w	r1, [r3], #4
      tp++;
 800321a:	e7f7      	b.n	800320c <__init_ram_areas+0x1c>
#endif
}
 800321c:	4770      	bx	lr
 800321e:	bf00      	nop
 8003220:	080034b0 	.word	0x080034b0
 8003224:	08003530 	.word	0x08003530
	...

08003230 <__default_exit>:
  while (true) {
 8003230:	e7fe      	b.n	8003230 <__default_exit>
 8003232:	bf00      	nop
	...

08003240 <__late_init>:
void __late_init(void) {}
 8003240:	4770      	bx	lr
 8003242:	bf00      	nop
	...

08003250 <__core_init>:
}
 8003250:	4770      	bx	lr
 8003252:	bf00      	nop
